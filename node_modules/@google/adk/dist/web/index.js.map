{
  "version": 3,
  "sources": ["../../src/agents/active_streaming_tool.ts", "../../src/agents/base_agent.ts", "../../src/events/event_actions.ts", "../../src/events/event.ts", "../../src/telemetry/tracing.ts", "../../src/version.ts", "../../src/sessions/state.ts", "../../src/agents/readonly_context.ts", "../../src/agents/callback_context.ts", "../../src/utils/env_aware_utils.ts", "../../src/agents/invocation_context.ts", "../../src/agents/base_llm_processor.ts", "../../src/agents/functions.ts", "../../src/auth/auth_handler.ts", "../../src/tools/tool_confirmation.ts", "../../src/tools/tool_context.ts", "../../src/utils/logger.ts", "../../src/agents/live_request_queue.ts", "../../src/agents/llm_agent.ts", "../../src/code_executors/base_code_executor.ts", "../../src/utils/model_name.ts", "../../src/code_executors/built_in_code_executor.ts", "../../src/code_executors/code_execution_utils.ts", "../../src/code_executors/code_executor_context.ts", "../../src/utils/client_labels.ts", "../../src/models/base_llm.ts", "../../src/models/llm_request.ts", "../../src/models/google_llm.ts", "../../src/utils/variant_utils.ts", "../../src/models/gemini_llm_connection.ts", "../../src/models/llm_response.ts", "../../src/models/registry.ts", "../../src/tools/base_tool.ts", "../../src/tools/function_tool.ts", "../../src/utils/simple_zod_to_json.ts", "../../src/agents/content_processor_utils.ts", "../../src/agents/instructions.ts", "../../src/agents/run_config.ts", "../../src/agents/loop_agent.ts", "../../src/agents/parallel_agent.ts", "../../src/agents/sequential_agent.ts", "../../src/artifacts/in_memory_artifact_service.ts", "../../src/auth/auth_credential.ts", "../../src/examples/base_example_provider.ts", "../../src/memory/in_memory_memory_service.ts", "../../src/plugins/base_plugin.ts", "../../src/plugins/logging_plugin.ts", "../../src/plugins/plugin_manager.ts", "../../src/plugins/security_plugin.ts", "../../src/sessions/in_memory_session_service.ts", "../../src/sessions/base_session_service.ts", "../../src/sessions/session.ts", "../../src/runner/runner.ts", "../../src/runner/in_memory_runner.ts", "../../src/tools/agent_tool.ts", "../../src/tools/forwarding_artifact_service.ts", "../../src/tools/base_toolset.ts", "../../src/tools/google_search_tool.ts", "../../src/tools/long_running_tool.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {LiveRequestQueue} from './live_request_queue.js';\n\n/**\n * The parameters for creating an ActiveStreamingTool.\n */\nexport interface ActiveStreamingToolParams {\n  task?: Promise<void>;\n  stream?: LiveRequestQueue;\n}\n\n/**\n * Manages streaming tool related resources during invocation.\n */\nexport class ActiveStreamingTool {\n  /**\n   * The active task of this streaming tool.\n   * TODO: Replace 'Promise<void>' with a proper Task type if available in this\n   * env.\n   */\n  task?: Promise<void>;\n\n  /**\n   * The active (input) streams of this streaming tool.\n   */\n  stream?: LiveRequestQueue;\n\n  constructor(params: ActiveStreamingToolParams = {}) {\n    this.task = params.task;\n    this.stream = params.stream;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\nimport {context, trace} from '@opentelemetry/api';\n\nimport {createEvent, Event} from '../events/event.js';\n\nimport {\n  runAsyncGeneratorWithOtelContext,\n  traceAgentInvocation,\n  tracer,\n} from '../telemetry/tracing.js';\nimport {CallbackContext} from './callback_context.js';\nimport {InvocationContext} from './invocation_context.js';\n\n/**\n * A single callback function for an agent.\n */\nexport type SingleAgentCallback = (\n  context: CallbackContext,\n) => Promise<Content | undefined> | (Content | undefined);\n\n/**\n * Type for before agent callbacks, which can be a single callback or\n * an array of callbacks.\n */\nexport type BeforeAgentCallback = SingleAgentCallback | SingleAgentCallback[];\n\n/**\n * Type for after agent callbacks, which can be a single callback or\n * an array of callbacks.\n */\nexport type AfterAgentCallback = SingleAgentCallback | SingleAgentCallback[];\n\n/**\n * The config of a base agent.\n */\nexport interface BaseAgentConfig {\n  name: string;\n  description?: string;\n  parentAgent?: BaseAgent;\n  subAgents?: BaseAgent[];\n  beforeAgentCallback?: BeforeAgentCallback;\n  afterAgentCallback?: AfterAgentCallback;\n}\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all BaseAgent instances.\n */\nconst BASE_AGENT_SIGNATURE_SYMBOL = Symbol.for('google.adk.baseAgent');\n\n/**\n * Type guard to check if an object is an instance of BaseAgent.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseAgent, false otherwise.\n */\nexport function isBaseAgent(obj: unknown): obj is BaseAgent {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BASE_AGENT_SIGNATURE_SYMBOL in obj &&\n    obj[BASE_AGENT_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * Base class for all agents in Agent Development Kit.\n */\nexport abstract class BaseAgent {\n  /**\n   * A unique symbol to identify ADK agent classes.\n   */\n  readonly [BASE_AGENT_SIGNATURE_SYMBOL] = true;\n\n  /**\n   * The agent's name.\n   * Agent name must be a JS identifier and unique within the agent tree.\n   * Agent name cannot be \"user\", since it's reserved for end-user's input.\n   */\n  readonly name: string;\n\n  /**\n   * Description about the agent's capability.\n   *\n   * The model uses this to determine whether to delegate control to the agent.\n   * One-line description is enough and preferred.\n   */\n  readonly description?: string;\n\n  /**\n   * Root agent of this agent.\n   * Computed dynamically by traversing up the parent chain.\n   */\n  get rootAgent(): BaseAgent {\n    return getRootAgent(this);\n  }\n\n  /**\n   * The parent agent of this agent.\n   *\n   * Note that an agent can ONLY be added as sub-agent once.\n   *\n   * If you want to add one agent twice as sub-agent, consider to create two\n   * agent instances with identical config, but with different name and add them\n   * to the agent tree.\n   *\n   * The parent agent is the agent that created this agent.\n   */\n  parentAgent?: BaseAgent;\n\n  /**\n   * The sub-agents of this agent.\n   */\n  readonly subAgents: BaseAgent[];\n\n  /**\n   * Callback or list of callbacks to be invoked before the agent run.\n   *\n   * When a list of callbacks is provided, the callbacks will be called in the\n   * order they are listed until a callback does not return undefined.\n   *\n   * @param callbackContext: MUST be named 'callbackContext' (enforced).\n   *\n   * @return Content: The content to return to the user. When the content is\n   *     present, the agent run will be skipped and the provided content will be\n   *     returned to user.\n   */\n  readonly beforeAgentCallback: SingleAgentCallback[];\n\n  /**\n   * Callback or list of callbacks to be invoked after the agent run.\n   *\n   * When a list of callbacks is provided, the callbacks will be called in the\n   * order they are listed until a callback does not return undefined.\n   *\n   * @param callbackContext: MUST be named 'callbackContext' (enforced).\n   *\n   * @return Content: The content to return to the user. When the content is\n   *     present, the provided content will be used as agent response and\n   *     appended to event history as agent response.\n   */\n  readonly afterAgentCallback: SingleAgentCallback[];\n\n  constructor(config: BaseAgentConfig) {\n    this.name = validateAgentName(config.name);\n    this.description = config.description;\n    this.parentAgent = config.parentAgent;\n    this.subAgents = config.subAgents || [];\n    this.beforeAgentCallback = getCannonicalCallback(\n      config.beforeAgentCallback,\n    );\n    this.afterAgentCallback = getCannonicalCallback(config.afterAgentCallback);\n\n    this.setParentAgentForSubAgents();\n  }\n\n  /**\n   * Entry method to run an agent via text-based conversation.\n   *\n   * @param parentContext The invocation context of the parent agent.\n   * @yields The events generated by the agent.\n   * @returns An AsyncGenerator that yields the events generated by the agent.\n   */\n  async *runAsync(\n    parentContext: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    const span = tracer.startSpan(`invoke_agent ${this.name}`);\n    const ctx = trace.setSpan(context.active(), span);\n    try {\n      yield* runAsyncGeneratorWithOtelContext<BaseAgent, Event>(\n        ctx,\n        this,\n        async function* () {\n          const context = this.createInvocationContext(parentContext);\n\n          const beforeAgentCallbackEvent =\n            await this.handleBeforeAgentCallback(context);\n          if (beforeAgentCallbackEvent) {\n            yield beforeAgentCallbackEvent;\n          }\n\n          if (context.endInvocation) {\n            return;\n          }\n\n          traceAgentInvocation({agent: this, invocationContext: context});\n          for await (const event of this.runAsyncImpl(context)) {\n            yield event;\n          }\n\n          if (context.endInvocation) {\n            return;\n          }\n\n          const afterAgentCallbackEvent =\n            await this.handleAfterAgentCallback(context);\n          if (afterAgentCallbackEvent) {\n            yield afterAgentCallbackEvent;\n          }\n        },\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Entry method to run an agent via video/audio-based conversation.\n   *\n   * @param parentContext The invocation context of the parent agent.\n   * @yields The events generated by the agent.\n   * @returns An AsyncGenerator that yields the events generated by the agent.\n   */\n  async *runLive(\n    parentContext: InvocationContext, // eslint-disable-line @typescript-eslint/no-unused-vars\n  ): AsyncGenerator<Event, void, void> {\n    const span = tracer.startSpan(`invoke_agent ${this.name}`);\n    const ctx = trace.setSpan(context.active(), span);\n    try {\n      yield* runAsyncGeneratorWithOtelContext<BaseAgent, Event>(\n        ctx,\n        this,\n        async function* () {\n          // TODO(b/425992518): Implement live mode.\n        },\n      );\n      throw new Error('Live mode is not implemented yet.');\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Core logic to run this agent via text-based conversation.\n   *\n   * @param context The invocation context of the agent.\n   * @yields The events generated by the agent.\n   * @returns An AsyncGenerator that yields the events generated by the agent.\n   */\n  protected abstract runAsyncImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void>;\n\n  /**\n   * Core logic to run this agent via video/audio-based conversation.\n   *\n   * @param context The invocation context of the agent.\n   * @yields The events generated by the agent.\n   * @returns An AsyncGenerator that yields the events generated by the agent.\n   */\n  protected abstract runLiveImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void>;\n\n  /**\n   * Finds the agent with the given name in this agent and its descendants.\n   *\n   * @param name The name of the agent to find.\n   * @return The agent with the given name, or undefined if not found.\n   */\n  findAgent(name: string): BaseAgent | undefined {\n    if (this.name === name) {\n      return this;\n    }\n\n    return this.findSubAgent(name);\n  }\n\n  /**\n   * Finds the agent with the given name in this agent's descendants.\n   *\n   * @param name The name of the agent to find.\n   * @return The agent with the given name, or undefined if not found.\n   */\n  findSubAgent(name: string): BaseAgent | undefined {\n    for (const subAgent of this.subAgents) {\n      const result = subAgent.findAgent(name);\n      if (result) {\n        return result;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Creates an invocation context for this agent.\n   *\n   * @param parentContext The invocation context of the parent agent.\n   * @return The invocation context for this agent.\n   */\n  protected createInvocationContext(\n    parentContext: InvocationContext,\n  ): InvocationContext {\n    return new InvocationContext({\n      ...parentContext,\n      agent: this,\n    });\n  }\n\n  /**\n   * Runs the before agent callback if it exists.\n   *\n   * @param invocationContext The invocation context of the agent.\n   * @return The event to return to the user, or undefined if no event is\n   *     generated.\n   */\n  protected async handleBeforeAgentCallback(\n    invocationContext: InvocationContext,\n  ): Promise<Event | undefined> {\n    if (this.beforeAgentCallback.length === 0) {\n      return undefined;\n    }\n\n    const callbackContext = new CallbackContext({invocationContext});\n    for (const callback of this.beforeAgentCallback) {\n      const content = await callback(callbackContext);\n\n      if (content) {\n        invocationContext.endInvocation = true;\n\n        return createEvent({\n          invocationId: invocationContext.invocationId,\n          author: this.name,\n          branch: invocationContext.branch,\n          content,\n          actions: callbackContext.eventActions,\n        });\n      }\n    }\n\n    if (callbackContext.state.hasDelta()) {\n      return createEvent({\n        invocationId: invocationContext.invocationId,\n        author: this.name,\n        branch: invocationContext.branch,\n        actions: callbackContext.eventActions,\n      });\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Runs the after agent callback if it exists.\n   *\n   * @param invocationContext The invocation context of the agent.\n   * @return The event to return to the user, or undefined if no event is\n   *     generated.\n   */\n  protected async handleAfterAgentCallback(\n    invocationContext: InvocationContext,\n  ): Promise<Event | undefined> {\n    if (this.afterAgentCallback.length === 0) {\n      return undefined;\n    }\n\n    const callbackContext = new CallbackContext({invocationContext});\n    for (const callback of this.afterAgentCallback) {\n      const content = await callback(callbackContext);\n\n      if (content) {\n        return createEvent({\n          invocationId: invocationContext.invocationId,\n          author: this.name,\n          branch: invocationContext.branch,\n          content,\n          actions: callbackContext.eventActions,\n        });\n      }\n    }\n\n    if (callbackContext.state.hasDelta()) {\n      return createEvent({\n        invocationId: invocationContext.invocationId,\n        author: this.name,\n        branch: invocationContext.branch,\n        actions: callbackContext.eventActions,\n      });\n    }\n\n    return undefined;\n  }\n\n  private setParentAgentForSubAgents(): void {\n    for (const subAgent of this.subAgents) {\n      if (subAgent.parentAgent) {\n        throw new Error(\n          `Agent \"${\n            subAgent.name\n          }\" already has a parent agent, current parent: \"${\n            subAgent.parentAgent.name\n          }\", trying to add: \"${this.name}\"`,\n        );\n      }\n\n      subAgent.parentAgent = this;\n    }\n  }\n}\n\n/**\n * Validates the agent name.\n *\n * @param name The name of the agent.\n * @return The validated agent name.\n */\nfunction validateAgentName(name: string): string {\n  if (!isIdentifier(name)) {\n    throw new Error(\n      `Found invalid agent name: \"${\n        name\n      }\". Agent name must be a valid identifier. It should start with a letter (a-z, A-Z) or an underscore (_), and can only contain letters, digits (0-9), and underscores.`,\n    );\n  }\n\n  if (name === 'user') {\n    throw new Error(\n      `Agent name cannot be 'user'. 'user' is reserved for end-user's input.`,\n    );\n  }\n\n  return name;\n}\n\n/**\n * Checks if the given string is a valid identifier.\n *\n * @param str The string to check.\n * @return True if the string is a valid identifier, false otherwise.\n */\nfunction isIdentifier(str: string): boolean {\n  return /^[\\p{ID_Start}$_][\\p{ID_Continue}$_]*$/u.test(str);\n}\n\n/**\n * Gets the root agent of the given agent.\n *\n * @param rootAgent The root agent to get the root agent of.\n * @return The root agent.\n */\nfunction getRootAgent(rootAgent: BaseAgent): BaseAgent {\n  while (rootAgent.parentAgent) {\n    rootAgent = rootAgent.parentAgent;\n  }\n\n  return rootAgent;\n}\n\n/**\n * Gets the canonical callback from the given callback.\n *\n * @param callbacks The callback or list of callbacks to get the canonical\n *     callback from.\n * @return The canonical callback.\n */\nexport function getCannonicalCallback<T>(callbacks?: T | T[]): T[] {\n  if (!callbacks) {\n    return [];\n  }\n\n  return Array.isArray(callbacks) ? callbacks : [callbacks];\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ToolConfirmation} from '../tools/tool_confirmation.js';\n\n// TODO: b/425992518 - Replace 'any' with a proper AuthConfig.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AuthConfig = any;\n\n/**\n * Represents the actions attached to an event.\n */\nexport interface EventActions {\n  /**\n   * If true, it won't call model to summarize function response.\n   * Only used for function_response event.\n   */\n  skipSummarization?: boolean;\n\n  /**\n   * Indicates that the event is updating the state with the given delta.\n   */\n  stateDelta: {[key: string]: unknown};\n\n  /**\n   * Indicates that the event is updating an artifact. key is the filename,\n   * value is the version.\n   */\n  artifactDelta: {[key: string]: number};\n\n  /**\n   * If set, the event transfers to the specified agent.\n   */\n  transferToAgent?: string;\n\n  /**\n   * The agent is escalating to a higher level agent.\n   */\n  escalate?: boolean;\n\n  /**\n   * Authentication configurations requested by tool responses.\n   *\n   * This field will only be set by a tool response event indicating tool\n   * request auth credential.\n   * - Keys: The function call id. Since one function response event could\n   * contain multiple function responses that correspond to multiple function\n   * calls. Each function call could request different auth configs. This id is\n   * used to identify the function call.\n   * - Values: The requested auth config.\n   */\n  requestedAuthConfigs: {[key: string]: AuthConfig};\n\n  /**\n   * A dict of tool confirmation requested by this event, keyed by the function\n   * call id.\n   */\n  requestedToolConfirmations: {[key: string]: ToolConfirmation};\n}\n\n/**\n * Creates an EventActions object.\n */\nexport function createEventActions(\n  state: Partial<EventActions> = {},\n): EventActions {\n  return {\n    stateDelta: {},\n    artifactDelta: {},\n    requestedAuthConfigs: {},\n    requestedToolConfirmations: {},\n    ...state,\n  };\n}\n\n/**\n * Merges a list of EventActions objects into a single EventActions object.\n *\n * 1. It merges dictionaries (stateDelta, artifactDelta, requestedAuthConfigs)\n * by adding all the properties from each source.\n *\n * 2. For other properties (skipSummarization,transferToAgent, escalate), the\n * last one wins.\n */\nexport function mergeEventActions(\n  sources: Array<Partial<EventActions>>,\n  target?: EventActions,\n): EventActions {\n  const result = createEventActions();\n\n  if (target) {\n    Object.assign(result, target);\n  }\n\n  for (const source of sources) {\n    if (!source) continue;\n\n    if (source.stateDelta) {\n      Object.assign(result.stateDelta, source.stateDelta);\n    }\n    if (source.artifactDelta) {\n      Object.assign(result.artifactDelta, source.artifactDelta);\n    }\n    if (source.requestedAuthConfigs) {\n      Object.assign(result.requestedAuthConfigs, source.requestedAuthConfigs);\n    }\n    if (source.requestedToolConfirmations) {\n      Object.assign(\n        result.requestedToolConfirmations,\n        source.requestedToolConfirmations,\n      );\n    }\n\n    if (source.skipSummarization !== undefined) {\n      result.skipSummarization = source.skipSummarization;\n    }\n    if (source.transferToAgent !== undefined) {\n      result.transferToAgent = source.transferToAgent;\n    }\n    if (source.escalate !== undefined) {\n      result.escalate = source.escalate;\n    }\n  }\n  return result;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {FunctionCall, FunctionResponse} from '@google/genai';\n\nimport {LlmResponse} from '../models/llm_response.js';\n\nimport {createEventActions, EventActions} from './event_actions.js';\n\n/**\n * Represents an event in a conversation between agents and users.\n\n  It is used to store the content of the conversation, as well as the actions\n  taken by the agents like function calls, etc.\n */\nexport interface Event extends LlmResponse {\n  /**\n   * The unique identifier of the event.\n   * Do not assign the ID. It will be assigned by the session.\n   */\n  id: string;\n\n  /**\n   * The invocation ID of the event. Should be non-empty before appending to a\n   * session.\n   */\n  invocationId: string;\n\n  /**\n   * \"user\" or the name of the agent, indicating who appended the event to the\n   * session.\n   */\n  author?: string;\n\n  /**\n   * The actions taken by the agent.\n   */\n  actions: EventActions;\n\n  /**\n   * Set of ids of the long running function calls. Agent client will know from\n   * this field about which function call is long running. Only valid for\n   * function call event\n   */\n  longRunningToolIds?: string[];\n\n  /**\n   * The branch of the event.\n   * The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of\n   * agent_2, and agent_2 is the parent of agent_3.\n   *\n   * Branch is used when multiple sub-agent shouldn't see their peer agents'\n   * conversation history.\n   */\n  branch?: string;\n\n  /**\n   * The timestamp of the event.\n   */\n  timestamp: number;\n}\n\n/**\n * Creates an event from a partial event.\n *\n * @param params The partial event to create the event from.\n * @returns The event.\n */\nexport function createEvent(params: Partial<Event> = {}): Event {\n  return {\n    ...params,\n    id: params.id || createNewEventId(),\n    invocationId: params.invocationId || '',\n    author: params.author,\n    actions: params.actions || createEventActions(),\n    longRunningToolIds: params.longRunningToolIds || [],\n    branch: params.branch,\n    timestamp: params.timestamp || Date.now(),\n  };\n}\n\n/**\n * Returns whether the event is the final response of the agent.\n */\nexport function isFinalResponse(event: Event) {\n  if (\n    event.actions.skipSummarization ||\n    (event.longRunningToolIds && event.longRunningToolIds.length > 0)\n  ) {\n    return true;\n  }\n\n  return (\n    getFunctionCalls(event).length === 0 &&\n    getFunctionResponses(event).length === 0 &&\n    !event.partial &&\n    !hasTrailingCodeExecutionResult(event)\n  );\n}\n\n/**\n * Returns the function calls in the event.\n */\nexport function getFunctionCalls(event: Event): FunctionCall[] {\n  const funcCalls = [];\n  if (event.content && event.content.parts) {\n    for (const part of event.content.parts) {\n      if (part.functionCall) {\n        funcCalls.push(part.functionCall);\n      }\n    }\n  }\n\n  return funcCalls;\n}\n\n/**\n * Returns the function responses in the event.\n */\nexport function getFunctionResponses(event: Event): FunctionResponse[] {\n  const funcResponses = [];\n  if (event.content && event.content.parts) {\n    for (const part of event.content.parts) {\n      if (part.functionResponse) {\n        funcResponses.push(part.functionResponse);\n      }\n    }\n  }\n\n  return funcResponses;\n}\n\n/**\n * Returns whether the event has a trailing code execution result.\n */\nexport function hasTrailingCodeExecutionResult(event: Event): boolean {\n  if (event.content && event.content.parts?.length) {\n    const lastPart = event.content.parts[event.content.parts.length - 1];\n    return lastPart.codeExecutionResult !== undefined;\n  }\n\n  return false;\n}\n\n/**\n * Extracts and concatenates all text from the parts of a `Event` object.\n * @param event The `Event` object to process.\n *\n * @returns A single string with the combined text.\n */\nexport function stringifyContent(event: Event): string {\n  if (!event.content?.parts) {\n    return '';\n  }\n\n  return event.content.parts.map((part) => part.text ?? '').join('');\n}\n\nconst ASCII_LETTERS_AND_NUMBERS =\n  'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n\n/**\n * Generates a new unique ID for the event.\n */\nexport function createNewEventId(): string {\n  let id = '';\n\n  for (let i = 0; i < 8; i++) {\n    id +=\n      ASCII_LETTERS_AND_NUMBERS[\n        Math.floor(Math.random() * ASCII_LETTERS_AND_NUMBERS.length)\n      ];\n  }\n\n  return id;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * NOTE:\n *\n *    We expect that the underlying GenAI SDK will provide a certain\n *    level of tracing and logging telemetry aligned with Open Telemetry\n *    Semantic Conventions (such as logging prompts, responses,\n *    request properties, etc.) and so the information that is recorded by the\n *    Agent Development Kit should be focused on the higher-level\n *    constructs of the framework that are not observable by the SDK.\n */\n\nimport {Content} from '@google/genai';\nimport {context, Context, trace} from '@opentelemetry/api';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {Event} from '../events/event.js';\nimport {LlmRequest} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {version} from '../version.js';\n\nconst GEN_AI_AGENT_DESCRIPTION = 'gen_ai.agent.description';\nconst GEN_AI_AGENT_NAME = 'gen_ai.agent.name';\nconst GEN_AI_CONVERSATION_ID = 'gen_ai.conversation.id';\nconst GEN_AI_OPERATION_NAME = 'gen_ai.operation.name';\nconst GEN_AI_TOOL_CALL_ID = 'gen_ai.tool.call.id';\nconst GEN_AI_TOOL_DESCRIPTION = 'gen_ai.tool.description';\nconst GEN_AI_TOOL_NAME = 'gen_ai.tool.name';\nconst GEN_AI_TOOL_TYPE = 'gen_ai.tool.type';\n\nexport const tracer = trace.getTracer('gcp.vertex.agent', version);\n\n/**\n * Convert any JavaScript object to a JSON-serializable string.\n *\n * @param obj The object to serialize.\n * @returns The JSON-serialized object string or '<not serializable>' if the object cannot be serialized.\n */\nfunction safeJsonSerialize(obj: unknown): string {\n  try {\n    return JSON.stringify(obj);\n  } catch (_e: unknown) {\n    return '<not serializable>';\n  }\n}\n\nexport interface TraceAgentInvocationParams {\n  agent: BaseAgent;\n  invocationContext: InvocationContext;\n}\n\n/**\n * Sets span attributes immediately available on agent invocation according to OTEL semconv version 1.37.\n *\n * @param params The parameters object containing agent and invocation context.\n *\n * Inference related fields are not set, due to their planned removal from invoke_agent span:\n * https://github.com/open-telemetry/semantic-conventions/issues/2632\n *\n * `gen_ai.agent.id` is not set because currently it's unclear what attributes this field should have, specifically:\n * - In which scope should it be unique (globally, given project, given agentic flow, given deployment).\n * - Should it be unchanging between deployments, and how this should this be achieved.\n *\n * `gen_ai.data_source.id` is not set because it's not available.\n * Closest type which could contain this information is types.GroundingMetadata, which does not have an ID.\n *\n * `server.*` attributes are not set pending confirmation from aabmass.\n */\nexport function traceAgentInvocation({\n  agent,\n  invocationContext,\n}: TraceAgentInvocationParams): void {\n  const span = trace.getActiveSpan();\n  if (!span) return;\n\n  // Required\n  span.setAttributes({\n    [GEN_AI_OPERATION_NAME]: 'invoke_agent',\n    // Conditionally Required\n    [GEN_AI_AGENT_DESCRIPTION]: agent.description,\n    [GEN_AI_AGENT_NAME]: agent.name,\n    [GEN_AI_CONVERSATION_ID]: invocationContext.session.id,\n  });\n}\n\nexport interface TraceToolCallParams {\n  tool: BaseTool;\n  args: Record<string, unknown>;\n  functionResponseEvent: Event;\n}\n\n/**\n * Traces tool call.\n *\n * @param params The parameters object containing tool, args, and function response event.\n */\nexport function traceToolCall({\n  tool,\n  args,\n  functionResponseEvent,\n}: TraceToolCallParams): void {\n  const span = trace.getActiveSpan();\n  if (!span) return;\n\n  span.setAttributes({\n    [GEN_AI_OPERATION_NAME]: 'execute_tool',\n    [GEN_AI_TOOL_DESCRIPTION]: tool.description || '',\n    [GEN_AI_TOOL_NAME]: tool.name,\n    // e.g. FunctionTool\n    [GEN_AI_TOOL_TYPE]: tool.constructor.name,\n    // Setting empty llm request and response (as UI expect these) while not\n    // applicable for tool_response.\n    'gcp.vertex.agent.llm_request': '{}',\n    'gcp.vertex.agent.llm_response': '{}',\n    'gcp.vertex.agent.tool_call_args': shouldAddRequestResponseToSpans()\n      ? safeJsonSerialize(args)\n      : '{}',\n  });\n\n  // Tracing tool response\n  let toolCallId = '<not specified>';\n  let toolResponse: unknown = '<not specified>';\n\n  if (functionResponseEvent.content?.parts) {\n    const responseParts = functionResponseEvent.content.parts;\n    const functionResponse = responseParts[0]?.functionResponse;\n    if (functionResponse?.id) {\n      toolCallId = functionResponse.id;\n    }\n    if (functionResponse?.response) {\n      toolResponse = functionResponse.response;\n    }\n  }\n  if (typeof toolResponse !== 'object' || toolResponse === null) {\n    toolResponse = {result: toolResponse};\n  }\n\n  span.setAttributes({\n    [GEN_AI_TOOL_CALL_ID]: toolCallId,\n    'gcp.vertex.agent.event_id': functionResponseEvent.id,\n    'gcp.vertex.agent.tool_response': shouldAddRequestResponseToSpans()\n      ? safeJsonSerialize(toolResponse)\n      : '{}',\n  });\n}\n\nexport interface TraceMergedToolCallsParams {\n  responseEventId: string;\n  functionResponseEvent: Event;\n}\n\n/**\n * Traces merged tool call events.\n *\n * Calling this function is not needed for telemetry purposes. This is provided\n * for preventing /debug/trace requests (typically sent by web UI).\n *\n * @param params The parameters object containing response event ID and function response event.\n */\nexport function traceMergedToolCalls({\n  responseEventId,\n  functionResponseEvent,\n}: TraceMergedToolCallsParams): void {\n  const span = trace.getActiveSpan();\n  if (!span) return;\n\n  span.setAttributes({\n    [GEN_AI_OPERATION_NAME]: 'execute_tool',\n    [GEN_AI_TOOL_NAME]: '(merged tools)',\n    [GEN_AI_TOOL_DESCRIPTION]: '(merged tools)',\n    [GEN_AI_TOOL_CALL_ID]: responseEventId,\n    'gcp.vertex.agent.tool_call_args': 'N/A',\n    'gcp.vertex.agent.event_id': responseEventId,\n    // Setting empty llm request and response (as UI expect these) while not\n    // applicable for tool_response.\n    'gcp.vertex.agent.llm_request': '{}',\n    'gcp.vertex.agent.llm_response': '{}',\n  });\n\n  span.setAttribute(\n    'gcp.vertex.agent.tool_response',\n    shouldAddRequestResponseToSpans()\n      ? safeJsonSerialize(functionResponseEvent)\n      : '{}',\n  );\n}\n\nexport interface TraceCallLlmParams {\n  invocationContext: InvocationContext;\n  eventId: string;\n  llmRequest: LlmRequest;\n  llmResponse: LlmResponse;\n}\n\n/**\n * Traces a call to the LLM.\n *\n * This function records details about the LLM request and response as\n * attributes on the current OpenTelemetry span.\n *\n * @param params The parameters object containing invocationContext, eventId, llmRequest, and llmResponse.\n */\nexport function traceCallLlm({\n  invocationContext,\n  eventId,\n  llmRequest,\n  llmResponse,\n}: TraceCallLlmParams): void {\n  // Special standard Open Telemetry GenAI attributes that indicate\n  // that this is a span related to a Generative AI system.\n  const span = trace.getActiveSpan();\n  if (!span) return;\n\n  span.setAttributes({\n    'gen_ai.system': 'gcp.vertex.agent',\n    'gen_ai.request.model': llmRequest.model,\n    'gcp.vertex.agent.invocation_id': invocationContext.invocationId,\n    'gcp.vertex.agent.session_id': invocationContext.session.id,\n    'gcp.vertex.agent.event_id': eventId,\n    // Consider removing once GenAI SDK provides a way to record this info.\n    'gcp.vertex.agent.llm_request': shouldAddRequestResponseToSpans()\n      ? safeJsonSerialize(buildLlmRequestForTrace(llmRequest))\n      : '{}',\n  });\n\n  // Consider removing once GenAI SDK provides a way to record this info.\n  if (llmRequest.config?.topP) {\n    span.setAttribute('gen_ai.request.top_p', llmRequest.config.topP);\n  }\n\n  if (llmRequest.config?.maxOutputTokens !== undefined) {\n    span.setAttribute(\n      'gen_ai.request.max_tokens',\n      llmRequest.config.maxOutputTokens,\n    );\n  }\n\n  span.setAttribute(\n    'gcp.vertex.agent.llm_response',\n    shouldAddRequestResponseToSpans() ? safeJsonSerialize(llmResponse) : '{}',\n  );\n\n  if (llmResponse.usageMetadata) {\n    span.setAttribute(\n      'gen_ai.usage.input_tokens',\n      llmResponse.usageMetadata.promptTokenCount || 0,\n    );\n  }\n\n  if (llmResponse.usageMetadata?.candidatesTokenCount) {\n    span.setAttribute(\n      'gen_ai.usage.output_tokens',\n      llmResponse.usageMetadata.candidatesTokenCount,\n    );\n  }\n\n  if (llmResponse.finishReason) {\n    // Convert enum to lowercase string array\n    const finishReasonValue =\n      typeof llmResponse.finishReason === 'string'\n        ? llmResponse.finishReason.toLowerCase()\n        : String(llmResponse.finishReason).toLowerCase();\n    span.setAttribute('gen_ai.response.finish_reasons', [finishReasonValue]);\n  }\n}\n\nexport interface TraceSendDataParams {\n  /** The invocation context for the current agent run. */\n  invocationContext: InvocationContext;\n  /** The ID of the event. */\n  eventId: string;\n  /** A list of content objects. */\n  data: Content[];\n}\n\n/**\n * Traces the sending of data to the agent.\n *\n * This function records details about the data sent to the agent as\n * attributes on the current OpenTelemetry span.\n *\n * @param params The parameters object containing invocationContext, eventId, and data.\n */\nexport function traceSendData({\n  invocationContext,\n  eventId,\n  data,\n}: TraceSendDataParams): void {\n  const span = trace.getActiveSpan();\n  if (!span) return;\n\n  span.setAttributes({\n    'gcp.vertex.agent.invocation_id': invocationContext.invocationId,\n    'gcp.vertex.agent.event_id': eventId,\n  });\n\n  // Once instrumentation is added to the GenAI SDK, consider whether this\n  // information still needs to be recorded by the Agent Development Kit.\n\n  span.setAttribute(\n    'gcp.vertex.agent.data',\n    shouldAddRequestResponseToSpans() ? safeJsonSerialize(data) : '{}',\n  );\n}\n\n/**\n * Builds a dictionary representation of the LLM request for tracing.\n *\n * This function prepares a dictionary representation of the LlmRequest\n * object, suitable for inclusion in a trace. It excludes fields that cannot\n * be serialized (e.g., function pointers) and avoids sending bytes data.\n *\n * @param llmRequest The LlmRequest object.\n * @returns A dictionary representation of the LLM request.\n */\nfunction buildLlmRequestForTrace(\n  llmRequest: LlmRequest,\n): Record<string, unknown> {\n  const result: Record<string, unknown> = {\n    model: llmRequest.model,\n    contents: [],\n  };\n\n  if (llmRequest.config) {\n    // Create a clean config object, pruning responseSchema to reduce noise size\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {responseSchema, ...cleanConfig} = llmRequest.config;\n    result.config = cleanConfig;\n  }\n\n  // We do not want to send bytes data to the trace.\n  result.contents = llmRequest.contents.map((content) => ({\n    role: content.role,\n    parts: content.parts?.filter((part) => !part.inlineData) || [],\n  }));\n\n  return result;\n}\n\n/**\n * Binds an async generator to OpenTelemetry context for trace propagation.\n * This is a temporary solution.\n * @param ctx - The OpenTelemetry context to bind the generator to\n * @param generator - The async generator to be bound to the context\n *\n * @returns A new async generator that executes all operations within the provided context\n */\nfunction bindOtelContextToAsyncGenerator<T>(\n  ctx: Context,\n  generator: AsyncGenerator<T, void, void>,\n): AsyncGenerator<T, void, void> {\n  return {\n    // Bind the next() method to execute within the provided context\n    next: context.bind(ctx, generator.next.bind(generator)),\n\n    // Bind the return() method to execute within the provided context\n    return: context.bind(ctx, generator.return.bind(generator)),\n\n    // Bind the throw() method to execute within the provided context\n    throw: context.bind(ctx, generator.throw.bind(generator)),\n\n    // Ensure the async iterator symbol also returns a context-bound generator\n    [Symbol.asyncIterator]() {\n      return bindOtelContextToAsyncGenerator(\n        ctx,\n        generator[Symbol.asyncIterator](),\n      );\n    },\n  };\n}\n\n/**\n * Runs an async generator function with both OTEL context and JavaScript 'this' context.\n *\n * @param otelContext - The OpenTelemetry context to bind the generator to\n * @param generatorFnContext - The 'this' context to bind to the generator function\n * @param generatorFn - The generator function to execute\n *\n * @returns A new async generator that executes within both contexts\n */\nexport function runAsyncGeneratorWithOtelContext<TThis, T>(\n  otelContext: Context,\n  generatorFnContext: TThis,\n  generatorFn: (this: TThis) => AsyncGenerator<T, void, void>,\n): AsyncGenerator<T, void, void> {\n  const generator = generatorFn.call(generatorFnContext);\n  return bindOtelContextToAsyncGenerator(otelContext, generator);\n}\n\n/**\n * Determines whether to add request/response content to spans.\n *\n * Defaults to true for now to preserve backward compatibility.\n * Once prompt and response logging is well established in ADK, we might start\n * a deprecation of request/response content in spans by switching the default\n * to false.\n *\n * @returns false only when ADK_CAPTURE_MESSAGE_CONTENT_IN_SPANS is explicitly set to 'false' or '0'\n */\nfunction shouldAddRequestResponseToSpans(): boolean {\n  const envValue = process.env.ADK_CAPTURE_MESSAGE_CONTENT_IN_SPANS || 'true';\n  return envValue === 'true' || envValue === '1';\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n// version: major.minor.patch\nexport const version = '0.3.0'; // x-release-please-version\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * A state mapping that maintains the current value and the pending-commit\n * delta.\n */\nexport class State {\n  static readonly APP_PREFIX = 'app:';\n  static readonly USER_PREFIX = 'user:';\n  static readonly TEMP_PREFIX = 'temp:';\n\n  constructor(\n    /** The current value of the state. */\n    private value: Record<string, unknown> = {},\n    /** The delta change to the current value that hasn't been committed. */\n    private delta: Record<string, unknown> = {},\n  ) {}\n\n  /**\n   * Returns the value of the state dict for the given key.\n   *\n   * @param key The key to get the value for.\n   * @param defaultValue The default value to return if the key is not found.\n   * @return The value of the state for the given key, or the default value if\n   *     not found.\n   */\n  get<T>(key: string, defaultValue?: T): T | undefined {\n    if (key in this.delta) {\n      return this.delta[key] as T;\n    }\n\n    if (key in this.value) {\n      return this.value[key] as T;\n    }\n\n    return defaultValue;\n  }\n\n  /**\n   * Sets the value of the state dict for the given key.\n   *\n   * @param key The key to set the value for.\n   * @param value The value to set.\n   */\n  set(key: string, value: unknown) {\n    this.value[key] = value;\n    this.delta[key] = value;\n  }\n\n  /**\n   * Whether the state has pending delta.\n   */\n  has(key: string): boolean {\n    return key in this.value || key in this.delta;\n  }\n\n  /**\n   * Whether the state has pending delta.\n   */\n  hasDelta(): boolean {\n    return Object.keys(this.delta).length > 0;\n  }\n\n  /**\n   * Updates the state dict with the given delta.\n   *\n   * @param delta The delta to update the state with.\n   */\n  update(delta: Record<string, unknown>) {\n    this.delta = {...this.delta, ...delta};\n    this.value = {...this.value, ...delta};\n  }\n\n  /**\n   * Returns the state as a plain JSON object.\n   */\n  toRecord(): Record<string, unknown> {\n    return {...this.value, ...this.delta};\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\n\nimport {State} from '../sessions/state.js';\n\nimport {InvocationContext} from './invocation_context.js';\n\n/**\n * A readonly context represents the data of a single invocation of an agent.\n */\nexport class ReadonlyContext {\n  constructor(readonly invocationContext: InvocationContext) {}\n\n  /**\n   * The user content that started this invocation.\n   */\n  get userContent(): Content | undefined {\n    return this.invocationContext.userContent;\n  }\n\n  /**\n   * The current invocation id.\n   */\n  get invocationId(): string {\n    return this.invocationContext.invocationId;\n  }\n\n  /**\n   * The current agent name.\n   */\n  get agentName(): string {\n    return this.invocationContext.agent.name;\n  }\n\n  /**\n   * The state of the current session.\n   */\n  get state(): Readonly<State> {\n    return new State(\n      this.invocationContext.session.state,\n      {},\n    ) as Readonly<State>;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Part} from '@google/genai';\n\nimport {createEventActions, EventActions} from '../events/event_actions.js';\nimport {State} from '../sessions/state.js';\n\nimport {InvocationContext} from './invocation_context.js';\nimport {ReadonlyContext} from './readonly_context.js';\n\n/**\n * The context of various callbacks within an agent run.\n */\nexport class CallbackContext extends ReadonlyContext {\n  private readonly _state: State;\n\n  readonly eventActions: EventActions;\n\n  constructor({\n    invocationContext,\n    eventActions,\n  }: {\n    invocationContext: InvocationContext;\n    eventActions?: EventActions;\n  }) {\n    super(invocationContext);\n    this.eventActions = eventActions || createEventActions();\n    this._state = new State(\n      invocationContext.session.state,\n      this.eventActions.stateDelta,\n    );\n  }\n\n  /**\n   * The delta-aware state of the current session.\n   */\n  override get state() {\n    return this._state;\n  }\n\n  /**\n   * Loads an artifact attached to the current session.\n   *\n   * @param filename The filename of the artifact.\n   * @param version The version of the artifact. If not provided, the latest\n   *     version will be used.\n   * @return A promise that resolves to the loaded artifact.\n   */\n  loadArtifact(filename: string, version?: number): Promise<Part | undefined> {\n    if (!this.invocationContext.artifactService) {\n      throw new Error('Artifact service is not initialized.');\n    }\n\n    return this.invocationContext.artifactService.loadArtifact({\n      appName: this.invocationContext.appName,\n      userId: this.invocationContext.userId,\n      sessionId: this.invocationContext.session.id,\n      filename,\n      version,\n    });\n  }\n\n  /**\n   * Saves an artifact attached to the current session.\n   *\n   * @param filename The filename of the artifact.\n   * @param artifact The artifact to save.\n   * @return A promise that resolves to the version of the saved artifact.\n   */\n  async saveArtifact(filename: string, artifact: Part): Promise<number> {\n    if (!this.invocationContext.artifactService) {\n      throw new Error('Artifact service is not initialized.');\n    }\n\n    const version = await this.invocationContext.artifactService.saveArtifact({\n      appName: this.invocationContext.appName,\n      userId: this.invocationContext.userId,\n      sessionId: this.invocationContext.session.id,\n      filename,\n      artifact,\n    });\n    this.eventActions.artifactDelta[filename] = version;\n\n    return version;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Returns true if the environment is a browser.\n */\nexport function isBrowser() {\n  return typeof window !== 'undefined';\n}\n\n/**\n * Generates a random UUID.\n */\nconst UUID_MASK = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\nexport function randomUUID() {\n  let uuid = '';\n\n  for (let i = 0; i < UUID_MASK.length; i++) {\n    const randomValue = (Math.random() * 16) | 0;\n\n    if (UUID_MASK[i] === 'x') {\n      uuid += randomValue.toString(16);\n    } else if (UUID_MASK[i] === 'y') {\n      uuid += ((randomValue & 0x3) | 0x8).toString(16);\n    } else {\n      uuid += UUID_MASK[i];\n    }\n  }\n\n  return uuid;\n}\n\n/**\n * Encodes the given string to base64.\n *\n * @param data The string to encode.\n * @return The base64-encoded string.\n */\nexport function base64Encode(data: string): string {\n  if (isBrowser()) {\n    // eslint-disable-next-line no-undef\n    return window.btoa(data);\n  }\n\n  return Buffer.from(data).toString('base64');\n}\n\n/**\n * Decodes the given base64 string to a string.\n *\n * @param data The base64-encoded string.\n * @return The decoded string.\n */\nexport function base64Decode(data: string): string {\n  if (isBrowser()) {\n    // eslint-disable-next-line no-undef\n    return window.atob(data);\n  }\n\n  return Buffer.from(data, 'base64').toString();\n}\n\n/**\n * Checks if the given string is base64-encoded.\n *\n * @param data The string to check.\n * @return True if the string is base64-encoded, false otherwise.\n */\nexport function isBase64Encoded(data: string): boolean {\n  try {\n    return base64Encode(base64Decode(data)) === data;\n  } catch (_e: unknown) {\n    return false;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\n\nimport {BaseArtifactService} from '../artifacts/base_artifact_service.js';\nimport {BaseCredentialService} from '../auth/credential_service/base_credential_service.js';\nimport {BaseMemoryService} from '../memory/base_memory_service.js';\nimport {PluginManager} from '../plugins/plugin_manager.js';\nimport {BaseSessionService} from '../sessions/base_session_service.js';\nimport {Session} from '../sessions/session.js';\nimport {randomUUID} from '../utils/env_aware_utils.js';\n\nimport {ActiveStreamingTool} from './active_streaming_tool.js';\nimport {BaseAgent} from './base_agent.js';\nimport {LiveRequestQueue} from './live_request_queue.js';\nimport {RunConfig} from './run_config.js';\nimport {TranscriptionEntry} from './transcription_entry.js';\n\n/**\n * The parameters for creating an invocation context.\n */\nexport interface InvocationContextParams {\n  artifactService?: BaseArtifactService;\n  sessionService?: BaseSessionService;\n  memoryService?: BaseMemoryService;\n  credentialService?: BaseCredentialService;\n  invocationId: string;\n  branch?: string;\n  agent: BaseAgent;\n  userContent?: Content;\n  session: Session;\n  endInvocation?: boolean;\n  transcriptionCache?: TranscriptionEntry[];\n  runConfig?: RunConfig;\n  liveRequestQueue?: LiveRequestQueue;\n  activeStreamingTools?: Record<string, ActiveStreamingTool>;\n  pluginManager: PluginManager;\n}\n\n/**\n * A container to keep track of the cost of invocation.\n *\n * While we don't expect the metrics captured here to be a direct\n * representative of monetary cost incurred in executing the current\n * invocation, they in some ways have an indirect effect.\n */\nclass InvocationCostManager {\n  private numberOfLlmCalls: number = 0;\n\n  /**\n   * Increments the number of llm calls and enforces the limit.\n   *\n   * @param runConfig the run config of the invocation.\n   * @throws If number of llm calls made exceed the set threshold.\n   */\n  incrementAndEnforceLlmCallsLimit(runConfig?: RunConfig) {\n    this.numberOfLlmCalls++;\n\n    if (\n      runConfig &&\n      runConfig.maxLlmCalls! > 0 &&\n      this.numberOfLlmCalls > runConfig.maxLlmCalls!\n    ) {\n      throw new Error(\n        `Max number of llm calls limit of ${runConfig.maxLlmCalls!} exceeded`,\n      );\n    }\n  }\n}\n\n/**\n * An invocation context represents the data of a single invocation of an agent.\n *\n * An invocation:\n *     1. Starts with a user message and ends with a final response.\n *     2. Can contain one or multiple agent calls.\n *     3. Is handled by runner.runAsync().\n *\n *   An invocation runs an agent until it does not request to transfer to\n * another agent.\n *\n *   An agent call:\n *     1. Is handled by agent.runAsync().\n *     2. Ends when agent.runAsync() ends.\n *\n *   An LLM agent call is an agent with a BaseLLMFlow.\n *  An LLM agent call can contain one or multiple steps.\n *\n *  An LLM agent runs steps in a loop until:\n *    1. A final response is generated.\n *    2. The agent transfers to another agent.\n *    3. The end_invocation is set to true by any callbacks or tools.\n *\n *  A step:\n *    1. Calls the LLM only once and yields its response.\n *   2. Calls the tools and yields their responses if requested.\n *\n *  The summarization of the function response is considered another step, since\n *  it is another llm call.\n *  A step ends when it's done calling llm and tools, or if the end_invocation\n *  is set to true at any time.\n *\n *  ```\n *     \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 invocation \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *     \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 llm_agent_call_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250C\u2500 agent_call_2 \u2500\u2510\n *     \u250C\u2500\u2500\u2500\u2500 step_1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250C\u2500\u2500\u2500\u2500\u2500 step_2 \u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *     [call_llm] [call_tool] [call_llm] [transfer]\n *  ```\n */\nexport class InvocationContext {\n  readonly artifactService?: BaseArtifactService;\n  readonly sessionService?: BaseSessionService;\n  readonly memoryService?: BaseMemoryService;\n  readonly credentialService?: BaseCredentialService;\n\n  /**\n   * The id of this invocation context.\n   */\n  readonly invocationId: string;\n\n  /**\n   * The branch of the invocation context.\n   *\n   * The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of\n   * agent_2, and agent_2 is the parent of agent_3.\n   *\n   * Branch is used when multiple sub-agents shouldn't see their peer agents'\n   * conversation history.\n   */\n  branch?: string;\n\n  /**\n   * The current agent of this invocation context.\n   */\n  agent: BaseAgent;\n\n  /**\n   * The user content that started this invocation.\n   */\n  readonly userContent?: Content;\n\n  /**\n   * The current session of this invocation context.\n   */\n  readonly session: Session;\n\n  /**\n   * Whether to end this invocation.\n   * Set to True in callbacks or tools to terminate this invocation.\n   */\n  endInvocation: boolean;\n\n  /**\n   * Caches necessary, data audio or contents, that are needed by transcription.\n   */\n  transcriptionCache?: TranscriptionEntry[];\n\n  /**\n   * Configurations for live agents under this invocation.\n   */\n  runConfig?: RunConfig;\n\n  /**\n   * A container to keep track of different kinds of costs incurred as a part of\n   * this invocation.\n   */\n  private readonly invocationCostManager = new InvocationCostManager();\n\n  /**\n   * The queue to receive live requests.\n   */\n  liveRequestQueue?: LiveRequestQueue;\n\n  /**\n   * The running streaming tools of this invocation.\n   */\n  activeStreamingTools?: Record<string, ActiveStreamingTool>;\n\n  /**\n   * The manager for keeping track of plugins in this invocation.\n   */\n  pluginManager: PluginManager;\n\n  /**\n   * @param params The parameters for creating an invocation context.\n   */\n  constructor(params: InvocationContextParams) {\n    this.artifactService = params.artifactService;\n    this.sessionService = params.sessionService;\n    this.memoryService = params.memoryService;\n    this.invocationId = params.invocationId;\n    this.branch = params.branch;\n    this.agent = params.agent;\n    this.userContent = params.userContent;\n    this.session = params.session;\n    this.endInvocation = params.endInvocation || false;\n    this.transcriptionCache = params.transcriptionCache;\n    this.runConfig = params.runConfig;\n    this.liveRequestQueue = params.liveRequestQueue;\n    this.activeStreamingTools = params.activeStreamingTools;\n    this.pluginManager = params.pluginManager;\n  }\n\n  /**\n   * The app name of the current session.\n   */\n  get appName() {\n    return this.session.appName;\n  }\n\n  /**\n   * The user ID of the current session.\n   */\n  get userId() {\n    return this.session.userId;\n  }\n\n  /**\n   * Tracks number of llm calls made.\n   *\n   * @throws If number of llm calls made exceed the set threshold.\n   */\n  incrementLlmCallCount() {\n    this.invocationCostManager.incrementAndEnforceLlmCallsLimit(this.runConfig);\n  }\n}\n\nexport function newInvocationContextId(): string {\n  return `e-${randomUUID()}`;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {Event} from '../events/event.js';\nimport {LlmRequest} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\n\n/**\n * Base class for LLM request processor.\n */\nexport abstract class BaseLlmRequestProcessor {\n  /**\n   * Runs the processor.\n   */\n  abstract runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void>;\n}\n\n/**\n * Base class for LLM response processor.\n */\nexport abstract class BaseLlmResponseProcessor {\n  /**\n   * Processes the LLM response.\n   */\n  abstract runAsync(\n    invocationContext: InvocationContext,\n    llmResponse: LlmResponse,\n  ): AsyncGenerator<Event, void, void>;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content, createUserContent, FunctionCall, Part} from '@google/genai';\nimport {isEmpty} from 'lodash-es';\n\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {createEvent, Event, getFunctionCalls} from '../events/event.js';\nimport {mergeEventActions} from '../events/event_actions.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {ToolConfirmation} from '../tools/tool_confirmation.js';\nimport {ToolContext} from '../tools/tool_context.js';\nimport {randomUUID} from '../utils/env_aware_utils.js';\nimport {logger} from '../utils/logger.js';\n\nimport {\n  traceMergedToolCalls,\n  tracer,\n  traceToolCall,\n} from '../telemetry/tracing.js';\nimport {\n  SingleAfterToolCallback,\n  SingleBeforeToolCallback,\n} from './llm_agent.js';\n\nconst AF_FUNCTION_CALL_ID_PREFIX = 'adk-';\nexport const REQUEST_EUC_FUNCTION_CALL_NAME = 'adk_request_credential';\nexport const REQUEST_CONFIRMATION_FUNCTION_CALL_NAME =\n  'adk_request_confirmation';\n\n// Export these items for testing purposes only\nexport const functionsExportedForTestingOnly = {\n  handleFunctionCallList,\n  generateAuthEvent,\n  generateRequestConfirmationEvent,\n};\n\nexport function generateClientFunctionCallId(): string {\n  return `${AF_FUNCTION_CALL_ID_PREFIX}${randomUUID()}`;\n}\n\n/**\n * Populates client-side function call IDs.\n *\n * It iterates through all function calls in the event and assigns a\n * unique client-side ID to each one that doesn't already have an ID.\n */\n// TODO - b/425992518: consider move into event.ts\nexport function populateClientFunctionCallId(modelResponseEvent: Event): void {\n  const functionCalls = getFunctionCalls(modelResponseEvent);\n  if (!functionCalls) {\n    return;\n  }\n  for (const functionCall of functionCalls) {\n    if (!functionCall.id) {\n      functionCall.id = generateClientFunctionCallId();\n    }\n  }\n}\n// TODO - b/425992518: consider internalize in content_[processor].ts\n/**\n * Removes the client-generated function call IDs from a given content object.\n *\n * When sending content back to the server, these IDs are\n * specific to the client-side and should not be included in requests to the\n * model.\n */\nexport function removeClientFunctionCallId(content: Content): void {\n  if (content && content.parts) {\n    for (const part of content.parts) {\n      if (\n        part.functionCall &&\n        part.functionCall.id &&\n        part.functionCall.id.startsWith(AF_FUNCTION_CALL_ID_PREFIX)\n      ) {\n        part.functionCall.id = undefined;\n      }\n      if (\n        part.functionResponse &&\n        part.functionResponse.id &&\n        part.functionResponse.id.startsWith(AF_FUNCTION_CALL_ID_PREFIX)\n      ) {\n        part.functionResponse.id = undefined;\n      }\n    }\n  }\n}\n// TODO - b/425992518: consider internalize as part of llm_agent's runtime.\n/**\n * Returns a set of function call ids of the long running tools.\n */\nexport function getLongRunningFunctionCalls(\n  functionCalls: FunctionCall[],\n  toolsDict: Record<string, BaseTool>,\n): Set<string> {\n  const longRunningToolIds = new Set<string>();\n  for (const functionCall of functionCalls) {\n    if (\n      functionCall.name &&\n      functionCall.name in toolsDict &&\n      toolsDict[functionCall.name].isLongRunning &&\n      functionCall.id\n    ) {\n      longRunningToolIds.add(functionCall.id);\n    }\n  }\n  return longRunningToolIds;\n}\n\n// TODO - b/425992518: consider internalize as part of llm_agent's runtime.\n// The auth part of function calling is a bit hacky, need to to clarify.\n/**\n * Generates an authentication event.\n *\n * It iterates through requested auth configurations in a function response\n * event and creates a new function call for each.\n */\nexport function generateAuthEvent(\n  invocationContext: InvocationContext,\n  functionResponseEvent: Event,\n): Event | undefined {\n  if (\n    !functionResponseEvent.actions?.requestedAuthConfigs ||\n    isEmpty(functionResponseEvent.actions.requestedAuthConfigs)\n  ) {\n    return undefined;\n  }\n  const parts: Part[] = [];\n  const longRunningToolIds = new Set<string>();\n  for (const [functionCallId, authConfig] of Object.entries(\n    functionResponseEvent.actions.requestedAuthConfigs,\n  )) {\n    const requestEucFunctionCall: FunctionCall = {\n      name: REQUEST_EUC_FUNCTION_CALL_NAME,\n      args: {\n        'function_call_id': functionCallId,\n        'auth_config': authConfig,\n      },\n      id: generateClientFunctionCallId(),\n    };\n    longRunningToolIds.add(requestEucFunctionCall.id!);\n    parts.push({functionCall: requestEucFunctionCall});\n  }\n\n  return createEvent({\n    invocationId: invocationContext.invocationId,\n    author: invocationContext.agent.name,\n    branch: invocationContext.branch,\n    content: {\n      parts: parts,\n      role: functionResponseEvent.content!.role,\n    },\n    longRunningToolIds: Array.from(longRunningToolIds),\n  });\n}\n\n/**\n * Generates a request confirmation event from a function response event.\n */\nexport function generateRequestConfirmationEvent({\n  invocationContext,\n  functionCallEvent,\n  functionResponseEvent,\n}: {\n  invocationContext: InvocationContext;\n  functionCallEvent: Event;\n  functionResponseEvent: Event;\n}): Event | undefined {\n  if (\n    !functionResponseEvent.actions?.requestedToolConfirmations ||\n    isEmpty(functionResponseEvent.actions.requestedToolConfirmations)\n  ) {\n    return;\n  }\n  const parts: Part[] = [];\n  const longRunningToolIds = new Set<string>();\n  const functionCalls = getFunctionCalls(functionCallEvent);\n\n  for (const [functionCallId, toolConfirmation] of Object.entries(\n    functionResponseEvent.actions.requestedToolConfirmations,\n  )) {\n    const originalFunctionCall =\n      functionCalls.find((call) => call.id === functionCallId) ?? undefined;\n    if (!originalFunctionCall) {\n      continue;\n    }\n    const requestConfirmationFunctionCall: FunctionCall = {\n      name: REQUEST_CONFIRMATION_FUNCTION_CALL_NAME,\n      args: {\n        'originalFunctionCall': originalFunctionCall,\n        'toolConfirmation': toolConfirmation,\n      },\n      id: generateClientFunctionCallId(),\n    };\n    longRunningToolIds.add(requestConfirmationFunctionCall.id!);\n    parts.push({functionCall: requestConfirmationFunctionCall});\n  }\n  return createEvent({\n    invocationId: invocationContext.invocationId,\n    author: invocationContext.agent.name,\n    branch: invocationContext.branch,\n    content: {\n      parts: parts,\n      role: functionResponseEvent.content!.role,\n    },\n    longRunningToolIds: Array.from(longRunningToolIds),\n  });\n}\n\nasync function callToolAsync(\n  tool: BaseTool,\n  args: Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  toolContext: ToolContext,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Promise<any> {\n  return tracer.startActiveSpan(`execute_tool ${tool.name}`, async (span) => {\n    try {\n      logger.debug(`callToolAsync ${tool.name}`);\n      const result = await tool.runAsync({args, toolContext});\n      traceToolCall({\n        tool,\n        args,\n        functionResponseEvent: buildResponseEvent(\n          tool,\n          result,\n          toolContext,\n          toolContext.invocationContext,\n        ),\n      });\n      return result;\n    } finally {\n      span.end();\n    }\n  });\n}\n\nfunction buildResponseEvent(\n  tool: BaseTool,\n  functionResult: unknown,\n  toolContext: ToolContext,\n  invocationContext: InvocationContext,\n): Event {\n  let responseResult: Record<string, unknown>;\n  if (typeof functionResult !== 'object' || functionResult == null) {\n    responseResult = {result: functionResult};\n  } else {\n    responseResult = functionResult as Record<string, unknown>;\n  }\n\n  const partFunctionResponse: Part = {\n    functionResponse: {\n      name: tool.name,\n      response: responseResult,\n      id: toolContext.functionCallId,\n    },\n  };\n\n  const content: Content = {\n    role: 'user',\n    parts: [partFunctionResponse],\n  };\n\n  return createEvent({\n    invocationId: invocationContext.invocationId,\n    author: invocationContext.agent.name,\n    content: content,\n    actions: toolContext.actions,\n    branch: invocationContext.branch,\n  });\n}\n/**\n * Handles function calls.\n * Runtime behavior to pay attention to:\n * - Iterate through each function call in the `functionCallEvent`:\n *   - Execute before tool callbacks !!if a callback provides a response, short\n *     circuit the rest.\n *   - Execute the tool.\n *   - Execute after tool callbacks !!if a callback provides a response, short\n *     circuit the rest.\n *   - If the tool is long-running and the response is null, continue. !!state\n * - Merge all function response events into a single event.\n */\nexport async function handleFunctionCallsAsync({\n  invocationContext,\n  functionCallEvent,\n  toolsDict,\n  beforeToolCallbacks,\n  afterToolCallbacks,\n  filters,\n  toolConfirmationDict,\n}: {\n  invocationContext: InvocationContext;\n  functionCallEvent: Event;\n  toolsDict: Record<string, BaseTool>;\n  beforeToolCallbacks: SingleBeforeToolCallback[];\n  afterToolCallbacks: SingleAfterToolCallback[];\n  filters?: Set<string>;\n  toolConfirmationDict?: Record<string, ToolConfirmation>;\n}): Promise<Event | null> {\n  const functionCalls = getFunctionCalls(functionCallEvent);\n  return await handleFunctionCallList({\n    invocationContext: invocationContext,\n    functionCalls: functionCalls,\n    toolsDict: toolsDict,\n    beforeToolCallbacks: beforeToolCallbacks,\n    afterToolCallbacks: afterToolCallbacks,\n    filters: filters,\n    toolConfirmationDict: toolConfirmationDict,\n  });\n}\n\n/**\n * The underlying implementation of handleFunctionCalls, but takes a list of\n * function calls instead of an event.\n * This is also used by llm_agent execution flow in preprocessing.\n */\nexport async function handleFunctionCallList({\n  invocationContext,\n  functionCalls,\n  toolsDict,\n  beforeToolCallbacks,\n  afterToolCallbacks,\n  filters,\n  toolConfirmationDict,\n}: {\n  invocationContext: InvocationContext;\n  functionCalls: FunctionCall[];\n  toolsDict: Record<string, BaseTool>;\n  beforeToolCallbacks: SingleBeforeToolCallback[];\n  afterToolCallbacks: SingleAfterToolCallback[];\n  filters?: Set<string>;\n  toolConfirmationDict?: Record<string, ToolConfirmation>;\n}): Promise<Event | null> {\n  const functionResponseEvents: Event[] = [];\n\n  // Note: only function ids INCLUDED in the filters will be executed.\n  const filteredFunctionCalls = functionCalls.filter((functionCall) => {\n    return !filters || (functionCall.id && filters.has(functionCall.id));\n  });\n\n  for (const functionCall of filteredFunctionCalls) {\n    let toolConfirmation = undefined;\n    if (toolConfirmationDict && functionCall.id) {\n      toolConfirmation = toolConfirmationDict[functionCall.id];\n    }\n\n    const {tool, toolContext} = getToolAndContext({\n      invocationContext,\n      functionCall,\n      toolsDict,\n      toolConfirmation,\n    });\n\n    // TODO - b/436079721: implement [tracer.start_as_current_span]\n    logger.debug(`execute_tool ${tool.name}`);\n    const functionArgs = functionCall.args ?? {};\n\n    // Step 1: Check if plugin before_tool_callback overrides the function\n    // response.\n    let functionResponse = null;\n    let functionResponseError: string | unknown | undefined;\n    functionResponse =\n      await invocationContext.pluginManager.runBeforeToolCallback({\n        tool: tool,\n        toolArgs: functionArgs,\n        toolContext: toolContext,\n      });\n\n    // Step 2: If no overrides are provided from the plugins, further run the\n    // canonical callback.\n    // TODO - b/425992518: validate the callback response type matches.\n    if (functionResponse == null) {\n      // Cover both null and undefined\n      for (const callback of beforeToolCallbacks) {\n        functionResponse = await callback({\n          tool: tool,\n          args: functionArgs,\n          context: toolContext,\n        });\n        if (functionResponse) {\n          break;\n        }\n      }\n    }\n\n    // Step 3: Otherwise, proceed calling the tool normally.\n    if (functionResponse == null) {\n      // Cover both null and undefined\n      try {\n        functionResponse = await callToolAsync(tool, functionArgs, toolContext);\n      } catch (e: unknown) {\n        if (e instanceof Error) {\n          const onToolErrorResponse =\n            await invocationContext.pluginManager.runOnToolErrorCallback({\n              tool: tool,\n              toolArgs: functionArgs,\n              toolContext: toolContext,\n              error: e,\n            });\n\n          // Set function response to the result of the error callback and\n          // continue execution, do not shortcut\n          if (onToolErrorResponse) {\n            functionResponse = onToolErrorResponse;\n          } else {\n            // If the error callback returns undefined, use the error message\n            // as the function response error.\n            functionResponseError = e.message;\n          }\n        } else {\n          // If the error is not an Error, use the error object as the function\n          // response error.\n          functionResponseError = e;\n        }\n      }\n    }\n\n    // Step 4: Check if plugin after_tool_callback overrides the function\n    // response.\n    let alteredFunctionResponse =\n      await invocationContext.pluginManager.runAfterToolCallback({\n        tool: tool,\n        toolArgs: functionArgs,\n        toolContext: toolContext,\n        result: functionResponse,\n      });\n\n    // Step 5: If no overrides are provided from the plugins, further run the\n    // canonical after_tool_callbacks.\n    if (alteredFunctionResponse == null) {\n      // Cover both null and undefined\n      for (const callback of afterToolCallbacks) {\n        alteredFunctionResponse = await callback({\n          tool: tool,\n          args: functionArgs,\n          context: toolContext,\n          response: functionResponse,\n        });\n        if (alteredFunctionResponse) {\n          break;\n        }\n      }\n    }\n\n    // Step 6: If alternative response exists from after_tool_callback, use it\n    // instead of the original function response.\n    if (alteredFunctionResponse != null) {\n      functionResponse = alteredFunctionResponse;\n    }\n\n    // TODO - b/425992518: state event polluting runtime, consider fix.\n    // Allow long running function to return None as response.\n    if (tool.isLongRunning && !functionResponse) {\n      continue;\n    }\n\n    if (functionResponseError) {\n      functionResponse = {error: functionResponseError};\n    } else if (\n      typeof functionResponse !== 'object' ||\n      functionResponse == null\n    ) {\n      functionResponse = {result: functionResponse};\n    }\n\n    // Builds the function response event.\n    const functionResponseEvent = createEvent({\n      invocationId: invocationContext.invocationId,\n      author: invocationContext.agent.name,\n      content: createUserContent({\n        functionResponse: {\n          id: toolContext.functionCallId,\n          name: tool.name,\n          response: functionResponse,\n        },\n      }),\n      actions: toolContext.actions,\n      branch: invocationContext.branch,\n    });\n\n    // TODO - b/436079721: implement [traceToolCall]\n    logger.debug('traceToolCall', {\n      tool: tool.name,\n      args: functionArgs,\n      functionResponseEvent: functionResponseEvent.id,\n    });\n    functionResponseEvents.push(functionResponseEvent);\n  }\n\n  if (!functionResponseEvents.length) {\n    return null;\n  }\n  const mergedEvent = mergeParallelFunctionResponseEvents(\n    functionResponseEvents,\n  );\n\n  if (functionResponseEvents.length > 1) {\n    tracer.startActiveSpan('execute_tool (merged)', (span) => {\n      try {\n        logger.debug('execute_tool (merged)');\n        // TODO - b/436079721: implement [traceMergedToolCalls]\n        logger.debug('traceMergedToolCalls', {\n          responseEventId: mergedEvent.id,\n          functionResponseEvent: mergedEvent.id,\n        });\n        traceMergedToolCalls({\n          responseEventId: mergedEvent.id,\n          functionResponseEvent: mergedEvent,\n        });\n      } finally {\n        span.end();\n      }\n    });\n  }\n  return mergedEvent;\n}\n\n// TODO - b/425992518: consider inline, which is much cleaner.\nfunction getToolAndContext({\n  invocationContext,\n  functionCall,\n  toolsDict,\n  toolConfirmation,\n}: {\n  invocationContext: InvocationContext;\n  functionCall: FunctionCall;\n  toolsDict: Record<string, BaseTool>;\n  toolConfirmation?: ToolConfirmation;\n}): {tool: BaseTool; toolContext: ToolContext} {\n  if (!functionCall.name || !(functionCall.name in toolsDict)) {\n    throw new Error(\n      `Function ${functionCall.name} is not found in the toolsDict.`,\n    );\n  }\n\n  const toolContext = new ToolContext({\n    invocationContext: invocationContext,\n    functionCallId: functionCall.id || undefined,\n    toolConfirmation,\n  });\n\n  const tool = toolsDict[functionCall.name];\n\n  return {tool, toolContext};\n}\n\n/**\n * Merges a list of function response events into a single event.\n */\n// TODO - b/425992518: may not need export. Can be conslidated into Event.\nexport function mergeParallelFunctionResponseEvents(\n  functionResponseEvents: Event[],\n): Event {\n  if (!functionResponseEvents.length) {\n    throw new Error('No function response events provided.');\n  }\n\n  if (functionResponseEvents.length === 1) {\n    return functionResponseEvents[0];\n  }\n  const mergedParts: Part[] = [];\n  for (const event of functionResponseEvents) {\n    if (event.content && event.content.parts) {\n      mergedParts.push(...event.content.parts);\n    }\n  }\n\n  const baseEvent = functionResponseEvents[0];\n\n  const actionsList = functionResponseEvents.map(\n    (event) => event.actions || {},\n  );\n  const mergedActions = mergeEventActions(actionsList);\n\n  return createEvent({\n    author: baseEvent.author,\n    branch: baseEvent.branch,\n    content: {role: 'user', parts: mergedParts},\n    actions: mergedActions,\n    timestamp: baseEvent.timestamp!,\n  });\n}\n\n// TODO - b/425992518: support function call in live connection.\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {State} from '../sessions/state.js';\n\nimport {AuthCredential} from './auth_credential.js';\nimport {AuthConfig} from './auth_tool.js';\n\n// TODO(b/425992518): Implement the rest\n/**\n * A handler that handles the auth flow in Agent Development Kit to help\n * orchestrates the credential request and response flow (e.g. OAuth flow)\n * This class should only be used by Agent Development Kit.\n */\nexport class AuthHandler {\n  constructor(private readonly authConfig: AuthConfig) {}\n\n  getAuthResponse(state: State): AuthCredential | undefined {\n    const credentialKey = 'temp:' + this.authConfig.credentialKey;\n\n    return state.get<AuthCredential>(credentialKey);\n  }\n\n  generateAuthRequest(): AuthConfig {\n    const authSchemeType = this.authConfig.authScheme.type;\n\n    if (!['oauth2', 'openIdConnect'].includes(authSchemeType)) {\n      return this.authConfig;\n    }\n\n    if (this.authConfig.exchangedAuthCredential?.oauth2?.authUri) {\n      return this.authConfig;\n    }\n\n    if (!this.authConfig.rawAuthCredential) {\n      throw new Error(`Auth Scheme ${authSchemeType} requires authCredential.`);\n    }\n\n    if (!this.authConfig.rawAuthCredential.oauth2) {\n      throw new Error(\n        `Auth Scheme ${authSchemeType} requires oauth2 in authCredential.`,\n      );\n    }\n\n    if (this.authConfig.rawAuthCredential.oauth2.authUri) {\n      return {\n        credentialKey: this.authConfig.credentialKey,\n        authScheme: this.authConfig.authScheme,\n        rawAuthCredential: this.authConfig.rawAuthCredential,\n        exchangedAuthCredential: this.authConfig.rawAuthCredential,\n      };\n    }\n\n    if (\n      !this.authConfig.rawAuthCredential.oauth2.clientId ||\n      !this.authConfig.rawAuthCredential.oauth2.clientSecret\n    ) {\n      throw new Error(\n        `Auth Scheme ${authSchemeType} requires both clientId and clientSecret in authCredential.oauth2.`,\n      );\n    }\n\n    return {\n      credentialKey: this.authConfig.credentialKey,\n      authScheme: this.authConfig.authScheme,\n      rawAuthCredential: this.authConfig.rawAuthCredential,\n      exchangedAuthCredential: this.generateAuthUri(),\n    };\n  }\n\n  /**\n   * Generates an response containing the auth uri for user to sign in.\n   *\n   * @return An AuthCredential object containing the auth URI and state.\n   * @throws Error: If the authorization endpoint is not configured in the\n   *     auth scheme.\n   */\n  generateAuthUri(): AuthCredential | undefined {\n    return this.authConfig.rawAuthCredential;\n    // TODO - b/425992518: Implement the rest of the function\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents a tool confirmation configuration.\n * @experimental  (Experimental, subject to change)\n */\nexport class ToolConfirmation {\n  /** The hint text for why the input is needed. */\n  hint: string;\n\n  /** Whether the tool execution is confirmed. */\n  confirmed: boolean;\n\n  /**\n   * The custom data payload needed from the user to continue the flow.\n   * It should be JSON serializable.\n   */\n  payload?: unknown;\n\n  constructor({\n    hint,\n    confirmed,\n    payload,\n  }: {\n    hint?: string;\n    confirmed: boolean;\n    payload?: unknown;\n  }) {\n    this.hint = hint ?? '';\n    this.confirmed = confirmed;\n    this.payload = payload;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {CallbackContext} from '../agents/callback_context.js';\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {AuthCredential} from '../auth/auth_credential.js';\nimport {AuthHandler} from '../auth/auth_handler.js';\nimport {AuthConfig} from '../auth/auth_tool.js';\nimport {EventActions} from '../events/event_actions.js';\nimport {SearchMemoryResponse} from '../memory/base_memory_service.js';\nimport {ToolConfirmation} from '../tools/tool_confirmation.js';\n\n/*\n * The context of the tool.\n *\n * This class provides the context for a tool invocation, including access to\n *  the invocation context, function call ID, event actions, and authentication\n *  response. It also provides methods for requesting credentials, retrieving\n *  authentication responses, listing artifacts, and searching memory.\n */\nexport class ToolContext extends CallbackContext {\n  readonly functionCallId?: string;\n  toolConfirmation?: ToolConfirmation;\n\n  /**\n   * @param params.invocationContext The invocation context of the tool.\n   * @param params.eventActions The event actions of the current tool call.\n   * @param params.functionCallId The function call id of the current tool call.\n   *     This id was returned in the function call event from LLM to identify a\n   *     function call. If LLM didn't return this id, ADK will assign one to it.\n   *     This id is used to map function call response to the original function\n   *     call.\n   * @param params.toolConfirmation The tool confirmation of the current tool\n   *     call.\n   */\n  constructor(params: {\n    invocationContext: InvocationContext;\n    eventActions?: EventActions;\n    functionCallId?: string;\n    toolConfirmation?: ToolConfirmation;\n  }) {\n    super(params);\n    this.functionCallId = params.functionCallId;\n    this.toolConfirmation = params.toolConfirmation;\n  }\n\n  get actions(): EventActions {\n    return this.eventActions;\n  }\n\n  requestCredential(authConfig: AuthConfig) {\n    if (!this.functionCallId) {\n      throw new Error('functionCallId is not set.');\n    }\n\n    const authHandler = new AuthHandler(authConfig);\n    this.eventActions.requestedAuthConfigs[this.functionCallId] =\n      authHandler.generateAuthRequest();\n  }\n\n  /**\n   * Gets the auth credential for the given auth config.\n   *\n   * @param authConfig The auth config to get the auth credential for.\n   * @return The auth credential for the given auth config.\n   */\n  getAuthResponse(authConfig: AuthConfig): AuthCredential | undefined {\n    const authHandler = new AuthHandler(authConfig);\n\n    return authHandler.getAuthResponse(this.state);\n  }\n\n  /**\n   * Lists the filenames of the artifacts attached to the current session.\n   *\n   * @return A promise that resolves to a list of artifact filenames.\n   */\n  listArtifacts(): Promise<string[]> {\n    if (!this.invocationContext.artifactService) {\n      throw new Error('Artifact service is not initialized.');\n    }\n\n    return this.invocationContext.artifactService.listArtifactKeys({\n      appName: this.invocationContext.session.appName,\n      userId: this.invocationContext.session.userId,\n      sessionId: this.invocationContext.session.id,\n    });\n  }\n\n  /**\n   * Searches the memory of the current user.\n   *\n   * @param query The query to search memory for.\n   * @return A promise that resolves to SearchMemoryResponse containing the\n   *     matching memories.\n   */\n  searchMemory(query: string): Promise<SearchMemoryResponse> {\n    if (!this.invocationContext.memoryService) {\n      throw new Error('Memory service is not initialized.');\n    }\n\n    return this.invocationContext.memoryService.searchMemory({\n      appName: this.invocationContext.session.appName,\n      userId: this.invocationContext.session.userId,\n      query,\n    });\n  }\n\n  /**\n   * Requests confirmation for the current tool call.\n   */\n  requestConfirmation({hint, payload}: {hint?: string; payload?: unknown}) {\n    if (!this.functionCallId) {\n      throw new Error('functionCallId is not set.');\n    }\n    this.eventActions.requestedToolConfirmations[this.functionCallId] =\n      new ToolConfirmation({\n        hint: hint,\n        confirmed: false,\n        payload: payload,\n      });\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/** Log levels for the logger. */\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3,\n}\n\n/**\n * Logger interface for ADK.\n */\nexport interface Logger {\n  log(level: LogLevel, ...args: unknown[]): void;\n\n  debug(...args: unknown[]): void;\n\n  info(...args: unknown[]): void;\n\n  warn(...args: unknown[]): void;\n\n  error(...args: unknown[]): void;\n}\n\nlet logLevel = LogLevel.INFO;\n\n/**\n * Sets the log level for the logger.\n */\nexport function setLogLevel(level: LogLevel) {\n  logLevel = level;\n}\n\n/**\n * Simple logger class for ADK.\n */\nclass SimpleLogger implements Logger {\n  log(level: LogLevel, ...args: unknown[]) {\n    if (level < logLevel) {\n      return;\n    }\n\n    switch (level) {\n      case LogLevel.DEBUG:\n        this.debug(...args);\n        break;\n      case LogLevel.INFO:\n        this.info(...args);\n        break;\n      case LogLevel.WARN:\n        this.warn(...args);\n        break;\n      case LogLevel.ERROR:\n        this.error(...args);\n        break;\n      default:\n        throw new Error(`Unsupported log level: ${level}`);\n    }\n  }\n\n  debug(...args: unknown[]) {\n    if (logLevel > LogLevel.DEBUG) {\n      return;\n    }\n\n    console.debug(getColoredPrefix(LogLevel.DEBUG), ...args);\n  }\n\n  info(...args: unknown[]) {\n    if (logLevel > LogLevel.INFO) {\n      return;\n    }\n\n    console.info(getColoredPrefix(LogLevel.INFO), ...args);\n  }\n\n  warn(...args: unknown[]) {\n    if (logLevel > LogLevel.WARN) {\n      return;\n    }\n\n    console.warn(getColoredPrefix(LogLevel.WARN), ...args);\n  }\n\n  error(...args: unknown[]) {\n    if (logLevel > LogLevel.ERROR) {\n      return;\n    }\n\n    console.error(getColoredPrefix(LogLevel.ERROR), ...args);\n  }\n}\n\n/**\n * A no-op logger that discards all log messages.\n */\nclass NoOpLogger implements Logger {\n  log(_level: LogLevel, ..._args: unknown[]): void {}\n  debug(..._args: unknown[]): void {}\n  info(..._args: unknown[]): void {}\n  warn(..._args: unknown[]): void {}\n  error(..._args: unknown[]): void {}\n}\n\nconst LOG_LEVEL_STR: Record<LogLevel, string> = {\n  [LogLevel.DEBUG]: 'DEBUG',\n  [LogLevel.INFO]: 'INFO',\n  [LogLevel.WARN]: 'WARN',\n  [LogLevel.ERROR]: 'ERROR',\n};\n\nconst CONSOLE_COLOR_MAP: Record<LogLevel, string> = {\n  [LogLevel.DEBUG]: '\\x1b[34m', // Blue\n  [LogLevel.INFO]: '\\x1b[32m', // Green\n  [LogLevel.WARN]: '\\x1b[33m', // Yellow\n  [LogLevel.ERROR]: '\\x1b[31m', // Red\n};\n\nconst RESET_COLOR = '\\x1b[0m';\n\nfunction getColoredPrefix(level: LogLevel): string {\n  return `${CONSOLE_COLOR_MAP[level]}[ADK ${LOG_LEVEL_STR[level]}]:${RESET_COLOR}`;\n}\n\nlet currentLogger: Logger = new SimpleLogger();\n\n/**\n * Sets a custom logger for ADK, or null to disable logging.\n */\nexport function setLogger(customLogger: Logger | null): void {\n  currentLogger = customLogger ?? new NoOpLogger();\n}\n\n/**\n * Gets the current logger instance.\n */\nexport function getLogger(): Logger {\n  return currentLogger;\n}\n\n/**\n * Resets the logger to the default SimpleLogger.\n */\nexport function resetLogger(): void {\n  currentLogger = new SimpleLogger();\n}\n\n/**\n * The logger instance for ADK.\n */\nexport const logger: Logger = {\n  log(level: LogLevel, ...args: unknown[]): void {\n    currentLogger.log(level, ...args);\n  },\n  debug(...args: unknown[]): void {\n    currentLogger.debug(...args);\n  },\n  info(...args: unknown[]): void {\n    currentLogger.info(...args);\n  },\n  warn(...args: unknown[]): void {\n    currentLogger.warn(...args);\n  },\n  error(...args: unknown[]): void {\n    currentLogger.error(...args);\n  },\n};\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ActivityEnd, ActivityStart, Blob, Content} from '@google/genai';\n\n/**\n * Request sent to live agents.\n */\nexport interface LiveRequest {\n  /** If set, send the content to the model in turn-by-turn mode. */\n  content?: Content;\n  /** If set, send the blob to the model in realtime mode. */\n  blob?: Blob;\n  /** If set, signal the start of user activity to the model. */\n  activityStart?: ActivityStart;\n  /** If set, signal the end of user activity to the model. */\n  activityEnd?: ActivityEnd;\n  /** If set, close the queue. */\n  close?: boolean;\n}\n\n/** Function type for resolving a Promise with a LiveRequest. */\ntype PromiseResolveFn = (req: LiveRequest) => void;\n\n/**\n * Queue used to send LiveRequest in a live (bidirectional streaming) way.\n */\nexport class LiveRequestQueue {\n  // Keeps track of the data that are waiting to be sent.\n  private readonly queue: LiveRequest[] = [];\n  // Keeps track of the promises that are waiting for data.\n  private readonly resolveFnFifoQueue: PromiseResolveFn[] = [];\n  private isClosed = false;\n\n  /**\n   * Adds a request to the queue. If there is a pending `get()` call, it\n   * will be resolved with the given request.\n   * @param req The request to send.\n   */\n  send(req: LiveRequest) {\n    if (this.isClosed) {\n      throw new Error('Cannot send to a closed queue.');\n    }\n    if (this.resolveFnFifoQueue.length > 0) {\n      const resolve = this.resolveFnFifoQueue.shift()!;\n      resolve(req);\n    } else {\n      this.queue.push(req);\n    }\n  }\n\n  /**\n   * Retrieves a request from the queue. If the queue is empty, it will\n   * wait until a request is available.\n   * @returns A promise that resolves with the next available request.\n   */\n  async get(): Promise<LiveRequest> {\n    if (this.queue.length > 0) {\n      return this.queue.shift()!;\n    }\n    if (this.isClosed) {\n      return {close: true};\n    }\n    return new Promise<LiveRequest>((resolve) => {\n      this.resolveFnFifoQueue.push(resolve);\n    });\n  }\n\n  /**\n   * Sends a close signal to the queue.\n   */\n  close() {\n    if (this.isClosed) {\n      return;\n    }\n    this.isClosed = true;\n\n    // Satisfy pending gets with existing queue items\n    while (this.resolveFnFifoQueue.length > 0 && this.queue.length > 0) {\n      const resolve = this.resolveFnFifoQueue.shift()!;\n      const req = this.queue.shift()!;\n      resolve(req);\n    }\n\n    // Resolve remaining pending gets with close signal\n    const closeRequest: LiveRequest = {close: true};\n    while (this.resolveFnFifoQueue.length > 0) {\n      const resolve = this.resolveFnFifoQueue.shift()!;\n      resolve(closeRequest);\n    }\n\n    // Remaining items in this.queue will be drained by subsequent get() calls.\n  }\n\n  /**\n   * Sends a content object to the queue.\n   * @param content The content to send.\n   */\n  sendContent(content: Content) {\n    this.send({content});\n  }\n\n  /**\n   * Sends a blob to the model in realtime mode.\n   * @param blob The blob to send.\n   */\n  sendRealtime(blob: Blob) {\n    this.send({blob});\n  }\n\n  /**\n   * Sends an activity start signal to mark the beginning of user input.\n   */\n  sendActivityStart() {\n    this.send({activityStart: {}});\n  }\n\n  /**\n   * Sends an activity end signal to mark the end of user input.\n   */\n  sendActivityEnd() {\n    this.send({activityEnd: {}});\n  }\n\n  /**\n   * Implements the async iterator protocol.\n   */\n  async *[Symbol.asyncIterator](): AsyncGenerator<\n    LiveRequest,\n    void,\n    undefined\n  > {\n    while (true) {\n      const request = await this.get();\n      yield request;\n      if (request.close) {\n        break;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Content,\n  FunctionCall,\n  GenerateContentConfig,\n  Part,\n  Schema,\n} from '@google/genai';\nimport {context, trace} from '@opentelemetry/api';\nimport {cloneDeep} from 'lodash-es';\nimport {z} from 'zod';\n\nimport {\n  BaseCodeExecutor,\n  isBaseCodeExecutor,\n} from '../code_executors/base_code_executor.js';\nimport {isBuiltInCodeExecutor} from '../code_executors/built_in_code_executor.js';\nimport {\n  buildCodeExecutionResultPart,\n  buildExecutableCodePart,\n  CodeExecutionResult,\n  convertCodeExecutionParts,\n  extractCodeAndTruncateContent,\n  File,\n} from '../code_executors/code_execution_utils.js';\nimport {CodeExecutorContext} from '../code_executors/code_executor_context.js';\nimport {\n  createEvent,\n  createNewEventId,\n  Event,\n  getFunctionCalls,\n  getFunctionResponses,\n  isFinalResponse,\n} from '../events/event.js';\nimport {createEventActions} from '../events/event_actions.js';\nimport {BaseExampleProvider} from '../examples/base_example_provider.js';\nimport {Example} from '../examples/example.js';\nimport {BaseLlm, isBaseLlm} from '../models/base_llm.js';\nimport {\n  appendInstructions,\n  LlmRequest,\n  setOutputSchema,\n} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\nimport {LLMRegistry} from '../models/registry.js';\nimport {State} from '../sessions/state.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {BaseToolset} from '../tools/base_toolset.js';\nimport {FunctionTool} from '../tools/function_tool.js';\nimport {ToolConfirmation} from '../tools/tool_confirmation.js';\nimport {ToolContext} from '../tools/tool_context.js';\nimport {base64Decode} from '../utils/env_aware_utils.js';\nimport {logger} from '../utils/logger.js';\n\nimport {\n  runAsyncGeneratorWithOtelContext,\n  traceCallLlm,\n  tracer,\n} from '../telemetry/tracing.js';\nimport {BaseAgent, BaseAgentConfig} from './base_agent.js';\nimport {\n  BaseLlmRequestProcessor,\n  BaseLlmResponseProcessor,\n} from './base_llm_processor.js';\nimport {CallbackContext} from './callback_context.js';\nimport {\n  getContents,\n  getCurrentTurnContents,\n} from './content_processor_utils.js';\nimport {\n  generateAuthEvent,\n  generateRequestConfirmationEvent,\n  getLongRunningFunctionCalls,\n  handleFunctionCallList,\n  handleFunctionCallsAsync,\n  populateClientFunctionCallId,\n  REQUEST_CONFIRMATION_FUNCTION_CALL_NAME,\n} from './functions.js';\nimport {injectSessionState} from './instructions.js';\nimport {InvocationContext} from './invocation_context.js';\nimport {ReadonlyContext} from './readonly_context.js';\nimport {StreamingMode} from './run_config.js';\n\n/** An object that can provide an instruction string. */\nexport type InstructionProvider = (\n  context: ReadonlyContext,\n) => string | Promise<string>;\n\n/**\n * A callback that runs before a request is sent to the model.\n *\n * @param params.context The current callback context.\n * @param params.request The raw model request. Callback can mutate the request.\n * @returns The content to return to the user. When present, the model call\n *     will be skipped and the provided content will be returned to user.\n */\nexport type SingleBeforeModelCallback = (params: {\n  context: CallbackContext;\n  request: LlmRequest;\n}) => LlmResponse | undefined | Promise<LlmResponse | undefined>;\n\n/**\n * A single callback or a list of callbacks.\n *\n * When a list of callbacks is provided, the callbacks will be called in the\n * order they are listed until a callback does not return None.\n */\nexport type BeforeModelCallback =\n  | SingleBeforeModelCallback\n  | SingleBeforeModelCallback[];\n\n/**\n * A callback that runs after a response is received from the model.\n *\n * @param params.context The current callback context.\n * @param params.response The actual model response.\n * @returns The content to return to the user. When present, the actual model\n *     response will be ignored and the provided content will be returned to\n *     user.\n */\nexport type SingleAfterModelCallback = (params: {\n  context: CallbackContext;\n  response: LlmResponse;\n}) => LlmResponse | undefined | Promise<LlmResponse | undefined>;\n\n/**\n * A single callback or a list of callbacks.\n *\n * When a list of callbacks is provided, the callbacks will be called in the\n order they are listed until a callback does not return None.\n */\nexport type AfterModelCallback =\n  | SingleAfterModelCallback\n  | SingleAfterModelCallback[];\n\n/**\n * A callback that runs before a tool is called.\n *\n * @param params.tool The tool to be called.\n * @param params.args The arguments to the tool.\n * @param params.context ToolContext for the tool call.\n * @returns The tool response. When present, the returned tool response will\n *     be used and the framework will skip calling the actual tool.\n */\nexport type SingleBeforeToolCallback = (params: {\n  tool: BaseTool;\n  args: Record<string, unknown>;\n  context: ToolContext;\n}) =>\n  | Record<string, unknown>\n  | undefined\n  | Promise<Record<string, unknown> | undefined>;\n\n/**\n * A single callback or a list of callbacks.\n *\n * When a list of callbacks is provided, the callbacks will be called in the\n * order they are listed until a callback does not return None.\n */\nexport type BeforeToolCallback =\n  | SingleBeforeToolCallback\n  | SingleBeforeToolCallback[];\n\n/**\n * A callback that runs after a tool is called.\n *\n * @param params.tool The tool to be called.\n * @param params.args The arguments to the tool.\n * @param params.context ToolContext for the tool call.\n * @param params.response The response from the tool.\n * @returns When present, the returned record will be used as tool result.\n */\nexport type SingleAfterToolCallback = (params: {\n  tool: BaseTool;\n  args: Record<string, unknown>;\n  context: ToolContext;\n  response: Record<string, unknown>;\n}) =>\n  | Record<string, unknown>\n  | undefined\n  | Promise<Record<string, unknown> | undefined>;\n\n/**\n * A single callback or a list of callbacks.\n *\n * When a list of callbacks is provided, the callbacks will be called in the\n * order they are listed until acallback does not return None.\n */\nexport type AfterToolCallback =\n  | SingleAfterToolCallback\n  | SingleAfterToolCallback[];\n\n/** A list of examples or an example provider. */\nexport type ExamplesUnion = Example[] | BaseExampleProvider;\n\n/** A union of tool types that can be provided to an agent. */\nexport type ToolUnion = BaseTool | BaseToolset;\n\nconst ADK_AGENT_NAME_LABEL_KEY = 'adk_agent_name';\n\n/**\n * The configuration options for creating an LLM-based agent.\n */\nexport interface LlmAgentConfig extends BaseAgentConfig {\n  /**\n   * The model to use for the agent.\n   */\n  model?: string | BaseLlm;\n\n  /** Instructions for the LLM model, guiding the agent's behavior. */\n  instruction?: string | InstructionProvider;\n\n  /**\n   * Instructions for all the agents in the entire agent tree.\n   *\n   * ONLY the globalInstruction in root agent will take effect.\n   *\n   * For example: use globalInstruction to make all agents have a stable\n   * identity or personality.\n   */\n  globalInstruction?: string | InstructionProvider;\n\n  /** Tools available to this agent. */\n  tools?: ToolUnion[];\n\n  /**\n   * The additional content generation configurations.\n   *\n   * NOTE: not all fields are usable, e.g. tools must be configured via\n   * `tools`, thinking_config must be configured via `planner` in LlmAgent.\n   *\n   * For example: use this config to adjust model temperature, configure safety\n   * settings, etc.\n   */\n  generateContentConfig?: GenerateContentConfig;\n\n  /**\n   * Disallows LLM-controlled transferring to the parent agent.\n   *\n   * NOTE: Setting this as True also prevents this agent to continue reply to\n   * the end-user. This behavior prevents one-way transfer, in which end-user\n   * may be stuck with one agent that cannot transfer to other agents in the\n   * agent tree.\n   */\n  disallowTransferToParent?: boolean;\n\n  /** Disallows LLM-controlled transferring to the peer agents. */\n  disallowTransferToPeers?: boolean;\n\n  // TODO - b/425992518: consider more complex contex engineering mechanims.\n  /**\n   * Controls content inclusion in model requests.\n   *\n   * Options:\n   *   default: Model receives relevant conversation history\n   *   none: Model receives no prior history, operates solely on current\n   *   instruction and input\n   */\n  includeContents?: 'default' | 'none';\n\n  /** The input schema when agent is used as a tool. */\n  inputSchema?: Schema;\n\n  /**\n   * The output schema when agent replies.\n   *\n   * NOTE:\n   *   When this is set, agent can ONLY reply and CANNOT use any tools, such as\n   *   function tools, RAGs, agent transfer, etc.\n   */\n  outputSchema?: Schema;\n\n  /**\n   * The key in session state to store the output of the agent.\n   *\n   * Typically use cases:\n   * - Extracts agent reply for later use, such as in tools, callbacks, etc.\n   * - Connects agents to coordinate with each other.\n   */\n  outputKey?: string;\n\n  /**\n   * Callbacks to be called before calling the LLM.\n   */\n  beforeModelCallback?: BeforeModelCallback;\n\n  /**\n   * Callbacks to be called after calling the LLM.\n   */\n  afterModelCallback?: AfterModelCallback;\n\n  /**\n   * Callbacks to be called before calling the tool.\n   */\n  beforeToolCallback?: BeforeToolCallback;\n\n  /**\n   * Callbacks to be called after calling the tool.\n   */\n  afterToolCallback?: AfterToolCallback;\n\n  /**\n   * Processors to run before the LLM request is sent.\n   */\n  requestProcessors?: BaseLlmRequestProcessor[];\n\n  /**\n   * Processors to run after the LLM response is received.\n   */\n  responseProcessors?: BaseLlmResponseProcessor[];\n\n  /**\n   * Instructs the agent to make a plan and execute it step by step.\n   */\n  codeExecutor?: BaseCodeExecutor;\n}\n\nasync function convertToolUnionToTools(\n  toolUnion: ToolUnion,\n  context?: ReadonlyContext,\n): Promise<BaseTool[]> {\n  if (toolUnion instanceof BaseTool) {\n    return [toolUnion];\n  }\n  return await toolUnion.getTools(context);\n}\n\n// --------------------------------------------------------------------------\n// #START Request Processors\n// --------------------------------------------------------------------------\nclass BasicLlmRequestProcessor extends BaseLlmRequestProcessor {\n  // eslint-disable-next-line require-yield\n  override async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void> {\n    const agent = invocationContext.agent;\n    if (!isLlmAgent(agent)) {\n      return;\n    }\n\n    // set model string, not model instance.\n    llmRequest.model = agent.canonicalModel.model;\n\n    llmRequest.config = {...(agent.generateContentConfig ?? {})};\n    if (agent.outputSchema) {\n      setOutputSchema(llmRequest, agent.outputSchema);\n    }\n\n    if (invocationContext.runConfig) {\n      llmRequest.liveConnectConfig.responseModalities =\n        invocationContext.runConfig.responseModalities;\n      llmRequest.liveConnectConfig.speechConfig =\n        invocationContext.runConfig.speechConfig;\n      llmRequest.liveConnectConfig.outputAudioTranscription =\n        invocationContext.runConfig.outputAudioTranscription;\n      llmRequest.liveConnectConfig.inputAudioTranscription =\n        invocationContext.runConfig.inputAudioTranscription;\n      llmRequest.liveConnectConfig.realtimeInputConfig =\n        invocationContext.runConfig.realtimeInputConfig;\n      llmRequest.liveConnectConfig.enableAffectiveDialog =\n        invocationContext.runConfig.enableAffectiveDialog;\n      llmRequest.liveConnectConfig.proactivity =\n        invocationContext.runConfig.proactivity;\n    }\n  }\n}\nconst BASIC_LLM_REQUEST_PROCESSOR = new BasicLlmRequestProcessor();\n\nclass IdentityLlmRequestProcessor extends BaseLlmRequestProcessor {\n  // eslint-disable-next-line require-yield\n  override async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, undefined> {\n    const agent = invocationContext.agent;\n    const si = [`You are an agent. Your internal name is \"${agent.name}\".`];\n    if (agent.description) {\n      si.push(`The description about you is \"${agent.description}\"`);\n    }\n    appendInstructions(llmRequest, si);\n  }\n}\nconst IDENTITY_LLM_REQUEST_PROCESSOR = new IdentityLlmRequestProcessor();\n\nclass InstructionsLlmRequestProcessor extends BaseLlmRequestProcessor {\n  /**\n   * Handles instructions and global instructions for LLM flow.\n   */\n  // eslint-disable-next-line require-yield\n  async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void> {\n    const agent = invocationContext.agent;\n    if (\n      !(agent instanceof LlmAgent) ||\n      !(agent.rootAgent instanceof LlmAgent)\n    ) {\n      return;\n    }\n    const rootAgent: LlmAgent = agent.rootAgent;\n\n    // TODO - b/425992518: unexpected and buggy for performance.\n    // Global instruction should be explicitly scoped.\n    // Step 1: Appends global instructions if set by RootAgent.\n    if (isLlmAgent(rootAgent) && rootAgent.globalInstruction) {\n      const {instruction, requireStateInjection} =\n        await rootAgent.canonicalGlobalInstruction(\n          new ReadonlyContext(invocationContext),\n        );\n      let instructionWithState = instruction;\n      if (requireStateInjection) {\n        instructionWithState = await injectSessionState(\n          instruction,\n          new ReadonlyContext(invocationContext),\n        );\n      }\n      appendInstructions(llmRequest, [instructionWithState]);\n    }\n\n    // Step 2: Appends agent local instructions if set.\n    // TODO - b/425992518: requireStateInjection means user passed a\n    // instruction processor. We need to make it more explicit.\n    if (agent.instruction) {\n      const {instruction, requireStateInjection} =\n        await agent.canonicalInstruction(\n          new ReadonlyContext(invocationContext),\n        );\n      let instructionWithState = instruction;\n      if (requireStateInjection) {\n        instructionWithState = await injectSessionState(\n          instruction,\n          new ReadonlyContext(invocationContext),\n        );\n      }\n      appendInstructions(llmRequest, [instructionWithState]);\n    }\n  }\n}\nconst INSTRUCTIONS_LLM_REQUEST_PROCESSOR =\n  new InstructionsLlmRequestProcessor();\n\nclass ContentRequestProcessor implements BaseLlmRequestProcessor {\n  // eslint-disable-next-line require-yield\n  async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void> {\n    const agent = invocationContext.agent;\n    if (!agent || !isLlmAgent(agent)) {\n      return;\n    }\n\n    if (agent.includeContents === 'default') {\n      // Include full conversation history\n      llmRequest.contents = getContents(\n        invocationContext.session.events,\n        agent.name,\n        invocationContext.branch,\n      );\n    } else {\n      // Include current turn context only (no conversation history).\n      llmRequest.contents = getCurrentTurnContents(\n        invocationContext.session.events,\n        agent.name,\n        invocationContext.branch,\n      );\n    }\n\n    return;\n  }\n}\nconst CONTENT_REQUEST_PROCESSOR = new ContentRequestProcessor();\n\nclass AgentTransferLlmRequestProcessor extends BaseLlmRequestProcessor {\n  private readonly toolName = 'transfer_to_agent' as const;\n  private readonly tool = new FunctionTool({\n    name: this.toolName,\n    description:\n      'Transfer the question to another agent. This tool hands off control to another agent when it is more suitable to answer the user question according to the agent description.',\n    parameters: z.object({\n      agentName: z.string().describe('the agent name to transfer to.'),\n    }),\n    execute: function (args: {agentName: string}, toolContext?: ToolContext) {\n      if (!toolContext) {\n        throw new Error('toolContext is required.');\n      }\n      toolContext.actions.transferToAgent = args.agentName;\n      return 'Transfer queued';\n    },\n  });\n\n  // eslint-disable-next-line require-yield\n  override async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void> {\n    if (!(invocationContext.agent instanceof LlmAgent)) {\n      return;\n    }\n\n    const transferTargets = this.getTransferTargets(invocationContext.agent);\n    if (!transferTargets.length) {\n      return;\n    }\n\n    appendInstructions(llmRequest, [\n      this.buildTargetAgentsInstructions(\n        invocationContext.agent,\n        transferTargets,\n      ),\n    ]);\n\n    const toolContext = new ToolContext({invocationContext});\n    await this.tool.processLlmRequest({toolContext, llmRequest});\n  }\n\n  private buildTargetAgentsInfo(targetAgent: BaseAgent): string {\n    return `\nAgent name: ${targetAgent.name}\nAgent description: ${targetAgent.description}\n`;\n  }\n\n  private buildTargetAgentsInstructions(\n    agent: LlmAgent,\n    targetAgents: BaseAgent[],\n  ): string {\n    let instructions = `\nYou have a list of other agents to transfer to:\n\n${targetAgents.map(this.buildTargetAgentsInfo).join('\\n')}\n\nIf you are the best to answer the question according to your description, you\ncan answer it.\n\nIf another agent is better for answering the question according to its\ndescription, call \\`${this.toolName}\\` function to transfer the\nquestion to that agent. When transferring, do not generate any text other than\nthe function call.\n`;\n\n    if (agent.parentAgent && !agent.disallowTransferToParent) {\n      instructions += `\nYour parent agent is ${agent.parentAgent.name}. If neither the other agents nor\nyou are best for answering the question according to the descriptions, transfer\nto your parent agent.\n`;\n    }\n    return instructions;\n  }\n\n  private getTransferTargets(agent: LlmAgent): BaseAgent[] {\n    const targets: BaseAgent[] = [];\n    targets.push(...agent.subAgents);\n\n    if (!agent.parentAgent || !isLlmAgent(agent.parentAgent)) {\n      return targets;\n    }\n\n    if (!agent.disallowTransferToParent) {\n      targets.push(agent.parentAgent);\n    }\n\n    if (!agent.disallowTransferToPeers) {\n      targets.push(\n        ...agent.parentAgent.subAgents.filter(\n          (peerAgent) => peerAgent.name !== agent.name,\n        ),\n      );\n    }\n\n    return targets;\n  }\n}\nconst AGENT_TRANSFER_LLM_REQUEST_PROCESSOR =\n  new AgentTransferLlmRequestProcessor();\n\nclass RequestConfirmationLlmRequestProcessor extends BaseLlmRequestProcessor {\n  /** Handles tool confirmation information to build the LLM request. */\n  override async *runAsync(\n    invocationContext: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    const agent = invocationContext.agent;\n    if (!isLlmAgent(agent)) {\n      return;\n    }\n    const events = invocationContext.session.events;\n    if (!events || events.length === 0) {\n      return;\n    }\n\n    const requestConfirmationFunctionResponses: {\n      [key: string]: ToolConfirmation;\n    } = {};\n\n    let confirmationEventIndex = -1;\n    // Step 1: Find the FIRST confirmation event authored by user.\n    for (let i = events.length - 1; i >= 0; i--) {\n      const event = events[i];\n      if (event.author !== 'user') {\n        continue;\n      }\n      const responses = getFunctionResponses(event);\n      if (!responses) {\n        continue;\n      }\n\n      let foundConfirmation = false;\n      for (const functionResponse of responses) {\n        if (functionResponse.name !== REQUEST_CONFIRMATION_FUNCTION_CALL_NAME) {\n          continue;\n        }\n        foundConfirmation = true;\n\n        let toolConfirmation = null;\n\n        if (\n          functionResponse.response &&\n          Object.keys(functionResponse.response).length === 1 &&\n          'response' in functionResponse.response\n        ) {\n          toolConfirmation = JSON.parse(\n            functionResponse.response['response'] as string,\n          ) as ToolConfirmation;\n        } else if (functionResponse.response) {\n          toolConfirmation = new ToolConfirmation({\n            hint: functionResponse.response['hint'] as string,\n            payload: functionResponse.response['payload'],\n            confirmed: functionResponse.response['confirmed'] as boolean,\n          });\n        }\n\n        if (functionResponse.id && toolConfirmation) {\n          requestConfirmationFunctionResponses[functionResponse.id] =\n            toolConfirmation;\n        }\n      }\n      if (foundConfirmation) {\n        confirmationEventIndex = i;\n        break;\n      }\n    }\n\n    if (Object.keys(requestConfirmationFunctionResponses).length === 0) {\n      return;\n    }\n\n    // Step 2: Find the system generated FunctionCall event requesting the tool\n    // confirmation\n    for (let i = confirmationEventIndex - 1; i >= 0; i--) {\n      const event = events[i];\n      const functionCalls = getFunctionCalls(event);\n      if (!functionCalls) {\n        continue;\n      }\n\n      const toolsToResumeWithConfirmation: {[key: string]: ToolConfirmation} =\n        {};\n      const toolsToResumeWithArgs: {[key: string]: FunctionCall} = {};\n\n      for (const functionCall of functionCalls) {\n        if (\n          !functionCall.id ||\n          !(functionCall.id in requestConfirmationFunctionResponses)\n        ) {\n          continue;\n        }\n\n        const args = functionCall.args;\n        if (!args || !('originalFunctionCall' in args)) {\n          continue;\n        }\n        const originalFunctionCall = args[\n          'originalFunctionCall'\n        ] as FunctionCall;\n\n        if (originalFunctionCall.id) {\n          toolsToResumeWithConfirmation[originalFunctionCall.id] =\n            requestConfirmationFunctionResponses[functionCall.id];\n          toolsToResumeWithArgs[originalFunctionCall.id] = originalFunctionCall;\n        }\n      }\n      if (Object.keys(toolsToResumeWithConfirmation).length === 0) {\n        continue;\n      }\n\n      // Step 3: Remove the tools that have already been confirmed AND resumed.\n      for (let j = events.length - 1; j > confirmationEventIndex; j--) {\n        const eventToCheck = events[j];\n        const functionResponses = getFunctionResponses(eventToCheck);\n        if (!functionResponses) {\n          continue;\n        }\n\n        for (const fr of functionResponses) {\n          if (fr.id && fr.id in toolsToResumeWithConfirmation) {\n            delete toolsToResumeWithConfirmation[fr.id];\n            delete toolsToResumeWithArgs[fr.id];\n          }\n        }\n        if (Object.keys(toolsToResumeWithConfirmation).length === 0) {\n          break;\n        }\n      }\n\n      if (Object.keys(toolsToResumeWithConfirmation).length === 0) {\n        continue;\n      }\n\n      const toolsList = await agent.canonicalTools(\n        new ReadonlyContext(invocationContext),\n      );\n      const toolsDict = Object.fromEntries(\n        toolsList.map((tool) => [tool.name, tool]),\n      );\n\n      const functionResponseEvent = await handleFunctionCallList({\n        invocationContext: invocationContext,\n        functionCalls: Object.values(toolsToResumeWithArgs),\n        toolsDict: toolsDict,\n        beforeToolCallbacks: agent.canonicalBeforeToolCallbacks,\n        afterToolCallbacks: agent.canonicalAfterToolCallbacks,\n        filters: new Set(Object.keys(toolsToResumeWithConfirmation)),\n        toolConfirmationDict: toolsToResumeWithConfirmation,\n      });\n\n      if (functionResponseEvent) {\n        yield functionResponseEvent;\n      }\n      return;\n    }\n  }\n}\n\nexport const REQUEST_CONFIRMATION_LLM_REQUEST_PROCESSOR =\n  new RequestConfirmationLlmRequestProcessor();\n\n/**\n * Processes code execution requests.\n */\nclass CodeExecutionRequestProcessor extends BaseLlmRequestProcessor {\n  override async *runAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n  ): AsyncGenerator<Event, void, void> {\n    if (!(invocationContext.agent instanceof LlmAgent)) {\n      return;\n    }\n\n    if (!invocationContext.agent.codeExecutor) {\n      return;\n    }\n\n    for await (const event of runPreProcessor(invocationContext, llmRequest)) {\n      yield event;\n    }\n\n    if (!isBaseCodeExecutor(invocationContext.agent.codeExecutor)) {\n      return;\n    }\n\n    for (const content of llmRequest.contents) {\n      const delimeters: [string, string] = invocationContext.agent.codeExecutor\n        .codeBlockDelimiters.length\n        ? invocationContext.agent.codeExecutor.codeBlockDelimiters[0]\n        : ['', ''];\n\n      convertCodeExecutionParts(\n        content,\n        delimeters,\n        invocationContext.agent.codeExecutor.executionResultDelimiters,\n      );\n    }\n  }\n}\n\n/**\n * Map of MIME types to data file utilities\n */\nconst DATA_FILE_UTIL_MAP: Record<\n  string,\n  {\n    extension: string;\n    loaderCodeTemplate: string;\n  }\n> = {\n  'text/csv': {\n    extension: '.csv',\n    loaderCodeTemplate: \"pd.read_csv('{filename}')\",\n  },\n};\n\n/**\n * Helper library for data file exploration\n */\nconst DATA_FILE_HELPER_LIB = `\nimport pandas as pd\n\ndef explore_df(df: pd.DataFrame) -> None:\n  \"\"\"Prints some information about a pandas DataFrame.\"\"\"\n\n  with pd.option_context(\n      'display.max_columns', None, 'display.expand_frame_repr', False\n  ):\n    # Print the column names to never encounter KeyError when selecting one.\n    df_dtypes = df.dtypes\n\n    # Obtain information about data types and missing values.\n    df_nulls = (len(df) - df.isnull().sum()).apply(\n        lambda x: f'{x} / {df.shape[0]} non-null'\n    )\n\n    # Explore unique total values in columns using \\`.unique()\\`.\n    df_unique_count = df.apply(lambda x: len(x.unique()))\n\n    # Explore unique values in columns using \\`.unique()\\`.\n    df_unique = df.apply(lambda x: crop(str(list(x.unique()))))\n\n    df_info = pd.concat(\n        (\n            df_dtypes.rename('Dtype'),\n            df_nulls.rename('Non-Null Count'),\n            df_unique_count.rename('Unique Values Count'),\n            df_unique.rename('Unique Values'),\n        ),\n        axis=1,\n    )\n    df_info.index.name = 'Columns'\n    print(f\"\"\"Total rows: {df.shape[0]}\nTotal columns: {df.shape[1]}\n\n{df_info}\"\"\")\n`;\n\n/**\n * Processor for code execution responses.\n */\nclass CodeExecutionResponseProcessor implements BaseLlmResponseProcessor {\n  /**\n   * Processes the LLM response asynchronously.\n   *\n   * @param invocationContext The invocation context\n   * @param llmResponse The LLM response to process\n   * @returns An async generator yielding events\n   */\n  async *runAsync(\n    invocationContext: InvocationContext,\n    llmResponse: LlmResponse,\n  ): AsyncGenerator<Event, void, unknown> {\n    // Skip if the response is partial (streaming)\n    if (llmResponse.partial) {\n      return;\n    }\n\n    // Run the post-processor with standard generator approach\n    for await (const event of runPostProcessor(\n      invocationContext,\n      llmResponse,\n    )) {\n      yield event;\n    }\n  }\n}\n\n/**\n * The exported response processor instance.\n */\nexport const responseProcessor = new CodeExecutionResponseProcessor();\n\n/**\n * Pre-processes the user message by adding the user message to the execution\n * environment.\n *\n * @param invocationContext The invocation context\n * @param llmRequest The LLM request to process\n * @returns An async generator yielding events\n */\nasync function* runPreProcessor(\n  invocationContext: InvocationContext,\n  llmRequest: LlmRequest,\n): AsyncGenerator<Event, void, unknown> {\n  const agent = invocationContext.agent;\n\n  if (!isLlmAgent(agent)) {\n    return;\n  }\n\n  const codeExecutor = agent.codeExecutor;\n\n  if (!codeExecutor || !isBaseCodeExecutor(codeExecutor)) {\n    return;\n  }\n\n  if (isBuiltInCodeExecutor(codeExecutor)) {\n    codeExecutor.processLlmRequest(llmRequest);\n    return;\n  }\n\n  if (!codeExecutor.optimizeDataFile) {\n    return;\n  }\n\n  const codeExecutorContext = new CodeExecutorContext(\n    new State(invocationContext.session.state),\n  );\n\n  // Skip if the error count exceeds the max retry attempts\n  if (\n    codeExecutorContext.getErrorCount(invocationContext.invocationId) >=\n    codeExecutor.errorRetryAttempts\n  ) {\n    return;\n  }\n\n  // [Step 1] Extract data files from the session_history and store them in\n  // memory Meanwhile, mutate the inline data file to text part in session\n  // history from all turns\n  const allInputFiles = extractAndReplaceInlineFiles(\n    codeExecutorContext,\n    llmRequest,\n  );\n\n  // [Step 2] Run explore_df code on the data files from the current turn\n  // We only need to explore the new data files because the previous data files\n  // should already be explored and cached in the code execution runtime\n  const processedFileNames = new Set(\n    codeExecutorContext.getProcessedFileNames(),\n  );\n  const filesToProcess = allInputFiles.filter(\n    (f) => !processedFileNames.has(f.name),\n  );\n\n  for (const file of filesToProcess) {\n    const codeStr = getDataFilePreprocessingCode(file);\n\n    // Skip for unsupported file or executor types\n    if (!codeStr) {\n      return;\n    }\n\n    // Emit the code to execute, and add it to the LLM request\n    const codeContent: Content = {\n      role: 'model',\n      parts: [\n        {text: `Processing input file: \\`${file.name}\\``},\n        buildExecutableCodePart(codeStr),\n      ],\n    };\n\n    llmRequest.contents.push(cloneDeep(codeContent)!);\n\n    yield createEvent({\n      invocationId: invocationContext.invocationId,\n      author: agent.name,\n      branch: invocationContext.branch,\n      content: codeContent,\n    });\n\n    const executionId = getOrSetExecutionId(\n      invocationContext,\n      codeExecutorContext,\n    );\n    const codeExecutionResult = await codeExecutor.executeCode({\n      invocationContext,\n      codeExecutionInput: {\n        code: codeStr,\n        inputFiles: [file],\n        executionId,\n      },\n    });\n\n    // Update the processing results to code executor context\n    codeExecutorContext.updateCodeExecutionResult({\n      invocationId: invocationContext.invocationId,\n      code: codeStr,\n      resultStdout: codeExecutionResult.stdout,\n      resultStderr: codeExecutionResult.stderr,\n    });\n\n    codeExecutorContext.addProcessedFileNames([file.name]);\n\n    // Emit the execution result, and add it to the LLM request\n    const executionResultEvent = await postProcessCodeExecutionResult(\n      invocationContext,\n      codeExecutorContext,\n      codeExecutionResult,\n    );\n\n    yield executionResultEvent;\n    llmRequest.contents.push(cloneDeep(executionResultEvent.content)!);\n  }\n}\n\n/**\n * Post-processes the model response by extracting and executing the first code\n * block.\n *\n * @param invocationContext The invocation context\n * @param llmResponse The LLM response to process\n * @returns An async generator yielding events\n */\nasync function* runPostProcessor(\n  invocationContext: InvocationContext,\n  llmResponse: LlmResponse,\n): AsyncGenerator<Event, void, unknown> {\n  const agent = invocationContext.agent;\n\n  if (!isLlmAgent(agent)) {\n    return;\n  }\n\n  const codeExecutor = agent.codeExecutor;\n\n  if (!codeExecutor || !isBaseCodeExecutor(codeExecutor)) {\n    return;\n  }\n\n  if (!llmResponse || !llmResponse.content) {\n    return;\n  }\n\n  if (isBuiltInCodeExecutor(codeExecutor)) {\n    return;\n  }\n\n  const codeExecutorContext = new CodeExecutorContext(\n    new State(invocationContext.session.state),\n  );\n\n  // Skip if the error count exceeds the max retry attempts\n  if (\n    codeExecutorContext.getErrorCount(invocationContext.invocationId) >=\n    codeExecutor.errorRetryAttempts\n  ) {\n    return;\n  }\n\n  // [Step 1] Extract code from the model predict response and truncate the\n  // content to the part with the first code block\n  const responseContent = llmResponse.content;\n  const codeStr = extractCodeAndTruncateContent(\n    responseContent,\n    codeExecutor.codeBlockDelimiters,\n  );\n\n  // Terminal state: no code to execute\n  if (!codeStr) {\n    return;\n  }\n\n  // [Step 2] Executes the code and emit 2 Events for code and execution result\n  yield createEvent({\n    invocationId: invocationContext.invocationId,\n    author: agent.name,\n    branch: invocationContext.branch,\n    content: responseContent,\n  });\n\n  const executionId = getOrSetExecutionId(\n    invocationContext,\n    codeExecutorContext,\n  );\n  const codeExecutionResult = await codeExecutor.executeCode({\n    invocationContext,\n    codeExecutionInput: {\n      code: codeStr,\n      inputFiles: codeExecutorContext.getInputFiles(),\n      executionId,\n    },\n  });\n\n  codeExecutorContext.updateCodeExecutionResult({\n    invocationId: invocationContext.invocationId,\n    code: codeStr,\n    resultStdout: codeExecutionResult.stdout,\n    resultStderr: codeExecutionResult.stderr,\n  });\n\n  yield await postProcessCodeExecutionResult(\n    invocationContext,\n    codeExecutorContext,\n    codeExecutionResult,\n  );\n\n  // [Step 3] Skip processing the original model response\n  // to continue code generation loop\n  llmResponse.content = undefined;\n}\n\n/**\n * Extracts and replaces inline files with file names in the LLM request.\n *\n * @param codeExecutorContext The code executor context\n * @param llmRequest The LLM request to process\n * @returns A list of input files\n */\nfunction extractAndReplaceInlineFiles(\n  codeExecutorContext: CodeExecutorContext,\n  llmRequest: LlmRequest,\n): File[] {\n  const allInputFiles = codeExecutorContext.getInputFiles();\n  const savedFileNames = new Set(allInputFiles.map((f) => f.name));\n\n  // [Step 1] Process input files from LlmRequest and cache them in CodeExecutor\n  for (let i = 0; i < llmRequest.contents.length; i++) {\n    const content = llmRequest.contents[i];\n\n    // Only process the user message\n    if (content.role !== 'user' || !content.parts) {\n      continue;\n    }\n\n    for (let j = 0; j < content.parts.length; j++) {\n      const part = content.parts[j] as Part;\n      const mimeType = part.inlineData?.mimeType;\n\n      // Skip if the inline data is not supported\n      if (!mimeType || !part.inlineData || !DATA_FILE_UTIL_MAP[mimeType]) {\n        continue;\n      }\n\n      // Replace the inline data file with a file name placeholder\n      const fileName = `data_${i + 1}_${j + 1}${DATA_FILE_UTIL_MAP[mimeType].extension}`;\n\n      part.text = `\\nAvailable file: \\`${fileName}\\`\\n`;\n\n      // Add the inline data as input file to the code executor context\n      const file: File = {\n        name: fileName,\n        content: base64Decode(part.inlineData.data!),\n        mimeType,\n      };\n\n      if (!savedFileNames.has(fileName)) {\n        codeExecutorContext.addInputFiles([file]);\n        allInputFiles.push(file);\n      }\n    }\n  }\n\n  return allInputFiles;\n}\n\n/**\n * Gets or sets the execution ID for stateful code execution.\n *\n * @param invocationContext The invocation context\n * @param codeExecutorContext The code executor context\n * @returns The execution ID or undefined if not stateful\n */\nfunction getOrSetExecutionId(\n  invocationContext: InvocationContext,\n  codeExecutorContext: CodeExecutorContext,\n): string | undefined {\n  const agent = invocationContext.agent;\n\n  if (!isLlmAgent(agent) || !agent.codeExecutor?.stateful) {\n    return undefined;\n  }\n\n  let executionId = codeExecutorContext.getExecutionId();\n\n  if (!executionId) {\n    executionId = invocationContext.session.id;\n    codeExecutorContext.setExecutionId(executionId);\n  }\n\n  return executionId;\n}\n\n/**\n * Post-processes the code execution result and emits an Event.\n *\n * @param invocationContext The invocation context\n * @param codeExecutorContext The code executor context\n * @param codeExecutionResult The code execution result\n * @returns The event with the code execution result\n */\nasync function postProcessCodeExecutionResult(\n  invocationContext: InvocationContext,\n  codeExecutorContext: CodeExecutorContext,\n  codeExecutionResult: CodeExecutionResult,\n): Promise<Event> {\n  if (!invocationContext.artifactService) {\n    throw new Error('Artifact service is not initialized.');\n  }\n\n  const resultContent: Content = {\n    role: 'model',\n    parts: [buildCodeExecutionResultPart(codeExecutionResult)],\n  };\n\n  const eventActions = createEventActions({\n    stateDelta: codeExecutorContext.getStateDelta(),\n  });\n\n  // Handle code execution error retry\n  if (codeExecutionResult.stderr) {\n    codeExecutorContext.incrementErrorCount(invocationContext.invocationId);\n  } else {\n    codeExecutorContext.resetErrorCount(invocationContext.invocationId);\n  }\n\n  // Handle output files\n  for (const outputFile of codeExecutionResult.outputFiles) {\n    const version = await invocationContext.artifactService.saveArtifact({\n      appName: invocationContext.appName || '',\n      userId: invocationContext.userId || '',\n      sessionId: invocationContext.session.id,\n      filename: outputFile.name,\n      artifact: {\n        inlineData: {data: outputFile.content, mimeType: outputFile.mimeType},\n      },\n    });\n\n    eventActions.artifactDelta[outputFile.name] = version;\n  }\n\n  return createEvent({\n    invocationId: invocationContext.invocationId,\n    author: invocationContext.agent.name,\n    branch: invocationContext.branch,\n    content: resultContent,\n    actions: eventActions,\n  });\n}\n\n/**\n * Returns the code to explore the data file.\n *\n * @param file The file to explore\n * @returns The code to explore the data file or undefined if not supported\n */\nfunction getDataFilePreprocessingCode(file: File): string | undefined {\n  /**\n   * Gets a normalized file name.\n   *\n   * @param fileName The file name to normalize\n   * @returns The normalized file name\n   */\n  function getNormalizedFileName(fileName: string): string {\n    const [varName] = fileName.split('.');\n\n    // Replace non-alphanumeric characters with underscores\n    let normalizedName = varName.replace(/[^a-zA-Z0-9_]/g, '_');\n\n    // If the filename starts with a digit, prepend an underscore\n    if (/^\\d/.test(normalizedName)) {\n      normalizedName = '_' + normalizedName;\n    }\n\n    return normalizedName;\n  }\n\n  if (!DATA_FILE_UTIL_MAP[file.mimeType]) {\n    return undefined;\n  }\n\n  const varName = getNormalizedFileName(file.name);\n  const loaderCode = DATA_FILE_UTIL_MAP[\n    file.mimeType\n  ].loaderCodeTemplate.replace('{filename}', file.name);\n\n  return `\n${DATA_FILE_HELPER_LIB}\n\n# Load the dataframe.\n${varName} = ${loaderCode}\n\n# Use \\`explore_df\\` to guide my analysis.\nexplore_df(${varName})\n`;\n}\n\nconst CODE_EXECUTION_REQUEST_PROCESSOR = new CodeExecutionRequestProcessor();\n\n// --------------------------------------------------------------------------\n// #END RequesBaseCodeExecutort Processors\n// --------------------------------------------------------------------------\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all LlmAgent instances.\n */\nconst LLM_AGENT_SIGNATURE_SYMBOL = Symbol.for('google.adk.llmAgent');\n\n/**\n * Type guard to check if an object is an instance of LlmAgent.\n * @param obj The object to check.\n * @returns True if the object is an instance of LlmAgent, false otherwise.\n */\nexport function isLlmAgent(obj: unknown): obj is LlmAgent {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    LLM_AGENT_SIGNATURE_SYMBOL in obj &&\n    obj[LLM_AGENT_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * An agent that uses a large language model to generate responses.\n */\nexport class LlmAgent extends BaseAgent {\n  /** A unique symbol to identify ADK LLM agent class. */\n  readonly [LLM_AGENT_SIGNATURE_SYMBOL] = true;\n\n  model?: string | BaseLlm;\n  instruction: string | InstructionProvider;\n  globalInstruction: string | InstructionProvider;\n  tools: ToolUnion[];\n  generateContentConfig?: GenerateContentConfig;\n  disallowTransferToParent: boolean;\n  disallowTransferToPeers: boolean;\n  includeContents: 'default' | 'none';\n  inputSchema?: Schema;\n  outputSchema?: Schema;\n  outputKey?: string;\n  beforeModelCallback?: BeforeModelCallback;\n  afterModelCallback?: AfterModelCallback;\n  beforeToolCallback?: BeforeToolCallback;\n  afterToolCallback?: AfterToolCallback;\n  requestProcessors: BaseLlmRequestProcessor[];\n  responseProcessors: BaseLlmResponseProcessor[];\n  codeExecutor?: BaseCodeExecutor;\n\n  constructor(config: LlmAgentConfig) {\n    super(config);\n    this.model = config.model;\n    this.instruction = config.instruction ?? '';\n    this.globalInstruction = config.globalInstruction ?? '';\n    this.tools = config.tools ?? [];\n    this.generateContentConfig = config.generateContentConfig;\n    this.disallowTransferToParent = config.disallowTransferToParent ?? false;\n    this.disallowTransferToPeers = config.disallowTransferToPeers ?? false;\n    this.includeContents = config.includeContents ?? 'default';\n    this.inputSchema = config.inputSchema;\n    this.outputSchema = config.outputSchema;\n    this.outputKey = config.outputKey;\n    this.beforeModelCallback = config.beforeModelCallback;\n    this.afterModelCallback = config.afterModelCallback;\n    this.beforeToolCallback = config.beforeToolCallback;\n    this.afterToolCallback = config.afterToolCallback;\n    this.codeExecutor = config.codeExecutor;\n\n    // TODO - b/425992518: Define these processor arrays.\n    // Orders matter, don't change. Append new processors to the end\n    this.requestProcessors = config.requestProcessors ?? [\n      BASIC_LLM_REQUEST_PROCESSOR,\n      IDENTITY_LLM_REQUEST_PROCESSOR,\n      INSTRUCTIONS_LLM_REQUEST_PROCESSOR,\n      REQUEST_CONFIRMATION_LLM_REQUEST_PROCESSOR,\n      CONTENT_REQUEST_PROCESSOR,\n      CODE_EXECUTION_REQUEST_PROCESSOR,\n    ];\n    this.responseProcessors = config.responseProcessors ?? [];\n\n    // Preserve the agent transfer behavior.\n    const agentTransferDisabled =\n      this.disallowTransferToParent &&\n      this.disallowTransferToPeers &&\n      !this.subAgents?.length;\n    if (!agentTransferDisabled) {\n      this.requestProcessors.push(AGENT_TRANSFER_LLM_REQUEST_PROCESSOR);\n    }\n\n    // Validate generateContentConfig.\n    if (config.generateContentConfig) {\n      if (config.generateContentConfig.tools) {\n        throw new Error('All tools must be set via LlmAgent.tools.');\n      }\n      if (config.generateContentConfig.systemInstruction) {\n        throw new Error(\n          'System instruction must be set via LlmAgent.instruction.',\n        );\n      }\n      if (config.generateContentConfig.responseSchema) {\n        throw new Error(\n          'Response schema must be set via LlmAgent.output_schema.',\n        );\n      }\n    } else {\n      this.generateContentConfig = {};\n    }\n\n    // Validate output schema related configurations.\n    if (this.outputSchema) {\n      if (!this.disallowTransferToParent || !this.disallowTransferToPeers) {\n        logger.warn(\n          `Invalid config for agent ${\n            this.name\n          }: outputSchema cannot co-exist with agent transfer configurations. Setting disallowTransferToParent=true, disallowTransferToPeers=true`,\n        );\n        this.disallowTransferToParent = true;\n        this.disallowTransferToPeers = true;\n      }\n\n      if (this.subAgents && this.subAgents.length > 0) {\n        throw new Error(\n          `Invalid config for agent ${\n            this.name\n          }: if outputSchema is set, subAgents must be empty to disable agent transfer.`,\n        );\n      }\n\n      if (this.tools && this.tools.length > 0) {\n        throw new Error(\n          `Invalid config for agent ${\n            this.name\n          }: if outputSchema is set, tools must be empty`,\n        );\n      }\n    }\n  }\n\n  /**\n   * The resolved BaseLlm instance.\n   *\n   * When not set, the agent will inherit the model from its ancestor.\n   */\n  get canonicalModel(): BaseLlm {\n    if (isBaseLlm(this.model)) {\n      return this.model;\n    }\n\n    if (typeof this.model === 'string' && this.model) {\n      return LLMRegistry.newLlm(this.model);\n    }\n\n    let ancestorAgent = this.parentAgent;\n    while (ancestorAgent) {\n      if (isLlmAgent(ancestorAgent)) {\n        return ancestorAgent.canonicalModel;\n      }\n      ancestorAgent = ancestorAgent.parentAgent;\n    }\n    throw new Error(`No model found for ${this.name}.`);\n  }\n\n  /**\n   * The resolved instruction field to construct instruction for this\n   * agent.\n   *\n   * This method is only for use by Agent Development Kit.\n   * @param context The context to retrieve the session state.\n   * @returns The resolved instruction field.\n   */\n  async canonicalInstruction(\n    context: ReadonlyContext,\n  ): Promise<{instruction: string; requireStateInjection: boolean}> {\n    if (typeof this.instruction === 'string') {\n      return {instruction: this.instruction, requireStateInjection: true};\n    }\n    return {\n      instruction: await this.instruction(context),\n      requireStateInjection: false,\n    };\n  }\n\n  /**\n   * The resolved globalInstruction field to construct global instruction.\n   *\n   * This method is only for use by Agent Development Kit.\n   * @param context The context to retrieve the session state.\n   * @returns The resolved globalInstruction field.\n   */\n  async canonicalGlobalInstruction(\n    context: ReadonlyContext,\n  ): Promise<{instruction: string; requireStateInjection: boolean}> {\n    if (typeof this.globalInstruction === 'string') {\n      return {\n        instruction: this.globalInstruction,\n        requireStateInjection: true,\n      };\n    }\n    return {\n      instruction: await this.globalInstruction(context),\n      requireStateInjection: false,\n    };\n  }\n\n  /**\n   * The resolved tools field as a list of BaseTool based on the context.\n   *\n   * This method is only for use by Agent Development Kit.\n   */\n  async canonicalTools(context?: ReadonlyContext): Promise<BaseTool[]> {\n    const resolvedTools: BaseTool[] = [];\n    for (const toolUnion of this.tools) {\n      const tools = await convertToolUnionToTools(toolUnion, context);\n      resolvedTools.push(...tools);\n    }\n    return resolvedTools;\n  }\n\n  /**\n   * Normalizes a callback or an array of callbacks into an array of callbacks.\n   *\n   * @param callback The callback or an array of callbacks.\n   * @returns An array of callbacks.\n   */\n  private static normalizeCallbackArray<T>(callback?: T | T[]): T[] {\n    if (!callback) {\n      return [];\n    }\n    if (Array.isArray(callback)) {\n      return callback;\n    }\n    return [callback];\n  }\n\n  /**\n   * The resolved beforeModelCallback field as a list of\n   * SingleBeforeModelCallback.\n   *\n   * This method is only for use by Agent Development Kit.\n   */\n  get canonicalBeforeModelCallbacks(): SingleBeforeModelCallback[] {\n    return LlmAgent.normalizeCallbackArray(this.beforeModelCallback);\n  }\n\n  /**\n   * The resolved afterModelCallback field as a list of\n   * SingleAfterModelCallback.\n   *\n   * This method is only for use by Agent Development Kit.\n   */\n  get canonicalAfterModelCallbacks(): SingleAfterModelCallback[] {\n    return LlmAgent.normalizeCallbackArray(this.afterModelCallback);\n  }\n\n  /**\n   * The resolved beforeToolCallback field as a list of\n   * BeforeToolCallback.\n   *\n   * This method is only for use by Agent Development Kit.\n   */\n  get canonicalBeforeToolCallbacks(): SingleBeforeToolCallback[] {\n    return LlmAgent.normalizeCallbackArray(this.beforeToolCallback);\n  }\n\n  /**\n   * The resolved afterToolCallback field as a list of AfterToolCallback.\n   *\n   * This method is only for use by Agent Development Kit.\n   */\n  get canonicalAfterToolCallbacks(): SingleAfterToolCallback[] {\n    return LlmAgent.normalizeCallbackArray(this.afterToolCallback);\n  }\n\n  /**\n   * Saves the agent's final response to the session state if configured.\n   *\n   * It extracts the text content from the final response event, optionally\n   * parses it as JSON based on the output schema, and stores the result in the\n   * session state using the specified output key.\n   *\n   * @param event The event to process.\n   */\n  private maybeSaveOutputToState(event: Event) {\n    if (event.author !== this.name) {\n      logger.debug(\n        `Skipping output save for agent ${this.name}: event authored by ${\n          event.author\n        }`,\n      );\n      return;\n    }\n    if (!this.outputKey) {\n      logger.debug(\n        `Skipping output save for agent ${this.name}: outputKey is not set`,\n      );\n      return;\n    }\n    if (!isFinalResponse(event)) {\n      logger.debug(\n        `Skipping output save for agent ${\n          this.name\n        }: event is not a final response`,\n      );\n      return;\n    }\n    if (!event.content?.parts?.length) {\n      logger.debug(\n        `Skipping output save for agent ${this.name}: event content is empty`,\n      );\n      return;\n    }\n\n    const resultStr: string = event.content.parts\n      .map((part) => (part.text ? part.text : ''))\n      .join('');\n    let result: unknown = resultStr;\n    if (this.outputSchema) {\n      // If the result from the final chunk is just whitespace or empty,\n      // it means this is an empty final chunk of a stream.\n      // Do not attempt to parse it as JSON.\n      if (!resultStr.trim()) {\n        return;\n      }\n      // TODO - b/425992518: Use a proper Schema validation utility.\n      // Should use output schema to validate the JSON.\n      try {\n        result = JSON.parse(resultStr);\n      } catch (e) {\n        logger.error(`Error parsing output for agent ${this.name}`, e);\n      }\n    }\n    event.actions.stateDelta[this.outputKey] = result;\n  }\n\n  protected async *runAsyncImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    while (true) {\n      let lastEvent: Event | undefined = undefined;\n      for await (const event of this.runOneStepAsync(context)) {\n        lastEvent = event;\n        this.maybeSaveOutputToState(event);\n        yield event;\n      }\n\n      if (!lastEvent || isFinalResponse(lastEvent)) {\n        break;\n      }\n      if (lastEvent.partial) {\n        logger.warn('The last event is partial, which is not expected.');\n        break;\n      }\n    }\n  }\n\n  protected async *runLiveImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    for await (const event of this.runLiveFlow(context)) {\n      this.maybeSaveOutputToState(event);\n      yield event;\n    }\n    if (context.endInvocation) {\n      return;\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // #START LlmFlow Logic\n  // --------------------------------------------------------------------------\n  // eslint-disable-next-line require-yield\n  private async *runLiveFlow(\n    _invocationContext: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    // TODO - b/425992518: remove dummy logic, implement this.\n    await Promise.resolve();\n    throw new Error('LlmAgent.runLiveFlow not implemented');\n  }\n\n  private async *runOneStepAsync(\n    invocationContext: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    const llmRequest: LlmRequest = {\n      contents: [],\n      toolsDict: {},\n      liveConnectConfig: {},\n    };\n\n    // =========================================================================\n    // Preprocess before calling the LLM\n    // =========================================================================\n    // Runs request processors.\n    for (const processor of this.requestProcessors) {\n      for await (const event of processor.runAsync(\n        invocationContext,\n        llmRequest,\n      )) {\n        yield event;\n      }\n    }\n    // TODO - b/425992518: check if tool preprocessors can be simplified.\n    // Run pre-processors for tools.\n    for (const toolUnion of this.tools) {\n      const toolContext = new ToolContext({invocationContext});\n\n      // process all tools from this tool union\n      const tools = await convertToolUnionToTools(\n        toolUnion,\n        new ReadonlyContext(invocationContext),\n      );\n      for (const tool of tools) {\n        await tool.processLlmRequest({toolContext, llmRequest});\n      }\n    }\n    // =========================================================================\n    // Global runtime interruption\n    // =========================================================================\n    // TODO - b/425992518: global runtime interruption, hacky, fix.\n    if (invocationContext.endInvocation) {\n      return;\n    }\n\n    // =========================================================================\n    // Calls the LLM\n    // =========================================================================\n    // TODO - b/425992518: misleading, this is passing metadata.\n    const modelResponseEvent = createEvent({\n      invocationId: invocationContext.invocationId,\n      author: this.name,\n      branch: invocationContext.branch,\n    });\n    const span = tracer.startSpan('call_llm');\n    const ctx = trace.setSpan(context.active(), span);\n    yield* runAsyncGeneratorWithOtelContext<LlmAgent, Event>(\n      ctx,\n      this,\n      async function* () {\n        for await (const llmResponse of this.callLlmAsync(\n          invocationContext,\n          llmRequest,\n          modelResponseEvent,\n        )) {\n          // ======================================================================\n          // Postprocess after calling the LLM\n          // ======================================================================\n          for await (const event of this.postprocess(\n            invocationContext,\n            llmRequest,\n            llmResponse,\n            modelResponseEvent,\n          )) {\n            // Update the mutable event id to avoid conflict\n            modelResponseEvent.id = createNewEventId();\n            modelResponseEvent.timestamp = new Date().getTime();\n            yield event;\n          }\n        }\n      },\n    );\n    span.end();\n  }\n\n  private async *postprocess(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n    llmResponse: LlmResponse,\n    modelResponseEvent: Event,\n  ): AsyncGenerator<Event, void, void> {\n    // =========================================================================\n    // Runs response processors\n    // =========================================================================\n    for (const processor of this.responseProcessors) {\n      for await (const event of processor.runAsync(\n        invocationContext,\n        llmResponse,\n      )) {\n        yield event;\n      }\n    }\n\n    // =========================================================================\n    // Builds the merged model response event\n    // =========================================================================\n    // If no model response, skip.\n    if (\n      !llmResponse.content &&\n      !llmResponse.errorCode &&\n      !llmResponse.interrupted\n    ) {\n      return;\n    }\n\n    // Merge llm response with model response event.\n    const mergedEvent = createEvent({\n      ...modelResponseEvent,\n      ...llmResponse,\n    });\n\n    if (mergedEvent.content) {\n      const functionCalls = getFunctionCalls(mergedEvent);\n      if (functionCalls?.length) {\n        // TODO - b/425992518: rename topopulate if missing.\n        populateClientFunctionCallId(mergedEvent);\n        // TODO - b/425992518: hacky, transaction log, simplify.\n        // Long running is a property of tool in registry.\n        mergedEvent.longRunningToolIds = Array.from(\n          getLongRunningFunctionCalls(functionCalls, llmRequest.toolsDict),\n        );\n      }\n    }\n    yield mergedEvent;\n\n    // =========================================================================\n    // Process function calls if any, which inlcudes agent transfer.\n    // =========================================================================\n    if (!getFunctionCalls(mergedEvent)?.length) {\n      return;\n    }\n\n    // Call functions\n    // TODO - b/425992518: bloated funciton input, fix.\n    // Tool callback passed to get rid of cyclic dependency.\n    const functionResponseEvent = await handleFunctionCallsAsync({\n      invocationContext: invocationContext,\n      functionCallEvent: mergedEvent,\n      toolsDict: llmRequest.toolsDict,\n      beforeToolCallbacks: this.canonicalBeforeToolCallbacks,\n      afterToolCallbacks: this.canonicalAfterToolCallbacks,\n    });\n\n    if (!functionResponseEvent) {\n      return;\n    }\n\n    // Yiels an authentication event if any.\n    // TODO - b/425992518: transaction log session, simplify.\n    const authEvent = generateAuthEvent(\n      invocationContext,\n      functionResponseEvent,\n    );\n    if (authEvent) {\n      yield authEvent;\n    }\n\n    // Yields a tool confirmation event if any.\n    const toolConfirmationEvent = generateRequestConfirmationEvent({\n      invocationContext: invocationContext,\n      functionCallEvent: mergedEvent,\n      functionResponseEvent: functionResponseEvent,\n    });\n    if (toolConfirmationEvent) {\n      yield toolConfirmationEvent;\n    }\n\n    // Yields the function response event.\n    yield functionResponseEvent;\n\n    // If model instruct to transfer to an agent, run the transferred agent.\n    const nextAgentName = functionResponseEvent.actions.transferToAgent;\n    if (nextAgentName) {\n      const nextAgent = this.getAgentByName(invocationContext, nextAgentName);\n      for await (const event of nextAgent.runAsync(invocationContext)) {\n        yield event;\n      }\n    }\n  }\n\n  /**\n   * Retrieves an agent from the agent tree by its name.\n   *\n   * Performing a depth-first search to locate the agent with the given name.\n   * - Starts searching from the root agent of the current invocation context.\n   * - Traverses down the agent tree to find the specified agent.\n   *\n   * @param invocationContext The current invocation context.\n   * @param agentName The name of the agent to retrieve.\n   * @returns The agent with the given name.\n   * @throws Error if the agent is not found.\n   */\n  private getAgentByName(\n    invocationContext: InvocationContext,\n    agentName: string,\n  ): BaseAgent {\n    const rootAgent = invocationContext.agent.rootAgent;\n    const agentToRun = rootAgent.findAgent(agentName);\n    if (!agentToRun) {\n      throw new Error(`Agent ${agentName} not found in the agent tree.`);\n    }\n    return agentToRun;\n  }\n\n  private async *callLlmAsync(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n    modelResponseEvent: Event,\n  ): AsyncGenerator<LlmResponse, void, void> {\n    // Runs before_model_callback if it exists.\n    const beforeModelResponse = await this.handleBeforeModelCallback(\n      invocationContext,\n      llmRequest,\n      modelResponseEvent,\n    );\n    if (beforeModelResponse) {\n      yield beforeModelResponse;\n      return;\n    }\n\n    llmRequest.config ??= {};\n    llmRequest.config.labels ??= {};\n\n    // Add agent name as a label to the llm_request. This will help with slicing\n    // the billing reports on a per-agent basis.\n    if (!llmRequest.config.labels[ADK_AGENT_NAME_LABEL_KEY]) {\n      llmRequest.config.labels[ADK_AGENT_NAME_LABEL_KEY] = this.name;\n    }\n\n    // Calls the LLM.\n    const llm = this.canonicalModel;\n    if (invocationContext.runConfig?.supportCfc) {\n      // TODO - b/425992518: Implement CFC call path\n      // This is a hack, underneath it calls runLive. Which makes\n      // runLive/run mixed.\n      throw new Error('CFC is not yet supported in callLlmAsync');\n    } else {\n      invocationContext.incrementLlmCallCount();\n      const responsesGenerator = llm.generateContentAsync(\n        llmRequest,\n        /* stream= */ invocationContext.runConfig?.streamingMode ===\n          StreamingMode.SSE,\n      );\n\n      for await (const llmResponse of this.runAndHandleError(\n        responsesGenerator,\n        invocationContext,\n        llmRequest,\n        modelResponseEvent,\n      )) {\n        traceCallLlm({\n          invocationContext,\n          eventId: modelResponseEvent.id,\n          llmRequest,\n          llmResponse,\n        });\n        // Runs after_model_callback if it exists.\n        const alteredLlmResponse = await this.handleAfterModelCallback(\n          invocationContext,\n          llmResponse,\n          modelResponseEvent,\n        );\n        yield alteredLlmResponse ?? llmResponse;\n      }\n    }\n  }\n\n  private async handleBeforeModelCallback(\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n    modelResponseEvent: Event,\n  ): Promise<LlmResponse | undefined> {\n    // TODO - b/425992518: Clean up eventActions from CallbackContext here as\n    // modelResponseEvent.actions is always empty.\n    const callbackContext = new CallbackContext({\n      invocationContext,\n      eventActions: modelResponseEvent.actions,\n    });\n\n    // Plugin callbacks before canonical callbacks\n    const beforeModelCallbackResponse =\n      await invocationContext.pluginManager.runBeforeModelCallback({\n        callbackContext,\n        llmRequest,\n      });\n    if (beforeModelCallbackResponse) {\n      return beforeModelCallbackResponse;\n    }\n\n    // If no override was returned from the plugins, run the canonical callbacks\n    for (const callback of this.canonicalBeforeModelCallbacks) {\n      const callbackResponse = await callback({\n        context: callbackContext,\n        request: llmRequest,\n      });\n      if (callbackResponse) {\n        return callbackResponse;\n      }\n    }\n    return undefined;\n  }\n\n  private async handleAfterModelCallback(\n    invocationContext: InvocationContext,\n    llmResponse: LlmResponse,\n    modelResponseEvent: Event,\n  ): Promise<LlmResponse | undefined> {\n    const callbackContext = new CallbackContext({\n      invocationContext,\n      eventActions: modelResponseEvent.actions,\n    });\n\n    // Plugin callbacks before canonical callbacks\n    const afterModelCallbackResponse =\n      await invocationContext.pluginManager.runAfterModelCallback({\n        callbackContext,\n        llmResponse,\n      });\n    if (afterModelCallbackResponse) {\n      return afterModelCallbackResponse;\n    }\n\n    // If no override was returned from the plugins, run the canonical callbacks\n    for (const callback of this.canonicalAfterModelCallbacks) {\n      const callbackResponse = await callback({\n        context: callbackContext,\n        response: llmResponse,\n      });\n      if (callbackResponse) {\n        return callbackResponse;\n      }\n    }\n    return undefined;\n  }\n\n  private async *runAndHandleError(\n    responseGenerator: AsyncGenerator<LlmResponse, void, void>,\n    invocationContext: InvocationContext,\n    llmRequest: LlmRequest,\n    modelResponseEvent: Event,\n  ): AsyncGenerator<LlmResponse, void, void> {\n    try {\n      for await (const response of responseGenerator) {\n        yield response;\n      }\n    } catch (modelError: unknown) {\n      // Return an LlmResponse with error details.\n      // Note: this will cause agent to work better if there's a loop.\n      const callbackContext = new CallbackContext({\n        invocationContext,\n        eventActions: modelResponseEvent.actions,\n      });\n\n      // Wrapped LLM should throw Error-typed errors\n      if (modelError instanceof Error) {\n        // Try plugins to recover from the error\n        const onModelErrorCallbackResponse =\n          await invocationContext.pluginManager.runOnModelErrorCallback({\n            callbackContext: callbackContext,\n            llmRequest: llmRequest,\n            error: modelError as Error,\n          });\n\n        if (onModelErrorCallbackResponse) {\n          yield onModelErrorCallbackResponse;\n        } else {\n          // If no plugins, just return the message.\n          const errorResponse = JSON.parse(modelError.message) as {\n            error: {code: number; message: string};\n          };\n\n          yield {\n            errorCode: String(errorResponse.error.code),\n            errorMessage: errorResponse.error.message,\n          };\n        }\n      } else {\n        logger.error('Unknown error during response generation', modelError);\n        throw modelError;\n      }\n    }\n  }\n\n  // --------------------------------------------------------------------------\n  // #END LlmFlow Logic\n  // --------------------------------------------------------------------------\n\n  // TODO - b/425992518: omitted Py LlmAgent features.\n  // - code_executor\n  // - configurable agents by yaml config\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {InvocationContext} from '../agents/invocation_context.js';\n\nimport {\n  CodeExecutionInput,\n  CodeExecutionResult,\n} from './code_execution_utils.js';\n\n/**\n * The parameters for executing code.\n * */\nexport interface ExecuteCodeParams {\n  /** The invocation context of the code execution. */\n  invocationContext: InvocationContext;\n  /** The input of the code execution. */\n  codeExecutionInput: CodeExecutionInput;\n}\n\n/**\n * A unique symbol to identify BaseCodeExecutor classes.\n * Defined once and shared by all BaseCodeExecutor instances.\n */\nconst BASE_CODE_EXECUTOR_SIGNATURE_SYMBOL = Symbol.for(\n  'google.adk.baseCodeExecutor',\n);\n\n/**\n * Type guard to check if an object is an instance of BaseCodeExecutor.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseCodeExecutor, false otherwise.\n */\nexport function isBaseCodeExecutor(obj: unknown): obj is BaseCodeExecutor {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BASE_CODE_EXECUTOR_SIGNATURE_SYMBOL in obj &&\n    obj[BASE_CODE_EXECUTOR_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * The code executor allows the agent to execute code blocks from model\n * responses and incorporate the execution results into the final response.\n */\nexport abstract class BaseCodeExecutor {\n  /** A unique symbol to identify BaseCodeExecutor class. */\n  readonly [BASE_CODE_EXECUTOR_SIGNATURE_SYMBOL] = true;\n  /**\n   * If true, extract and process data files from the model request\n   * and attach them to the code executor.\n   *\n   * Supported data file MimeTypes are [text/csv].\n   * Default to false.\n   */\n  optimizeDataFile = false;\n\n  /**\n   * Whether the code executor is stateful. Default to false.\n   */\n  stateful = false;\n\n  /**\n   * The number of attempts to retry on consecutive code execution errors.\n   * Default to 2.\n   */\n  errorRetryAttempts = 2;\n\n  /**\n   * The list of the enclosing delimiters to identify the code blocks.\n   * For example, the delimiter('```python\\\\n', '\\\\n```') can be  used to\n   * identify code blocks with the following format::\n   *\n   * ```python\n   *  print(\"hello\")\n   * ```\n   */\n  codeBlockDelimiters: Array<[string, string]> = [\n    ['```tool_code\\n', '\\n```'],\n    ['```python\\n', '\\n```'],\n  ];\n\n  /**\n   * The delimiters to format the code execution result.\n   */\n  executionResultDelimiters: [string, string] = ['```tool_output\\n', '\\n```'];\n\n  /**\n   * Executes code and return the code execution result.\n   *\n   * @param params The parameters for executing code.\n   * @return The result of the code execution.\n   */\n  abstract executeCode(params: ExecuteCodeParams): Promise<CodeExecutionResult>;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nconst MODEL_NAME_PATTERN =\n  '^projects/[^/]+/locations/[^/]+/publishers/[^/]+/models/(.+)$';\n\n/**\n * Extract the actual model name from either simple or path-based format.\n *\n * @param modelString Either a simple model name like \"gemini-2.5-pro\" or\n *     a path-based model name like \"projects/.../models/gemini-2.0-flash-001\"\n * @return The extracted model name (e.g., \"gemini-2.5-pro\")\n */\nexport function extractModelName(modelString: string): string {\n  const match = modelString.match(MODEL_NAME_PATTERN);\n  if (match) {\n    return match[1];\n  }\n\n  // If it's not a path-based model, return as-is (simple model name)\n  return modelString;\n}\n\n/**\n * Check if the model is a Gemini model using regex patterns.\n *\n * @param modelString Either a simple model name or path - based model name\n * @return true if it's a Gemini model, false otherwise.\n */\nexport function isGeminiModel(modelString: string): boolean {\n  const modelName = extractModelName(modelString);\n\n  return modelName.startsWith('gemini-');\n}\n\ninterface ParsedVersion {\n  valid: boolean;\n  major: number;\n  minor: number;\n  patch: number;\n}\n\nfunction parseVersion(versionString: string): ParsedVersion {\n  if (!/^\\d+(\\.\\d+)*$/.test(versionString)) {\n    return {valid: false, major: 0, minor: 0, patch: 0};\n  }\n  const parts = versionString.split('.').map((part) => parseInt(part, 10));\n\n  return {\n    valid: true,\n    major: parts[0],\n    minor: parts.length > 1 ? parts[1] : 0,\n    patch: parts.length > 2 ? parts[2] : 0,\n  };\n}\n\n/**\n * Check if the model is a Gemini 1.x model using regex patterns.\n *\n * @param modelString Either a simple model name or path - based model name\n * @return true if it's a Gemini 1.x model, false otherwise.\n */\nexport function isGemini1Model(modelString: string): boolean {\n  const modelName = extractModelName(modelString);\n\n  return modelName.startsWith('gemini-1');\n}\n\n/**\n * Check if the model is a Gemini 2.x model using regex patterns.\n *\n * @param modelString Either a simple model name or path - based model name\n * @return true if it's a Gemini 2.x model, false otherwise.\n */\nexport function isGemini2OrAbove(modelString: string): boolean {\n  if (!modelString) {\n    return false;\n  }\n\n  const modelName = extractModelName(modelString);\n\n  if (!modelName.startsWith('gemini-')) {\n    return false;\n  }\n\n  const versionString = modelName.slice('gemini-'.length).split('-', 1)[0];\n\n  const parsedVersion = parseVersion(versionString);\n  return parsedVersion.valid && parsedVersion.major >= 2;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {LlmRequest} from '../models/llm_request.js';\nimport {isGemini2OrAbove} from '../utils/model_name.js';\n\nimport {BaseCodeExecutor, ExecuteCodeParams} from './base_code_executor.js';\nimport {CodeExecutionResult} from './code_execution_utils.js';\n\n/**\n * A unique symbol to identify BuiltInCodeExecutor classes.\n * Defined once and shared by all BuiltInCodeExecutor instances.\n */\nconst BUILT_IN_CODE_EXECUTOR_SIGNATURE_SYMBOL = Symbol.for(\n  'google.adk.builtInCodeExecutor',\n);\n\n/**\n * Type guard to check if an object is an instance of BuiltInCodeExecutor.\n * @param obj The object to check.\n * @returns True if the object is an instance of BuiltInCodeExecutor, false otherwise.\n */\nexport function isBuiltInCodeExecutor(\n  obj: unknown,\n): obj is BuiltInCodeExecutor {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BUILT_IN_CODE_EXECUTOR_SIGNATURE_SYMBOL in obj &&\n    obj[BUILT_IN_CODE_EXECUTOR_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * A code executor that uses the Model's built-in code executor.\n *\n * Currently only supports Gemini 2.0+ models, but will be expanded to\n * other models.\n */\nexport class BuiltInCodeExecutor extends BaseCodeExecutor {\n  /** A unique symbol to identify BuiltInCodeExecutor class. */\n  readonly [BUILT_IN_CODE_EXECUTOR_SIGNATURE_SYMBOL] = true;\n\n  executeCode(_params: ExecuteCodeParams): Promise<CodeExecutionResult> {\n    return Promise.resolve({\n      stdout: '',\n      stderr: '',\n      outputFiles: [],\n    });\n  }\n\n  processLlmRequest(llmRequest: LlmRequest) {\n    if (llmRequest.model && isGemini2OrAbove(llmRequest.model)) {\n      llmRequest.config = llmRequest.config || {};\n      llmRequest.config.tools = llmRequest.config.tools || [];\n      llmRequest.config.tools.push({codeExecution: {}});\n\n      return;\n    }\n\n    throw new Error(\n      `Gemini code execution tool is not supported for model ${llmRequest.model}`,\n    );\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {Content, Language, Outcome, Part} from '@google/genai';\nimport {cloneDeep} from 'lodash-es';\n\nimport {base64Encode, isBase64Encoded} from '../utils/env_aware_utils.js';\n\n/**\n * A structure that contains a file name and its content\n */\nexport interface File {\n  /**\n   * The name of the file with file extension(e.g., ' file.csv')\n   * */\n  name: string;\n\n  /**\n   * The base64 - encoded bytes of the file content.\n   * */\n  content: string;\n\n  /**\n   * The mime type of the file (e.g., ' image / png')\n   * */\n  mimeType: string;\n}\n\n/**\n * A structure that contains the input of code execution.\n * */\nexport interface CodeExecutionInput {\n  /**\n   * The code to execute.\n   * */\n  code: string;\n\n  /**\n   * The input files available to the code.\n   * */\n  inputFiles: File[];\n\n  /**\n   * The execution ID for the stateful code execution.\n   * */\n  executionId?: string;\n}\n\n/**\n * A structure that contains the result of code execution.\n * */\nexport interface CodeExecutionResult {\n  /**\n   * The standard output of the code execution.\n   * */\n  stdout: string;\n\n  /**\n   * The standard error of the code execution.\n   * */\n  stderr: string;\n\n  /**\n   * The output files from the code execution.\n   * */\n  outputFiles: File[];\n}\n\n/**\n * Gets the file content as a base64-encoded bytes.\n *\n * @param data The file content bytes.\n * @return The file content as a base64-encoded bytes.\n */\nexport function getEncodedFileContent(data: string): string {\n  return isBase64Encoded(data) ? data : base64Encode(data);\n}\n\n// Type to be used for regex matching of code blocks.\ninterface CodeGroupMatch {\n  groups?: {prefix?: string; codeStr?: string};\n  index?: number;\n  length?: number;\n}\n\n/**\n * Extracts the first code block from the content and truncate everything after\n * it.\n *\n * @param content The mutable content to extract the code from.\n * @param codeBlockDelimiters The list of the enclosing delimiters to identify\n *     the code blocks.\n * @return The first code block if found, otherwise None.\n */\nexport function extractCodeAndTruncateContent(\n  content: Content,\n  codeBlockDelimiters: Array<[string, string]>,\n): string {\n  if (!content.parts?.length) {\n    return '';\n  }\n\n  // Extract the code from the executable code parts if there're no associated\n  // code execution result parts.\n  for (let i = 0; i < content.parts.length; i++) {\n    const part = content.parts[i];\n    if (\n      part.executableCode &&\n      (i === content.parts.length - 1 ||\n        !content.parts[i + 1].codeExecutionResult)\n    ) {\n      content.parts = content.parts.slice(0, i + 1);\n      return part.executableCode.code!;\n    }\n  }\n\n  // Extract the code from the text parts.\n  const textParts = content.parts.filter((part) => part.text);\n  if (!textParts.length) {\n    return '';\n  }\n\n  const firstTextPart = cloneDeep(textParts[0])!;\n  const responseText = textParts.map((part) => part.text!).join('\\n');\n\n  // Find the first code block.\n  const leadingDelimiterPattern = codeBlockDelimiters\n    .map((d) => d[0])\n    .join('|');\n  const trailingDelimiterPattern = codeBlockDelimiters\n    .map((d) => d[1])\n    .join('|');\n  const match = new RegExp(\n    `?<prefix>.*?)(${leadingDelimiterPattern})(?<codeStr>.*?)(${trailingDelimiterPattern})(?<suffix>.*?)$`,\n    's',\n  ).exec(responseText) as unknown as CodeGroupMatch | null;\n\n  const {prefix, codeStr} = match?.groups || {};\n\n  if (!codeStr) {\n    return '';\n  }\n\n  content.parts = [];\n\n  if (prefix) {\n    firstTextPart.text = prefix;\n    content.parts.push(firstTextPart);\n  }\n  content.parts.push(buildExecutableCodePart(codeStr));\n\n  return codeStr;\n}\n\n/**\n * Builds an executable code part with code string.\n *\n * @param code The code string.\n * @return The constructed executable code part.\n */\nexport function buildExecutableCodePart(code: string): Part {\n  return {\n    text: code,\n    executableCode: {\n      code,\n      language: Language.PYTHON,\n    },\n  };\n}\n\n/**\n * Builds the code execution result part from the code execution result.\n *\n * @param codeExecutionResult The code execution result.\n * @return The code execution result part.\n */\nexport function buildCodeExecutionResultPart(\n  codeExecutionResult: CodeExecutionResult,\n): Part {\n  if (codeExecutionResult.stderr) {\n    return {\n      text: codeExecutionResult.stderr,\n      codeExecutionResult: {\n        outcome: Outcome.OUTCOME_FAILED,\n      },\n    };\n  }\n\n  const finalResult = [];\n  if (codeExecutionResult.stdout || !codeExecutionResult.outputFiles) {\n    finalResult.push(`Code execution result:\\n${codeExecutionResult.stdout}\\n`);\n  }\n  if (codeExecutionResult.outputFiles) {\n    finalResult.push(\n      `Saved artifacts:\\n` +\n        codeExecutionResult.outputFiles.map((f) => f.name).join(', '),\n    );\n  }\n\n  return {\n    text: finalResult.join('\\n\\n'),\n    codeExecutionResult: {\n      outcome: Outcome.OUTCOME_OK,\n    },\n  };\n}\n\n/**\n * Converts the code execution parts to text parts in a Content.\n *\n * @param content The mutable content to convert the code execution parts to\n *     text parts.\n * @param codeBlockDelimiter The delimiter to format the code block.\n * @param executionResultDelimiters The delimiter to format the code execution\n *     result.\n * @return The converted content.\n */\nexport function convertCodeExecutionParts(\n  content: Content,\n  codeBlockDelimiter: [string, string],\n  executionResultDelimiters: [string, string],\n) {\n  if (!content.parts?.length) {\n    return;\n  }\n\n  const lastPart = content.parts[content.parts.length - 1];\n\n  if (lastPart.executableCode) {\n    content.parts[content.parts.length - 1] = {\n      text:\n        codeBlockDelimiter[0] +\n        lastPart.executableCode.code +\n        codeBlockDelimiter[1],\n    };\n  } else if (content.parts.length == 1 && lastPart.codeExecutionResult) {\n    content.parts[content.parts.length - 1] = {\n      text:\n        executionResultDelimiters[0] +\n        lastPart.codeExecutionResult.output +\n        executionResultDelimiters[1],\n    };\n    content.role = 'user';\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {cloneDeep} from 'lodash-es';\n\nimport {State} from '../sessions/state.js';\n\nimport {File} from './code_execution_utils.js';\n\nconst CONTEXT_KEY = '_code_execution_context';\nconst SESSION_ID_KEY = 'execution_session_id';\nconst PROCESSED_FILE_NAMES_KEY = 'processed_input_files';\nconst INPUT_FILE_KEY = '_code_executor_input_files';\nconst ERROR_COUNT_KEY = '_code_executor_error_counts';\nconst CODE_EXECUTION_RESULTS_KEY = '_code_execution_results';\n\ninterface CodeExecutionResult {\n  code: string;\n  resultStdout: string;\n  resultStderr: string;\n  timestamp: number;\n}\n\n/**\n * The parameters for updating the code execution result.\n * */\nexport interface UpdateCodeExecutionResultParams {\n  invocationId: string;\n  code: string;\n  resultStdout: string;\n  resultStderr: string;\n}\n\n/**\n * The persistent context used to configure the code executor.\n */\nexport class CodeExecutorContext {\n  private readonly context: {\n    [SESSION_ID_KEY]?: string;\n    [PROCESSED_FILE_NAMES_KEY]?: string[];\n  };\n\n  constructor(private readonly sessionState: State) {\n    this.context = sessionState.get(CONTEXT_KEY) ?? {};\n    this.sessionState = sessionState;\n  }\n\n  /**\n   * Gets the state delta to update in the persistent session state.\n   * @return The state delta to update in the persistent session state.\n   */\n  getStateDelta(): Record<string, unknown> {\n    return {\n      [CONTEXT_KEY]: cloneDeep(this.context),\n    };\n  }\n\n  /**\n   * Gets the execution ID for the code executor.\n   * @return The execution ID for the code executor.\n   */\n  getExecutionId(): string | undefined {\n    if (!(SESSION_ID_KEY in this.context)) {\n      return undefined;\n    }\n\n    return this.context[SESSION_ID_KEY];\n  }\n\n  /**\n   * Sets the execution ID for the code executor.\n   * @param executionId The execution ID to set.\n   */\n  setExecutionId(executionId: string) {\n    this.context[SESSION_ID_KEY] = executionId;\n  }\n\n  /**\n   * Gets the processed file names from the session state.\n   * @return A list of processed file names in the code executor context.\n   */\n  getProcessedFileNames(): string[] {\n    if (!(PROCESSED_FILE_NAMES_KEY in this.context)) {\n      return [];\n    }\n\n    return this.context[PROCESSED_FILE_NAMES_KEY]!;\n  }\n\n  /**\n   * Adds the processed file names to the session state.\n   * @param fileNames The file names to add to the session state.\n   */\n  addProcessedFileNames(fileNames: string[]) {\n    if (!(PROCESSED_FILE_NAMES_KEY in this.context)) {\n      this.context[PROCESSED_FILE_NAMES_KEY] = [];\n    }\n\n    this.context[PROCESSED_FILE_NAMES_KEY]!.push(...fileNames);\n  }\n\n  /**\n   * Gets the input files from the session state.\n   * @return A list of input files in the code executor context.\n   */\n  getInputFiles(): File[] {\n    if (!(INPUT_FILE_KEY in this.sessionState)) {\n      return [];\n    }\n\n    return this.sessionState.get(INPUT_FILE_KEY) as File[];\n  }\n\n  /**\n   * Adds the input files to the session state.\n   * @param inputFiles The input files to add to the session state.\n   */\n  addInputFiles(inputFiles: File[]) {\n    if (!(INPUT_FILE_KEY in this.sessionState)) {\n      this.sessionState.set(INPUT_FILE_KEY, []);\n    }\n\n    (this.sessionState.get(INPUT_FILE_KEY) as File[]).push(...inputFiles);\n  }\n\n  clearInputFiles() {\n    if (INPUT_FILE_KEY in this.sessionState) {\n      this.sessionState.set(INPUT_FILE_KEY, []);\n    }\n\n    if (PROCESSED_FILE_NAMES_KEY in this.context) {\n      this.context[PROCESSED_FILE_NAMES_KEY] = [];\n    }\n  }\n\n  /**\n   * Gets the error count from the session state.\n   * @param invocationId The invocation ID to get the error count for.\n   * @return The error count for the given invocation ID.\n   */\n  getErrorCount(invocationId: string): number {\n    if (!(ERROR_COUNT_KEY in this.sessionState)) {\n      return 0;\n    }\n\n    return (\n      ((this.sessionState.get(ERROR_COUNT_KEY) as Record<string, number>)[\n        invocationId\n      ] as number) || 0\n    );\n  }\n\n  /**\n   * Increments the error count from the session state.\n   * @param invocationId The invocation ID to increment the error count for.\n   */\n  incrementErrorCount(invocationId: string) {\n    if (!(ERROR_COUNT_KEY in this.sessionState)) {\n      this.sessionState.set(ERROR_COUNT_KEY, {});\n    }\n\n    (this.sessionState.get(ERROR_COUNT_KEY) as Record<string, number>)[\n      invocationId\n    ] = this.getErrorCount(invocationId) + 1;\n  }\n\n  /**\n   * Resets the error count from the session state.\n   * @param invocationId The invocation ID to reset the error count for.\n   */\n  resetErrorCount(invocationId: string) {\n    if (!(ERROR_COUNT_KEY in this.sessionState)) {\n      return;\n    }\n\n    const errorCounts = this.sessionState.get(ERROR_COUNT_KEY) as Record<\n      string,\n      number\n    >;\n\n    if (invocationId in errorCounts) {\n      delete errorCounts[invocationId];\n    }\n  }\n\n  /**\n   * Updates the code execution result.\n   * @param invocationId The invocation ID to update the code execution result\n   *     for.\n   * @param code The code to execute.\n   * @param resultStdout The standard output of the code execution.\n   * @param resultStderr The standard error of the code execution.\n   */\n  updateCodeExecutionResult({\n    invocationId,\n    code,\n    resultStdout,\n    resultStderr,\n  }: UpdateCodeExecutionResultParams) {\n    if (!(CODE_EXECUTION_RESULTS_KEY in this.sessionState)) {\n      this.sessionState.set(CODE_EXECUTION_RESULTS_KEY, {});\n    }\n\n    const codeExecutionResults = this.sessionState.get(\n      CODE_EXECUTION_RESULTS_KEY,\n    ) as Record<string, CodeExecutionResult[]>;\n\n    if (!(invocationId in codeExecutionResults)) {\n      codeExecutionResults[invocationId] = [];\n    }\n\n    codeExecutionResults[invocationId].push({\n      code,\n      resultStdout,\n      resultStderr,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Gets the code execution context from the session state.\n   * @return The code execution context for the given invocation ID.\n   */\n  getCodeExecutionContext(): Record<string, unknown> {\n    return this.sessionState.get(CONTEXT_KEY) || {};\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {version} from '../version.js';\n\nimport {isBrowser} from './env_aware_utils.js';\n\nconst ADK_LABEL = 'google-adk';\nconst LANGUAGE_LABEL = 'gl-typescript';\nconst AGENT_ENGINE_TELEMETRY_TAG = 'remote_reasoning_engine';\nconst AGENT_ENGINE_TELEMETRY_ENV_VARIABLE_NAME = 'GOOGLE_CLOUD_AGENT_ENGINE_ID';\n\n// TODO: b/468053794 - Configurable client labels in AsyncLocalStorage and/or\n// browser equivalent\n\nfunction _getDefaultLabels(): string[] {\n  let frameworkLabel = `${ADK_LABEL}/${version}`;\n\n  if (!isBrowser() && process.env[AGENT_ENGINE_TELEMETRY_ENV_VARIABLE_NAME]) {\n    frameworkLabel = `${frameworkLabel}+${AGENT_ENGINE_TELEMETRY_TAG}`;\n  }\n\n  // TODO: b/468051563 - Consider extracting browser name and version from\n  // userAgent string\n  // eslint-disable-next-line no-undef\n  const languageLabel = `${LANGUAGE_LABEL}/${isBrowser() ? window.navigator.userAgent : process.version}`;\n  return [frameworkLabel, languageLabel];\n}\n\n/**\n * Returns the current list of client labels that can be added to HTTP Headers.\n */\nexport function getClientLabels(): string[] {\n  const labels = _getDefaultLabels();\n  // TODO: b/468053794 - Configurable client labels in AsyncLocalStorage and/or\n  // browser equivalent\n  return labels;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {getClientLabels} from '../utils/client_labels.js';\n\nimport {BaseLlmConnection} from './base_llm_connection.js';\nimport {LlmRequest} from './llm_request.js';\nimport {LlmResponse} from './llm_response.js';\n\n/**\n * A unique symbol to identify BaseLlm classes.\n * Defined once and shared by all BaseLlm instances.\n */\nconst BASE_MODEL_SYMBOL = Symbol.for('google.adk.baseModel');\n\n/**\n * Type guard to check if an object is an instance of BaseLlm.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseLlm, false otherwise.\n */\nexport function isBaseLlm(obj: unknown): obj is BaseLlm {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BASE_MODEL_SYMBOL in obj &&\n    obj[BASE_MODEL_SYMBOL] === true\n  );\n}\n\n/**\n * The BaseLLM class.\n */\nexport abstract class BaseLlm {\n  /**\n   * A unique symbol to identify BaseLlm classes.\n   */\n  readonly [BASE_MODEL_SYMBOL] = true;\n\n  readonly model: string;\n\n  /**\n   * Creates an instance of BaseLLM.\n   * @param params The parameters for creating a BaseLlm instance.\n   * @param params.model The name of the LLM, e.g. gemini-1.5-flash or\n   *     gemini-1.5-flash-001.\n   */\n  constructor({model}: {model: string}) {\n    this.model = model;\n  }\n\n  /**\n   * List of supported models in regex for LlmRegistry.\n   */\n  static readonly supportedModels: Array<string | RegExp> = [];\n\n  /**\n   * Generates one content from the given contents and tools.\n   *\n   * @param llmRequest  LlmRequest, the request to send to the LLM.\n   * @param stream whether to do streaming call.\n   * For non-streaming call, it will only yield one Content.\n   * @return A generator of LlmResponse.\n   */\n  abstract generateContentAsync(\n    llmRequest: LlmRequest,\n    stream?: boolean,\n  ): AsyncGenerator<LlmResponse, void>;\n\n  /**\n   * Creates a live connection to the LLM.\n   *\n   * @param llmRequest LlmRequest, the request to send to the LLM.\n   * @return A live connection to the LLM.\n   */\n  abstract connect(llmRequest: LlmRequest): Promise<BaseLlmConnection>;\n\n  protected get trackingHeaders(): Record<string, string> {\n    const labels = getClientLabels();\n    const headerValue = labels.join(' ');\n    return {\n      'x-goog-api-client': headerValue,\n      'user-agent': headerValue,\n    };\n  }\n\n  /**\n   * Appends a user content, so that model can continue to output.\n   *\n   * @param llmRequest LlmRequest, the request to send to the LLM.\n   */\n  maybeAppendUserContent(llmRequest: LlmRequest): void {\n    if (llmRequest.contents.length === 0) {\n      llmRequest.contents.push({\n        role: 'user',\n        parts: [\n          {\n            text: 'Handle the requests as specified in the System Instruction.',\n          },\n        ],\n      });\n    }\n\n    if (llmRequest.contents[llmRequest.contents.length - 1]?.role !== 'user') {\n      llmRequest.contents.push({\n        role: 'user',\n        parts: [\n          {\n            text: 'Continue processing previous requests as instructed. Exit or provide a summary if no more outputs are needed.',\n          },\n        ],\n      });\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Content,\n  FunctionDeclaration,\n  GenerateContentConfig,\n  LiveConnectConfig,\n  SchemaUnion,\n} from '@google/genai';\n\nimport {BaseTool} from '../tools/base_tool.js';\n\n/**\n * LLM request class that allows passing in tools, output schema and system\n * instructions to the model.\n */\nexport interface LlmRequest {\n  /**\n   * The model name.\n   */\n  model?: string;\n\n  /**\n   * The contents to send to the model.\n   */\n  contents: Content[];\n\n  /**\n   * Additional config for the generate content request.\n   * Tools in generateContentConfig should not be set directly; use appendTools.\n   */\n  config?: GenerateContentConfig;\n\n  liveConnectConfig: LiveConnectConfig;\n\n  /**\n   * The tools dictionary. Excluded from JSON serialization.\n   */\n  toolsDict: {[key: string]: BaseTool};\n}\n\n/**\n * Appends instructions to the system instruction.\n * @param instructions The instructions to append.\n */\nexport function appendInstructions(\n  llmRequest: LlmRequest,\n  instructions: string[],\n): void {\n  if (!llmRequest.config) {\n    llmRequest.config = {};\n  }\n  const newInstructions = instructions.join('\\n\\n');\n  if (llmRequest.config.systemInstruction) {\n    llmRequest.config.systemInstruction += '\\n\\n' + newInstructions;\n  } else {\n    llmRequest.config.systemInstruction = newInstructions;\n  }\n}\n\n/**\n * Appends tools to the request.\n * @param tools The tools to append.\n */\nexport function appendTools(llmRequest: LlmRequest, tools: BaseTool[]): void {\n  if (!tools?.length) {\n    return;\n  }\n\n  const functionDeclarations: FunctionDeclaration[] = [];\n  for (const tool of tools) {\n    const declaration = tool._getDeclaration();\n    if (declaration) {\n      functionDeclarations.push(declaration);\n      llmRequest.toolsDict[tool.name] = tool;\n    }\n  }\n\n  if (functionDeclarations.length) {\n    if (!llmRequest.config) {\n      llmRequest.config = {};\n    }\n    if (!llmRequest.config.tools) {\n      llmRequest.config.tools = [];\n    }\n    llmRequest.config.tools.push({functionDeclarations});\n  }\n}\n\n/**\n * Sets the output schema for the request.\n *\n * @param schema The JSON Schema object to set as the output schema.\n */\nexport function setOutputSchema(\n  llmRequest: LlmRequest,\n  schema: SchemaUnion,\n): void {\n  if (!llmRequest.config) {\n    llmRequest.config = {};\n  }\n  llmRequest.config.responseSchema = schema;\n  llmRequest.config.responseMimeType = 'application/json';\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Blob,\n  createPartFromText,\n  FileData,\n  FinishReason,\n  GenerateContentResponse,\n  GoogleGenAI,\n  Part,\n} from '@google/genai';\n\nimport {logger} from '../utils/logger.js';\nimport {GoogleLLMVariant} from '../utils/variant_utils.js';\n\nimport {BaseLlm} from './base_llm.js';\nimport {BaseLlmConnection} from './base_llm_connection.js';\nimport {GeminiLlmConnection} from './gemini_llm_connection.js';\nimport {LlmRequest} from './llm_request.js';\nimport {createLlmResponse, LlmResponse} from './llm_response.js';\n\n/**\n * The parameters for creating a Gemini instance.\n */\nexport interface GeminiParams {\n  /**\n   * The name of the model to use. Defaults to 'gemini-2.5-flash'.\n   */\n  model?: string;\n  /**\n   * The API key to use for the Gemini API. If not provided, it will look for\n   * the GOOGLE_GENAI_API_KEY or GEMINI_API_KEY environment variable.\n   */\n  apiKey?: string;\n  /**\n   * Whether to use Vertex AI. If true, `project`, `location`\n   * should be provided.\n   */\n  vertexai?: boolean;\n  /**\n   * The Vertex AI project ID. Required if `vertexai` is true.\n   */\n  project?: string;\n  /**\n   * The Vertex AI location. Required if `vertexai` is true.\n   */\n  location?: string;\n  /**\n   * Headers to merge with internally crafted headers.\n   */\n  headers?: Record<string, string>;\n}\n\n/**\n * Integration for Gemini models.\n */\nexport class Gemini extends BaseLlm {\n  private readonly apiKey?: string;\n  private readonly vertexai: boolean;\n  private readonly project?: string;\n  private readonly location?: string;\n  private readonly headers?: Record<string, string>;\n\n  /**\n   * @param params The parameters for creating a Gemini instance.\n   */\n  constructor({\n    model,\n    apiKey,\n    vertexai,\n    project,\n    location,\n    headers,\n  }: GeminiParams) {\n    if (!model) {\n      model = 'gemini-2.5-flash';\n    }\n\n    super({model});\n\n    this.project = project;\n    this.location = location;\n    this.apiKey = apiKey;\n    this.headers = headers;\n\n    const canReadEnv = typeof process === 'object';\n\n    this.vertexai = !!vertexai;\n    if (!this.vertexai && canReadEnv) {\n      const vertexAIfromEnv = process.env['GOOGLE_GENAI_USE_VERTEXAI'];\n      if (vertexAIfromEnv) {\n        this.vertexai =\n          vertexAIfromEnv.toLowerCase() === 'true' || vertexAIfromEnv === '1';\n      }\n    }\n\n    if (this.vertexai) {\n      if (canReadEnv && !this.project) {\n        this.project = process.env['GOOGLE_CLOUD_PROJECT'];\n      }\n      if (canReadEnv && !this.location) {\n        this.location = process.env['GOOGLE_CLOUD_LOCATION'];\n      }\n      if (!this.project) {\n        throw new Error(\n          'VertexAI project must be provided via constructor or GOOGLE_CLOUD_PROJECT environment variable.',\n        );\n      }\n      if (!this.location) {\n        throw new Error(\n          'VertexAI location must be provided via constructor or GOOGLE_CLOUD_LOCATION environment variable.',\n        );\n      }\n    } else {\n      if (!this.apiKey && canReadEnv) {\n        this.apiKey =\n          process.env['GOOGLE_GENAI_API_KEY'] || process.env['GEMINI_API_KEY'];\n      }\n      if (!this.apiKey) {\n        throw new Error(\n          'API key must be provided via constructor or GOOGLE_GENAI_API_KEY or GEMINI_API_KEY environment variable.',\n        );\n      }\n    }\n  }\n\n  /**\n   * A list of model name patterns that are supported by this LLM.\n   *\n   * @returns A list of supported models.\n   */\n  static override readonly supportedModels: Array<string | RegExp> = [\n    /gemini-.*/,\n    // fine-tuned vertex endpoint pattern\n    /projects\\/.+\\/locations\\/.+\\/endpoints\\/.+/,\n    // vertex gemini long name\n    /projects\\/.+\\/locations\\/.+\\/publishers\\/google\\/models\\/gemini.+/,\n  ];\n\n  private _apiClient?: GoogleGenAI;\n  private _apiBackend?: GoogleLLMVariant;\n  private _trackingHeaders?: Record<string, string>;\n  private _liveApiVersion?: string;\n  private _liveApiClient?: GoogleGenAI;\n\n  /**\n   * Sends a request to the Gemini model.\n   *\n   * @param llmRequest LlmRequest, the request to send to the Gemini model.\n   * @param stream bool = false, whether to do streaming call.\n   * @yields LlmResponse: The model response.\n   */\n  override async *generateContentAsync(\n    llmRequest: LlmRequest,\n    stream = false,\n  ): AsyncGenerator<LlmResponse, void> {\n    this.preprocessRequest(llmRequest);\n    this.maybeAppendUserContent(llmRequest);\n    logger.info(\n      `Sending out request, model: ${llmRequest.model}, backend: ${this.apiBackend}, stream: ${stream}`,\n    );\n\n    if (llmRequest.config?.httpOptions) {\n      llmRequest.config.httpOptions.headers = {\n        ...llmRequest.config.httpOptions.headers,\n        ...this.trackingHeaders,\n      };\n    }\n\n    if (stream) {\n      const streamResult = await this.apiClient.models.generateContentStream({\n        model: llmRequest.model ?? this.model,\n        contents: llmRequest.contents,\n        config: llmRequest.config,\n      });\n      let thoughtText = '';\n      let text = '';\n      let usageMetadata;\n      let lastResponse: GenerateContentResponse | undefined;\n\n      // TODO - b/425992518: verify the type of streaming response is correct.\n      for await (const response of streamResult) {\n        lastResponse = response;\n        const llmResponse = createLlmResponse(response);\n        usageMetadata = llmResponse.usageMetadata;\n        const firstPart = llmResponse.content?.parts?.[0];\n        // Accumulates the text and thought text from the first part.\n        if (firstPart?.text) {\n          if ('thought' in firstPart && firstPart.thought) {\n            thoughtText += firstPart.text;\n          } else {\n            text += firstPart.text;\n          }\n          llmResponse.partial = true;\n        } else if (\n          (thoughtText || text) &&\n          (!firstPart || !firstPart.inlineData)\n        ) {\n          // Flushes the data if there's no more text.\n          const parts: Part[] = [];\n          if (thoughtText) {\n            parts.push({text: thoughtText, thought: true});\n          }\n          if (text) {\n            parts.push(createPartFromText(text));\n          }\n          yield {\n            content: {\n              role: 'model',\n              parts,\n            },\n            usageMetadata: llmResponse.usageMetadata,\n          };\n          thoughtText = '';\n          text = '';\n        }\n        yield llmResponse;\n      }\n      if (\n        (text || thoughtText) &&\n        lastResponse?.candidates?.[0]?.finishReason === FinishReason.STOP\n      ) {\n        const parts: Part[] = [];\n        if (thoughtText) {\n          parts.push({text: thoughtText, thought: true} as Part);\n        }\n        if (text) {\n          parts.push({text: text});\n        }\n        yield {\n          content: {\n            role: 'model',\n            parts,\n          },\n          usageMetadata,\n        };\n      }\n    } else {\n      const response = await this.apiClient.models.generateContent({\n        model: llmRequest.model ?? this.model,\n        contents: llmRequest.contents,\n        config: llmRequest.config,\n      });\n      yield createLlmResponse(response);\n    }\n  }\n\n  get apiClient(): GoogleGenAI {\n    if (this._apiClient) {\n      return this._apiClient;\n    }\n\n    const combinedHeaders = {\n      ...this.trackingHeaders,\n      ...this.headers,\n    };\n\n    if (this.vertexai) {\n      this._apiClient = new GoogleGenAI({\n        vertexai: this.vertexai,\n        project: this.project,\n        location: this.location,\n        httpOptions: {headers: combinedHeaders},\n      });\n    } else {\n      this._apiClient = new GoogleGenAI({\n        apiKey: this.apiKey,\n        httpOptions: {headers: combinedHeaders},\n      });\n    }\n    return this._apiClient;\n  }\n\n  get apiBackend(): GoogleLLMVariant {\n    if (!this._apiBackend) {\n      this._apiBackend = this.apiClient.vertexai\n        ? GoogleLLMVariant.VERTEX_AI\n        : GoogleLLMVariant.GEMINI_API;\n    }\n    return this._apiBackend;\n  }\n\n  get liveApiVersion(): string {\n    if (!this._liveApiVersion) {\n      this._liveApiVersion =\n        this.apiBackend === GoogleLLMVariant.VERTEX_AI ? 'v1beta1' : 'v1alpha';\n    }\n    return this._liveApiVersion;\n  }\n\n  get liveApiClient(): GoogleGenAI {\n    if (!this._liveApiClient) {\n      this._liveApiClient = new GoogleGenAI({\n        apiKey: this.apiKey,\n        httpOptions: {\n          headers: this.trackingHeaders,\n          apiVersion: this.liveApiVersion,\n        },\n      });\n    }\n    return this._liveApiClient;\n  }\n\n  /**\n   * Connects to the Gemini model and returns an llm connection.\n   *\n   * @param llmRequest LlmRequest, the request to send to the Gemini model.\n   * @returns BaseLlmConnection, the connection to the Gemini model.\n   */\n  override async connect(llmRequest: LlmRequest): Promise<BaseLlmConnection> {\n    // add tracking headers to custom headers and set api_version given\n    // the customized http options will override the one set in the api client\n    // constructor\n    if (llmRequest.liveConnectConfig?.httpOptions) {\n      if (!llmRequest.liveConnectConfig.httpOptions.headers) {\n        llmRequest.liveConnectConfig.httpOptions.headers = {};\n      }\n      Object.assign(\n        llmRequest.liveConnectConfig.httpOptions.headers,\n        this.trackingHeaders,\n      );\n      llmRequest.liveConnectConfig.httpOptions.apiVersion = this.liveApiVersion;\n    }\n\n    if (llmRequest.config?.systemInstruction) {\n      llmRequest.liveConnectConfig.systemInstruction = {\n        role: 'system',\n        // TODO - b/425992518: validate type casting works well.\n        parts: [\n          createPartFromText(llmRequest.config.systemInstruction as string),\n        ],\n      };\n    }\n\n    llmRequest.liveConnectConfig.tools = llmRequest.config?.tools;\n\n    const liveSession = await this.liveApiClient.live.connect({\n      model: llmRequest.model ?? this.model,\n      config: llmRequest.liveConnectConfig,\n      callbacks: {\n        // TODO - b/425992518: GenAI SDK inconsistent API, missing methods.\n        onmessage: () => {},\n      },\n    });\n    return new GeminiLlmConnection(liveSession);\n  }\n\n  private preprocessRequest(llmRequest: LlmRequest): void {\n    if (this.apiBackend === GoogleLLMVariant.GEMINI_API) {\n      if (llmRequest.config) {\n        // Using API key from Google AI Studio to call model doesn't support\n        // labels.\n        (llmRequest.config as {labels?: unknown}).labels = undefined;\n      }\n      if (llmRequest.contents) {\n        for (const content of llmRequest.contents) {\n          if (!content.parts) continue;\n          for (const part of content.parts) {\n            removeDisplayNameIfPresent(part.inlineData);\n            removeDisplayNameIfPresent(part.fileData);\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction removeDisplayNameIfPresent(\n  dataObj: Blob | FileData | undefined,\n): void {\n  // display_name is not supported for Gemini API (non-vertex)\n  if (dataObj && (dataObj as FileData).displayName) {\n    (dataObj as FileData).displayName = undefined;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * The Google LLM variant to use.\n * see\n * https://google.github.io/adk-docs/get-started/quickstart/#set-up-the-model\n */\nexport enum GoogleLLMVariant {\n  /**\n   * For using credentials from Google Vertex AI\n   */\n  VERTEX_AI = 'VERTEX_AI',\n\n  /**\n   * For using API Key from Google AI Studio\n   */\n  GEMINI_API = 'GEMINI_API',\n}\n\n/**\n * Gets the Google LLM variant to use.\n */\nexport function getGoogleLlmVariant() {\n  return getBooleanEnvVar('GOOGLE_GENAI_USE_VERTEXAI')\n    ? GoogleLLMVariant.VERTEX_AI\n    : GoogleLLMVariant.GEMINI_API;\n}\n\n/**\n * Gets the boolean value of the given environment variable.\n *\n * @param envVar The environment variable to get the value of.\n * @return The boolean value of the environment variable.\n */\nfunction getBooleanEnvVar(envVar: string): boolean {\n  if (!process.env) {\n    return false;\n  }\n\n  const envVarValue = (process.env[envVar] || '').toLowerCase();\n\n  return ['true', '1'].includes(envVarValue);\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Blob, Content, FunctionResponse, Session} from '@google/genai';\n\nimport {logger} from '../utils/logger.js';\n\nimport {BaseLlmConnection} from './base_llm_connection.js';\nimport {LlmResponse} from './llm_response.js';\n\n/** The Gemini model connection. */\nexport class GeminiLlmConnection implements BaseLlmConnection {\n  constructor(private readonly geminiSession: Session) {}\n\n  /**\n   * Sends the conversation history to the gemini model.\n   *\n   * You call this method right after setting up the model connection.\n   * The model will respond if the last content is from user, otherwise it will\n   * wait for new user input before responding.\n   *\n   * @param history The conversation history to send to the model.\n   */\n  async sendHistory(history: Content[]): Promise<void> {\n    // We ignore any audio from user during the agent transfer phase.\n    const contents = history.filter(\n      (content) => content.parts && content.parts[0]?.text,\n    );\n\n    if (contents.length > 0) {\n      this.geminiSession.sendClientContent({\n        turns: contents,\n        turnComplete: contents[contents.length - 1].role === 'user',\n      });\n    } else {\n      logger.info('no content is sent');\n    }\n  }\n\n  /**\n   * Sends a user content to the gemini model.\n   *\n   * The model will respond immediately upon receiving the content.\n   * If you send function responses, all parts in the content should be function\n   * responses.\n   *\n   * @param content The content to send to the model.\n   */\n  async sendContent(content: Content): Promise<void> {\n    if (!content.parts) {\n      throw new Error('Content must have parts.');\n    }\n    if (content.parts[0].functionResponse) {\n      // All parts have to be function responses.\n      const functionResponses = content.parts\n        .map((part) => part.functionResponse)\n        .filter((fr): fr is FunctionResponse => !!fr);\n      logger.debug('Sending LLM function response:', functionResponses);\n      this.geminiSession.sendToolResponse({\n        functionResponses,\n      });\n    } else {\n      logger.debug('Sending LLM new content', content);\n      this.geminiSession.sendClientContent({\n        turns: [content],\n        turnComplete: true,\n      });\n    }\n  }\n\n  /**\n   * Sends a chunk of audio or a frame of video to the model in realtime.\n   *\n   * @param blob The blob to send to the model.\n   */\n  async sendRealtime(blob: Blob): Promise<void> {\n    logger.debug('Sending LLM Blob:', blob);\n    this.geminiSession.sendRealtimeInput({media: blob});\n  }\n\n  /**\n   * Builds a full text response.\n   *\n   * The text should not be partial and the returned LlmResponse is not be\n   * partial.\n   *\n   * @param text The text to be included in the response.\n   * @returns An LlmResponse containing the full text.\n   */\n  private buildFullTextResponse(text: string): LlmResponse {\n    return {\n      content: {\n        role: 'model',\n        parts: [{text}],\n      },\n    };\n  }\n\n  // TODO(b/425992518): GenAI SDK inconsistent API, missing methods.\n  // eslint-disable-next-line require-yield\n  async *receive(): AsyncGenerator<LlmResponse, void, void> {\n    throw new Error('Not Implemented.');\n  }\n\n  /**\n   * Closes the llm server connection.\n   */\n  async close(): Promise<void> {\n    this.geminiSession.close();\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Content,\n  FinishReason,\n  GenerateContentResponse,\n  GenerateContentResponseUsageMetadata,\n  GroundingMetadata,\n  LiveServerSessionResumptionUpdate,\n  Transcription,\n} from '@google/genai';\n\n/**\n * LLM response class that provides the first candidate response from the\n * model if available. Otherwise, returns error code and message.\n */\nexport interface LlmResponse {\n  /**\n   * The content of the response.\n   */\n  content?: Content;\n\n  /**\n   * The grounding metadata of the response.\n   */\n  groundingMetadata?: GroundingMetadata;\n\n  /**\n   * Indicates whether the text content is part of a unfinished text stream.\n   * Only used for streaming mode and when the content is plain text.\n   */\n  partial?: boolean;\n\n  /**\n   * Indicates whether the response from the model is complete.\n   * Only used for streaming mode.\n   */\n  turnComplete?: boolean;\n\n  /**\n   * Error code if the response is an error. Code varies by model.\n   */\n  errorCode?: string;\n\n  /**\n   * Error message if the response is an error.\n   */\n  errorMessage?: string;\n\n  /**\n   * Flag indicating that LLM was interrupted when generating the content.\n   * Usually it's due to user interruption during a bidi streaming.\n   */\n  interrupted?: boolean;\n\n  /**\n   * The custom metadata of the LlmResponse.\n   * An optional key-value pair to label an LlmResponse.\n   * NOTE: the entire object must be JSON serializable.\n   */\n  customMetadata?: {[key: string]: unknown};\n\n  /**\n   * The usage metadata of the LlmResponse.\n   */\n  usageMetadata?: GenerateContentResponseUsageMetadata;\n\n  /**\n   * The finish reason of the response.\n   */\n  finishReason?: FinishReason;\n\n  /**\n   * The session resumption update of the LlmResponse\n   */\n  liveSessionResumptionUpdate?: LiveServerSessionResumptionUpdate;\n\n  /**\n   * Audio transcription of user input.\n   */\n  inputTranscription?: Transcription;\n\n  /**\n   * Audio transcription of model output.\n   */\n  outputTranscription?: Transcription;\n}\n\n/**\n * Creates an LlmResponse from a GenerateContentResponse.\n *\n * @param response The GenerateContentResponse to create the\n *   LlmResponse from.\n * @returns The LlmResponse.\n */\nexport function createLlmResponse(\n  response: GenerateContentResponse,\n): LlmResponse {\n  const usageMetadata = response.usageMetadata;\n\n  if (response.candidates && response.candidates.length > 0) {\n    const candidate = response.candidates[0];\n    if (candidate.content?.parts && candidate.content.parts.length > 0) {\n      return {\n        content: candidate.content,\n        groundingMetadata: candidate.groundingMetadata,\n        usageMetadata: usageMetadata,\n        finishReason: candidate.finishReason,\n      };\n    }\n\n    return {\n      errorCode: candidate.finishReason,\n      errorMessage: candidate.finishMessage,\n      usageMetadata: usageMetadata,\n      finishReason: candidate.finishReason,\n    };\n  }\n\n  if (response.promptFeedback) {\n    return {\n      errorCode: response.promptFeedback.blockReason,\n      errorMessage: response.promptFeedback.blockReasonMessage,\n      usageMetadata: usageMetadata,\n    };\n  }\n\n  // The ultimate fallback for an unknown error state\n  return {\n    errorCode: 'UNKNOWN_ERROR',\n    errorMessage: 'Unknown error.',\n    usageMetadata: usageMetadata,\n  };\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {logger} from '../utils/logger.js';\n\nimport {BaseLlm} from './base_llm.js';\nimport {Gemini} from './google_llm.js';\n\n/**\n * type[BaseLlm] equivalent in TypeScript, represents a class that can be new-ed\n * to create a BaseLlm instance.\n */\nexport type BaseLlmType = (new (params: {model: string}) => BaseLlm) & {\n  readonly supportedModels: Array<string | RegExp>;\n};\n\n/**\n * A simple LRU cache.\n */\n// TODO - b/425992518: consider remove this. model resolution is not frequent.\nclass LRUCache<K, V> {\n  private readonly maxSize: number;\n  private cache: Map<K, V>;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n    this.cache = new Map<K, V>();\n  }\n\n  get(key: K): V | undefined {\n    const item = this.cache.get(key);\n    if (item) {\n      // Map maintians insertion order.\n      this.cache.delete(key);\n      this.cache.set(key, item);\n    }\n    return item;\n  }\n\n  set(key: K, value: V): void {\n    if (this.cache.size >= this.maxSize && !this.cache.has(key)) {\n      const lruKey = this.cache.keys().next().value;\n      if (lruKey !== undefined) {\n        this.cache.delete(lruKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n}\n\n/**\n * Registry for LLMs.\n */\nexport class LLMRegistry {\n  /**\n   * Key is the regex that matches the model name.\n   * Value is the class that implements the model.\n   */\n  private static llmRegistryDict: Map<string | RegExp, BaseLlmType> = new Map();\n  private static resolveCache = new LRUCache<string, BaseLlmType>(32);\n\n  /**\n   * Creates a new LLM instance.\n   * @param model The model name.\n   * @returns The LLM instance.\n   */\n  static newLlm(model: string): BaseLlm {\n    return new (LLMRegistry.resolve(model))({model});\n  }\n\n  private static _register(\n    modelNameRegex: string | RegExp,\n    llmCls: BaseLlmType,\n  ) {\n    if (LLMRegistry.llmRegistryDict.has(modelNameRegex)) {\n      logger.info(\n        `Updating LLM class for ${modelNameRegex} from ${LLMRegistry.llmRegistryDict.get(modelNameRegex)} to ${llmCls}`,\n      );\n    }\n    LLMRegistry.llmRegistryDict.set(modelNameRegex, llmCls);\n  }\n\n  /**\n   * Registers a new LLM class.\n   * @param llmCls The class that implements the model.\n   */\n  static register<T extends BaseLlm>(\n    llmCls: (new (params: {model: string}) => T) & {\n      readonly supportedModels: Array<string | RegExp>;\n    },\n  ) {\n    for (const regex of llmCls.supportedModels) {\n      LLMRegistry._register(regex, llmCls);\n    }\n  }\n\n  /**\n   * Resolves the model to a BaseLlm subclass.\n   * @param model The model name.\n   * @returns The BaseLlm subclass.\n   * @throws If the model is not found.\n   */\n  static resolve(model: string): BaseLlmType {\n    const cachedLlm = LLMRegistry.resolveCache.get(model);\n    if (cachedLlm) {\n      return cachedLlm;\n    }\n\n    for (const [regex, llmClass] of LLMRegistry.llmRegistryDict.entries()) {\n      // Replicates Python's `re.fullmatch` by anchoring the regex\n      // to the start (^) and end ($) of the string.\n      // TODO - b/425992518: validate it works well.\n      const pattern = new RegExp(\n        `^${regex instanceof RegExp ? regex.source : regex}$`,\n        regex instanceof RegExp ? regex.flags : undefined,\n      );\n      if (pattern.test(model)) {\n        LLMRegistry.resolveCache.set(model, llmClass);\n        return llmClass;\n      }\n    }\n\n    throw new Error(`Model ${model} not found.`);\n  }\n}\n\n/** Registers default LLM factories, e.g. for Gemini models. */\nLLMRegistry.register(Gemini);\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {FunctionDeclaration, Tool} from '@google/genai';\n\nimport {LlmRequest} from '../models/llm_request.js';\nimport {getGoogleLlmVariant} from '../utils/variant_utils.js';\n\nimport {ToolContext} from './tool_context.js';\n\n/**\n * The parameters for `runAsync`.\n */\nexport interface RunAsyncToolRequest {\n  args: Record<string, unknown>;\n  toolContext: ToolContext;\n}\n\n/**\n * The parameters for `processLlmRequest`.\n */\nexport interface ToolProcessLlmRequest {\n  toolContext: ToolContext;\n  llmRequest: LlmRequest;\n}\n\n/**\n * Parameters for the BaseTool constructor.\n */\nexport interface BaseToolParams {\n  name: string;\n  description: string;\n  isLongRunning?: boolean;\n}\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all BaseTool instances.\n */\nconst BASE_TOOL_SIGNATURE_SYMBOL = Symbol.for('google.adk.baseTool');\n\n/**\n * Type guard to check if an object is an instance of BaseTool.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseTool, false otherwise.\n */\nexport function isBaseTool(obj: unknown): obj is BaseTool {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BASE_TOOL_SIGNATURE_SYMBOL in obj &&\n    obj[BASE_TOOL_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * The base class for all tools.\n */\nexport abstract class BaseTool {\n  /** A unique symbol to identify ADK base tool class. */\n  readonly [BASE_TOOL_SIGNATURE_SYMBOL] = true;\n\n  readonly name: string;\n  readonly description: string;\n  readonly isLongRunning: boolean;\n\n  /**\n   * Base constructor for a tool.\n   *\n   * @param params The parameters for `BaseTool`.\n   */\n  constructor(params: BaseToolParams) {\n    this.name = params.name;\n    this.description = params.description;\n    this.isLongRunning = params.isLongRunning ?? false;\n  }\n\n  /**\n   * Gets the OpenAPI specification of this tool in the form of a\n   * FunctionDeclaration.\n   *\n   * NOTE\n   * - Required if subclass uses the default implementation of\n   *   `processLlmRequest` to add function declaration to LLM request.\n   * - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n   *   Gemini.\n   *\n   * @return The FunctionDeclaration of this tool, or undefined if it doesn't\n   *     need to be added to LlmRequest.config.\n   */\n  _getDeclaration(): FunctionDeclaration | undefined {\n    return undefined;\n  }\n\n  /**\n   * Runs the tool with the given arguments and context.\n   *\n   * NOTE\n   * - Required if this tool needs to run at the client side.\n   * - Otherwise, can be skipped, e.g. for a built-in GoogleSearch tool for\n   *   Gemini.\n   *\n   * @param request The request to run the tool.\n   * @return A promise that resolves to the tool response.\n   */\n  abstract runAsync(request: RunAsyncToolRequest): Promise<unknown>;\n\n  /**\n   * Processes the outgoing LLM request for this tool.\n   *\n   * Use cases:\n   * - Most common use case is adding this tool to the LLM request.\n   * - Some tools may just preprocess the LLM request before it's sent out.\n   *\n   * @param request The request to process the LLM request.\n   */\n  async processLlmRequest({llmRequest}: ToolProcessLlmRequest): Promise<void> {\n    const functionDeclaration = this._getDeclaration();\n    if (!functionDeclaration) {\n      return;\n    }\n\n    llmRequest.toolsDict[this.name] = this;\n\n    const tool = findToolWithFunctionDeclarations(llmRequest);\n    if (tool) {\n      if (!tool.functionDeclarations) {\n        tool.functionDeclarations = [];\n      }\n\n      tool.functionDeclarations.push(functionDeclaration);\n    } else {\n      llmRequest.config = llmRequest.config || {};\n      llmRequest.config.tools = llmRequest.config.tools || [];\n      llmRequest.config.tools.push({\n        functionDeclarations: [functionDeclaration],\n      });\n    }\n  }\n\n  /**\n   * The Google API LLM variant to use.\n   */\n  get apiVariant() {\n    return getGoogleLlmVariant();\n  }\n}\n\nfunction findToolWithFunctionDeclarations(\n  llmRequest: LlmRequest,\n): Tool | undefined {\n  return (llmRequest.config?.tools || []).find(\n    (tool) => 'functionDeclarations' in tool,\n  ) as Tool | undefined;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {FunctionDeclaration, Schema, Type} from '@google/genai';\nimport {z as z3} from 'zod/v3';\nimport {z as z4} from 'zod/v4';\n\nimport {isZodObject, zodObjectToSchema} from '../utils/simple_zod_to_json.js';\n\nimport {BaseTool, RunAsyncToolRequest} from './base_tool.js';\nimport {ToolContext} from './tool_context.js';\n\n/**\n * Input parameters of the function tool.\n */\nexport type ToolInputParameters =\n  | z3.ZodObject<z3.ZodRawShape>\n  | z4.ZodObject<z4.ZodRawShape>\n  | Schema\n  | undefined;\n\n/*\n * The arguments of the function tool.\n */\nexport type ToolExecuteArgument<TParameters extends ToolInputParameters> =\n  TParameters extends z3.ZodObject<infer T, infer U, infer V>\n    ? z3.infer<z3.ZodObject<T, U, V>>\n    : TParameters extends z4.ZodObject<infer T>\n      ? z4.infer<z4.ZodObject<T>>\n      : TParameters extends Schema\n        ? unknown\n        : string;\n\n/*\n * The function to execute by the tool.\n */\nexport type ToolExecuteFunction<TParameters extends ToolInputParameters> = (\n  input: ToolExecuteArgument<TParameters>,\n  tool_context?: ToolContext,\n) => Promise<unknown> | unknown;\n\n/**\n * The configuration options for creating a function-based tool.\n * The `name`, `description` and `parameters` fields are used to generate the\n * tool definition that is passed to the LLM prompt.\n *\n * Note: Unlike Python's ADK, JSDoc on the `execute` function is ignored\n * for tool definition generation.\n */\nexport type ToolOptions<TParameters extends ToolInputParameters> = {\n  name?: string;\n  description: string;\n  parameters?: TParameters;\n  execute: ToolExecuteFunction<TParameters>;\n  isLongRunning?: boolean;\n};\n\nfunction toSchema<TParameters extends ToolInputParameters>(\n  parameters: TParameters,\n): Schema {\n  if (parameters === undefined) {\n    return {type: Type.OBJECT, properties: {}};\n  }\n\n  if (isZodObject(parameters)) {\n    return zodObjectToSchema(parameters);\n  }\n\n  return parameters;\n}\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all BaseTool instances.\n */\nconst FUNCTION_TOOL_SIGNATURE_SYMBOL = Symbol.for('google.adk.functionTool');\n\n/**\n * Type guard to check if an object is an instance of BaseTool.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseTool, false otherwise.\n */\nexport function isFunctionTool(obj: unknown): obj is FunctionTool {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    FUNCTION_TOOL_SIGNATURE_SYMBOL in obj &&\n    obj[FUNCTION_TOOL_SIGNATURE_SYMBOL] === true\n  );\n}\n\nexport class FunctionTool<\n  TParameters extends ToolInputParameters = undefined,\n> extends BaseTool {\n  /** A unique symbol to identify ADK function tool class. */\n  readonly [FUNCTION_TOOL_SIGNATURE_SYMBOL] = true;\n\n  // User defined function.\n  private readonly execute: ToolExecuteFunction<TParameters>;\n  // Typed input parameters.\n  private readonly parameters?: TParameters;\n\n  /**\n   * The constructor acts as the user-friendly factory.\n   * @param options The configuration for the tool.\n   */\n  constructor(options: ToolOptions<TParameters>) {\n    const name = options.name ?? (options.execute as {name?: string}).name;\n    if (!name) {\n      throw new Error(\n        'Tool name cannot be empty. Either name the `execute` function or provide a `name`.',\n      );\n    }\n    super({\n      name,\n      description: options.description,\n      isLongRunning: options.isLongRunning,\n    });\n    this.execute = options.execute;\n    this.parameters = options.parameters;\n  }\n\n  /**\n   * Provide a schema for the function.\n   */\n  override _getDeclaration(): FunctionDeclaration {\n    return {\n      name: this.name,\n      description: this.description,\n      parameters: toSchema(this.parameters),\n    };\n  }\n\n  /**\n   * Logic for running the tool.\n   */\n  override async runAsync(req: RunAsyncToolRequest): Promise<unknown> {\n    try {\n      let validatedArgs: unknown = req.args;\n      if (isZodObject(this.parameters)) {\n        validatedArgs = this.parameters.parse(req.args);\n      }\n      return await this.execute(\n        validatedArgs as ToolExecuteArgument<TParameters>,\n        req.toolContext,\n      );\n    } catch (error) {\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n      throw new Error(`Error in tool '${this.name}': ${errorMessage}`);\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Schema, Type} from '@google/genai';\nimport {\n  JsonSchema7ArrayType,\n  JsonSchema7BigintType,\n  JsonSchema7EnumType,\n  JsonSchema7NumberType,\n  JsonSchema7ObjectType,\n  JsonSchema7StringType,\n  zodToJsonSchema as toJSONSchemaV3,\n} from 'zod-to-json-schema';\nimport {z as z3} from 'zod/v3';\nimport {toJSONSchema as toJSONSchemaV4, z as z4} from 'zod/v4';\n\ntype ZodSchema<T = unknown> = z3.ZodType<T> | z4.ZodType<T>;\n\nfunction isZodSchema(obj: unknown): obj is ZodSchema {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    'parse' in obj &&\n    typeof (obj as {parse: unknown}).parse === 'function' &&\n    'safeParse' in obj &&\n    typeof (obj as {safeParse: unknown}).safeParse === 'function'\n  );\n}\n\nfunction isZodV3Schema(obj: unknown): obj is z3.ZodTypeAny {\n  return isZodSchema(obj) && !('_zod' in obj);\n}\n\nfunction isZodV4Schema(obj: unknown): obj is z4.ZodType {\n  return isZodSchema(obj) && '_zod' in obj;\n}\n\nfunction getZodTypeName(\n  schema: z3.ZodTypeAny | z4.ZodType,\n): string | undefined {\n  const schemaAny = schema as {_def: z3.ZodTypeDef | z4.ZodType};\n\n  if ((schemaAny._def as z3.ZodStringDef)?.typeName) {\n    return (schemaAny._def as z3.ZodStringDef).typeName;\n  }\n\n  const zod4Type = (schemaAny._def as z4.ZodType)?.type;\n  if (typeof zod4Type === 'string' && zod4Type) {\n    return 'Zod' + zod4Type.charAt(0).toUpperCase() + zod4Type.slice(1);\n  }\n\n  return undefined;\n}\n\n/**\n * Returns true if the given object is a ZodObject (supports both Zod v3 and v4).\n */\nexport function isZodObject(\n  obj: unknown,\n): obj is z3.ZodObject<z3.ZodRawShape> | z4.ZodObject<z4.ZodRawShape> {\n  return isZodSchema(obj) && getZodTypeName(obj) === 'ZodObject';\n}\n\nexport function zodObjectToSchema(\n  schema: z3.ZodObject<z3.ZodRawShape> | z4.ZodObject<z4.ZodRawShape>,\n): Schema {\n  if (!isZodObject(schema)) {\n    throw new Error('Expected a Zod Object');\n  }\n\n  if (isZodV4Schema(schema)) {\n    return toJSONSchemaV4(schema, {\n      target: 'openapi-3.0',\n      io: 'input',\n      override: (ctx) => {\n        const {jsonSchema} = ctx;\n\n        if (jsonSchema.additionalProperties !== undefined) {\n          delete jsonSchema.additionalProperties;\n        }\n\n        if (jsonSchema.readOnly !== undefined) {\n          delete jsonSchema.readOnly;\n        }\n\n        if (jsonSchema.maxItems !== undefined) {\n          (jsonSchema as Schema).maxItems = jsonSchema.maxItems.toString();\n        }\n\n        if (jsonSchema.format === 'email' || jsonSchema.format === 'uuid') {\n          delete jsonSchema.pattern;\n        }\n\n        if (jsonSchema.minItems !== undefined) {\n          (jsonSchema as Schema).minItems = jsonSchema.minItems.toString();\n        }\n\n        if (jsonSchema.minLength !== undefined) {\n          (jsonSchema as Schema).minLength = jsonSchema.minLength.toString();\n        }\n\n        if (jsonSchema.maxLength !== undefined) {\n          (jsonSchema as Schema).maxLength = jsonSchema.maxLength.toString();\n        }\n\n        if (jsonSchema.enum?.length === 1 && jsonSchema.enum[0] === null) {\n          (jsonSchema as Schema).type = Type.NULL;\n          delete jsonSchema.enum;\n        }\n\n        if (jsonSchema.type !== undefined) {\n          (jsonSchema as {type: string}).type = (\n            jsonSchema as {type: string}\n          ).type.toUpperCase();\n        }\n      },\n    }) as Schema;\n  }\n\n  if (isZodV3Schema(schema)) {\n    return toJSONSchemaV3(schema, {\n      target: 'openApi3',\n      emailStrategy: 'format:email',\n      postProcess: (jsonSchema) => {\n        if (!jsonSchema) {\n          return;\n        }\n\n        if (\n          (jsonSchema as JsonSchema7ObjectType).additionalProperties !==\n          undefined\n        ) {\n          delete (jsonSchema as JsonSchema7ObjectType).additionalProperties;\n        }\n\n        if ((jsonSchema as JsonSchema7ArrayType).maxItems !== undefined) {\n          (jsonSchema as Schema).maxItems = (\n            jsonSchema as JsonSchema7ArrayType\n          ).maxItems?.toString();\n        }\n\n        if ((jsonSchema as JsonSchema7ArrayType).minItems !== undefined) {\n          (jsonSchema as Schema).minItems = (\n            jsonSchema as JsonSchema7ArrayType\n          ).minItems?.toString();\n        }\n\n        if ((jsonSchema as JsonSchema7StringType).minLength !== undefined) {\n          (jsonSchema as Schema).minLength = (\n            jsonSchema as JsonSchema7StringType\n          ).minLength?.toString();\n        }\n\n        if ((jsonSchema as JsonSchema7StringType).maxLength !== undefined) {\n          (jsonSchema as Schema).maxLength = (\n            jsonSchema as JsonSchema7StringType\n          ).maxLength?.toString();\n        }\n\n        if (\n          (jsonSchema as JsonSchema7EnumType).enum?.length === 1 &&\n          (jsonSchema as JsonSchema7EnumType).enum[0] === 'null'\n        ) {\n          (jsonSchema as Schema).type = Type.NULL;\n          delete (jsonSchema as unknown as {enum?: []}).enum;\n        }\n\n        if (\n          (jsonSchema as JsonSchema7NumberType).type === 'integer' &&\n          (jsonSchema as JsonSchema7BigintType).format !== 'int64'\n        ) {\n          (jsonSchema as JsonSchema7NumberType).minimum ??=\n            Number.MIN_SAFE_INTEGER;\n          (jsonSchema as JsonSchema7NumberType).maximum ??=\n            Number.MAX_SAFE_INTEGER;\n        }\n\n        if ((jsonSchema as {type: string}).type !== undefined) {\n          (jsonSchema as {type: string}).type = (\n            jsonSchema as {type: string}\n          ).type.toUpperCase();\n        }\n\n        return jsonSchema;\n      },\n    }) as Schema;\n  }\n\n  throw new Error('Unsupported Zod schema version.');\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {Content} from '@google/genai';\nimport {cloneDeep} from 'lodash-es';\n\nimport {\n  createEvent,\n  Event,\n  getFunctionCalls,\n  getFunctionResponses,\n} from '../events/event.js';\n\nimport {\n  removeClientFunctionCallId,\n  REQUEST_CONFIRMATION_FUNCTION_CALL_NAME,\n  REQUEST_EUC_FUNCTION_CALL_NAME,\n} from './functions.js';\n\n/**\n * Get the contents for the LLM request.\n *\n * @param events: A list of all session events.\n * @param agentName: The name of the agent.\n * @param currentBranch: The current branch of the agent.\n *\n * @returns A list of processed contents.\n */\nexport function getContents(\n  events: Event[],\n  agentName: string,\n  currentBranch?: string,\n): Content[] {\n  const filteredEvents: Event[] = [];\n\n  for (const event of events) {\n    // Skip events without content, or generated neither by user nor by model.\n    // E.g. events purely for mutating session states.\n    if (!event.content?.role || event.content.parts?.[0]?.text === '') {\n      continue;\n    }\n\n    // Skip events not in the current branch.\n    // TODO - b/425992518: inefficient, a tire search is better.\n    if (\n      currentBranch &&\n      event.branch &&\n      !currentBranch.startsWith(event.branch)\n    ) {\n      continue;\n    }\n\n    if (isAuthEvent(event)) {\n      continue;\n    }\n\n    if (isToolConfirmationEvent(event)) {\n      continue;\n    }\n\n    filteredEvents.push(\n      isEventFromAnotherAgent(agentName, event)\n        ? convertForeignEvent(event)\n        : event,\n    );\n  }\n\n  let resultEvents = rearrangeEventsForLatestFunctionResponse(filteredEvents);\n  resultEvents =\n    rearrangeEventsForAsyncFunctionResponsesInHistory(resultEvents);\n  const contents = [];\n  for (const event of resultEvents) {\n    const content = cloneDeep(event.content!);\n    removeClientFunctionCallId(content);\n    contents.push(content);\n  }\n  return contents;\n}\n\n/**\n * Get contents for the current turn only (no conversation history).\n *\n * When include_contents='none', we want to include:\n * - The current user input\n * - Tool calls and responses from the current turn\n * But exclude conversation history from previous turns.\n *\n * In multi-agent scenarios, the \"current turn\" for an agent starts from an\n * actual user or from another agent.\n *\n * @param events: A list of all session events.\n * @param agentName: The name of the agent.\n * @param currentBranch: The current branch of the agent.\n *\n * @returns A list of contents for the current turn only, preserving context\n *     needed for proper tool execution while excluding conversation history.\n */\nexport function getCurrentTurnContents(\n  events: Event[],\n  agentName: string,\n  currentBranch?: string,\n): Content[] {\n  // Find the latest event that starts the current turn and process from there.\n  for (let i = events.length - 1; i >= 0; i--) {\n    const event = events[i];\n    if (event.author === 'user' || isEventFromAnotherAgent(agentName, event)) {\n      return getContents(events.slice(i), agentName, currentBranch);\n    }\n  }\n\n  return [];\n}\n\n/**\n * Whether the event is an auth event.\n *\n * An auth event is an event that contains a function call or response\n * related to requesting end-user credentials (EUC). These events are\n * skipped when constructing the content for the LLM request.\n */\nfunction isAuthEvent(event: Event): boolean {\n  if (!event.content?.parts) {\n    return false;\n  }\n  for (const part of event.content.parts) {\n    if (\n      part.functionCall?.name === REQUEST_EUC_FUNCTION_CALL_NAME ||\n      part.functionResponse?.name === REQUEST_EUC_FUNCTION_CALL_NAME\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Whether the event is a tool confirmation event.\n *\n * A tool confirmation event is an event that contains a function call or\n * response related to requesting confirmation for a tool call. These events\n * are skipped when constructing the content for the LLM request.\n */\nfunction isToolConfirmationEvent(event: Event): boolean {\n  if (!event.content?.parts) {\n    return false;\n  }\n  for (const part of event.content.parts) {\n    if (\n      part.functionCall?.name === REQUEST_CONFIRMATION_FUNCTION_CALL_NAME ||\n      part.functionResponse?.name === REQUEST_CONFIRMATION_FUNCTION_CALL_NAME\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Whether the event is from another agent.\n */\nfunction isEventFromAnotherAgent(agentName: string, event: Event): boolean {\n  return !!agentName && event.author !== agentName && event.author !== 'user';\n}\n\n/**\n * Formats an event authored by another agent to a user-content event.\n *\n * This is to provide another agent's output as context to the current agent,\n * so that current agent can continue to respond, such as summarizing previous\n * agent's reply, etc.\n *\n * @param event The event to convert.\n *\n * @returns The converted event.\n */\nfunction convertForeignEvent(event: Event): Event {\n  if (!event.content?.parts?.length) {\n    return event;\n  }\n\n  const content: Content = {\n    role: 'user',\n    parts: [\n      {\n        text: 'For context:',\n      },\n    ],\n  };\n\n  for (const part of event.content.parts) {\n    // Exclude thoughts from the context.\n    // TODO - b/425992518: filtring should be configurable.\n    if (part.text && !part.thought) {\n      content.parts?.push({\n        text: `[${event.author}] said: ${part.text}`,\n      });\n    } else if (part.functionCall) {\n      const argsText = safeStringify(part.functionCall.args);\n      content.parts?.push({\n        text: `[${event.author}] called tool \\`${part.functionCall.name}\\` with parameters: ${argsText}`,\n      });\n    } else if (part.functionResponse) {\n      const responseText = safeStringify(part.functionResponse.response);\n      content.parts?.push({\n        text: `[${event.author}] tool \\`${part.functionResponse.name}\\` returned result: ${responseText}`,\n      });\n    } else {\n      content.parts?.push(part);\n    }\n  }\n\n  return createEvent({\n    invocationId: event.invocationId,\n    author: 'user',\n    content,\n    branch: event.branch,\n    timestamp: event.timestamp,\n  });\n}\n\n/**\n * Merges a list of function_response events into one event.\n *\n * The key goal is to ensure:\n *  1. function_call and function_response are always of the same number.\n *  2. The function_call and function_response are consecutively in the content.\n *\n * @param events: A list of function_response events.\n *\n * NOTE:\n * function_response_events must fulfill these requirements:\n * 1. The list is in increasing order of timestamp;\n * 2. the first event is the initial function_response event;\n * 3. all later events should contain at least one function_response part that\n * related to the function_call event. Caveat: This implementation doesn't\n * support when a parallel function_call event contains async function_call of\n * the same name.\n *\n * @returns\n *    A merged event, that is\n *      1. All later function_response will replace function_response part in\n *          the initial function_response event.\n *      2. All non-function_response parts will be appended to the part list of\n *          the initial function_response event.\n */\nfunction mergeFunctionResponseEvents(events: Event[]): Event {\n  if (events.length === 0) {\n    throw new Error('Cannot merge an empty list of events.');\n  }\n\n  const mergedEvent = createEvent(events[0]);\n  const partsInMergedEvent = mergedEvent.content?.parts || [];\n\n  if (partsInMergedEvent.length === 0) {\n    throw new Error('There should be at least one function_response part.');\n  }\n\n  const partIndicesInMergedEvent: Record<string, number> = {};\n  for (let i = 0; i < partsInMergedEvent.length; i++) {\n    const part = partsInMergedEvent[i];\n    if (part.functionResponse && part.functionResponse.id) {\n      partIndicesInMergedEvent[part.functionResponse.id] = i;\n    }\n  }\n\n  for (const event of events.slice(1)) {\n    if (!event.content || !event.content.parts) {\n      throw new Error('There should be at least one function_response part.');\n    }\n    for (const part of event.content.parts) {\n      if (part.functionResponse && part.functionResponse.id) {\n        const functionCallId = part.functionResponse.id;\n        if (functionCallId in partIndicesInMergedEvent) {\n          partsInMergedEvent[partIndicesInMergedEvent[functionCallId]] = part;\n        } else {\n          partsInMergedEvent.push(part);\n          partIndicesInMergedEvent[functionCallId] =\n            partsInMergedEvent.length - 1;\n        }\n      } else {\n        partsInMergedEvent.push(part);\n      }\n    }\n  }\n\n  return mergedEvent;\n}\n\n/**\n * Rearrange the async functionResponse events in the history.\n */\nfunction rearrangeEventsForLatestFunctionResponse(events: Event[]): Event[] {\n  if (events.length === 0) {\n    return events;\n  }\n\n  const latestEvent = events[events.length - 1];\n  const functionResponses = getFunctionResponses(latestEvent);\n\n  // No need to process, since the latest event is not functionResponse.\n  if (!functionResponses?.length) {\n    return events;\n  }\n\n  let functionResponsesIds = new Set<string>(\n    functionResponses\n      .filter((response): response is {id: string} => !!response.id)\n      .map((response) => response.id),\n  );\n\n  // No need to rearrange if the second latest event already contains the\n  // corresponding function calls for the latest function responses.\n  const secondLatestEvent = events.at(-2);\n  if (secondLatestEvent) {\n    const functionCallsFromSecondLatest = getFunctionCalls(secondLatestEvent);\n    if (functionCallsFromSecondLatest) {\n      for (const functionCall of functionCallsFromSecondLatest) {\n        if (functionCall.id && functionResponsesIds.has(functionCall.id)) {\n          return events;\n        }\n      }\n    }\n  }\n\n  // Look for corresponding function call event reversely.\n  let functionCallEventIdx = -1;\n  for (let idx = events.length - 2; idx >= 0; idx--) {\n    const event = events[idx];\n    const functionCalls = getFunctionCalls(event);\n    if (!functionCalls?.length) {\n      continue;\n    }\n\n    for (const functionCall of functionCalls) {\n      if (functionCall.id && functionResponsesIds.has(functionCall.id)) {\n        functionCallEventIdx = idx;\n        const functionCallIds = new Set<string>(\n          functionCalls.map((fc) => fc.id).filter((id): id is string => !!id),\n        );\n\n        // Check if functionResponsesIds is a subset of functionCallIds\n        const isSubset = Array.from(functionResponsesIds).every((id) =>\n          functionCallIds.has(id),\n        );\n\n        if (!isSubset) {\n          throw new Error(\n            'Last response event should only contain the responses for the' +\n              ' function calls in the same function call event. Function' +\n              ` call ids found : ${Array.from(functionCallIds).join(\n                ', ',\n              )}, function response` +\n              ` ids provided: ${Array.from(functionResponsesIds).join(', ')}`,\n          );\n        }\n        // Expand the function call events to collect all function responses\n        // from the function call event to the last response event.\n        // TODO - b/425992518: bad practice, state can mutated multiple times.\n        functionResponsesIds = functionCallIds;\n        break;\n      }\n    }\n  }\n\n  if (functionCallEventIdx === -1) {\n    throw new Error(\n      `No function call event found for function responses ids: ${Array.from(\n        functionResponsesIds,\n      ).join(', ')}`,\n    );\n  }\n\n  // Collect all function response events between the function call event\n  // and the last function response event\n  const functionResponseEvents: Event[] = [];\n  for (let idx = functionCallEventIdx + 1; idx < events.length - 1; idx++) {\n    const event = events[idx];\n    const responses = getFunctionResponses(event);\n    if (\n      responses &&\n      responses.some(\n        (response) => response.id && functionResponsesIds.has(response.id),\n      )\n    ) {\n      functionResponseEvents.push(event);\n    }\n  }\n  functionResponseEvents.push(events[events.length - 1]);\n\n  const resultEvents = events.slice(0, functionCallEventIdx + 1);\n  resultEvents.push(mergeFunctionResponseEvents(functionResponseEvents));\n\n  return resultEvents;\n}\n\n/**\n * Rearrange the events for the latest function_response.\n *\n * If the latest function_response is for an async function_call, all events\n * between the initial function_call and the latest function_response will be\n * removed.\n *\n * @param event: A list of events.\n *\n * @returns A list of events with the latest function_response rearranged.\n */\nfunction rearrangeEventsForAsyncFunctionResponsesInHistory(\n  events: Event[],\n): Event[] {\n  const functionCallIdToResponseEventIndex: Map<string, number> = new Map();\n\n  // First pass: Map function_call_id to the index of their\n  // corresponding response events.\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i];\n    const functionResponses = getFunctionResponses(event);\n    if (functionResponses?.length) {\n      for (const functionResponse of functionResponses) {\n        if (!functionResponse.id) {\n          continue;\n        }\n\n        functionCallIdToResponseEventIndex.set(functionResponse.id, i);\n      }\n    }\n  }\n\n  const resultEvents: Event[] = [];\n\n  // Second pass: Build the new ordered list of events.\n  for (const event of events) {\n    // If the event contains function responses, it will be handled when\n    // its corresponding function_call is encountered, so skip it for now.\n    if (getFunctionResponses(event).length > 0) {\n      continue;\n    }\n\n    const functionCalls = getFunctionCalls(event);\n    if (functionCalls?.length) {\n      const functionResponseEventsIndices: Set<number> = new Set();\n      for (const functionCall of functionCalls) {\n        const functionCallId = functionCall.id;\n        if (\n          functionCallId &&\n          functionCallIdToResponseEventIndex.has(functionCallId)\n        ) {\n          functionResponseEventsIndices.add(\n            functionCallIdToResponseEventIndex.get(functionCallId)!,\n          );\n        }\n      }\n\n      resultEvents.push(event);\n\n      if (functionResponseEventsIndices.size === 0) {\n        continue;\n      }\n\n      if (functionResponseEventsIndices.size === 1) {\n        const [responseIndex] = [...functionResponseEventsIndices];\n        resultEvents.push(events[responseIndex]);\n      } else {\n        const indicesArray = Array.from(functionResponseEventsIndices).sort(\n          (a, b) => a - b,\n        );\n        const eventsToMerge = indicesArray.map((index) => events[index]);\n        resultEvents.push(mergeFunctionResponseEvents(eventsToMerge));\n      }\n    } else {\n      resultEvents.push(event);\n    }\n  }\n\n  return resultEvents;\n}\n\n/**\n * Safely stringifies an object, handling circular references.\n */\nfunction safeStringify(obj: unknown): string {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n  try {\n    return JSON.stringify(obj);\n  } catch (_e: unknown) {\n    return String(obj);\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {State} from '../sessions/state.js';\nimport {ReadonlyContext} from './readonly_context.js';\n\n/**\n * Populates values in the instruction template, e.g. state, artifact, etc.\n *\n * ```\n * async function buildInstruction(\n *     readonlyContext: ReadonlyContext,\n * ): Promise<string> {\n *   return await injectSessionState(\n *       'You can inject a state variable like {var_name} or an artifact ' +\n *       '{artifact.file_name} into the instruction template.',\n *       readonlyContext,\n *   );\n * }\n *\n * const agent = new LlmAgent({\n *     model: 'gemini-1.5-flash',\n *     name: 'agent',\n *     instruction: buildInstruction,\n * });\n * ```\n *\n * @param template The instruction template.\n * @param readonlyContext The read-only context\n * @returns The instruction template with values populated.\n */\nexport async function injectSessionState(\n  template: string,\n  readonlyContext: ReadonlyContext,\n): Promise<string> {\n  const invocationContext = readonlyContext.invocationContext;\n\n  /**\n   * Replaces a matched string in the template with the corresponding value from\n   * the context.\n   *\n   * @param match The matched string in the template.\n   * @returns The replaced string.\n   */\n  async function replaceMatchedKeyWithItsValue(\n    match: RegExpMatchArray,\n  ): Promise<string> {\n    // Step 1: extract the key from the match\n    let key = match[0].replace(/^\\{+/, '').replace(/\\}+$/, '').trim();\n    const isOptional = key.endsWith('?');\n    if (isOptional) {\n      key = key.slice(0, -1);\n    }\n\n    // Step 2: handle artifact injection\n    if (key.startsWith('artifact.')) {\n      const fileName = key.substring('artifact.'.length);\n      if (invocationContext.artifactService === undefined) {\n        throw new Error('Artifact service is not initialized.');\n      }\n      const artifact = await invocationContext.artifactService.loadArtifact({\n        appName: invocationContext.session.appName,\n        userId: invocationContext.session.userId,\n        sessionId: invocationContext.session.id,\n        filename: fileName,\n      });\n      if (!artifact) {\n        throw new Error(`Artifact ${fileName} not found.`);\n      }\n      return String(artifact);\n    }\n\n    // Step 3: Handle state variable injection.\n    if (!isValidStateName(key)) {\n      return match[0];\n    }\n\n    if (key in invocationContext.session.state) {\n      return String(invocationContext.session.state[key]);\n    }\n\n    if (isOptional) {\n      return '';\n    }\n\n    throw new Error(`Context variable not found: \\`${key}\\`.`);\n  }\n  // TODO - b/425992518: enable concurrent repalcement with key deduplication.\n  const pattern = /\\{+[^{}]*}+/g;\n  const result: string[] = [];\n  let lastEnd = 0;\n  const matches = template.matchAll(pattern);\n\n  for (const match of matches) {\n    result.push(template.slice(lastEnd, match.index));\n    const replacement = await replaceMatchedKeyWithItsValue(match);\n    result.push(replacement);\n    lastEnd = match.index! + match[0].length;\n  }\n  result.push(template.slice(lastEnd));\n  return result.join('');\n}\n\n/**\n * An IIFE that checks if the JavaScript runtime supports Unicode property\n * escapes (`\\p{...}`) in regular expressions and returns a RegExp object that\n * is used for all subsequent calls to isIdentifier().\n */\nconst isIdentifierPattern = (() => {\n  return /^[a-zA-Z_][a-zA-Z0-9_]*$/;\n})();\n\n/**\n * Checks if a string is a valid identifier.\n */\nfunction isIdentifier(s: string): boolean {\n  if (s === '' || s === undefined) {\n    return false;\n  }\n\n  return isIdentifierPattern.test(s);\n}\n\nconst VALID_PREFIXES = [State.APP_PREFIX, State.USER_PREFIX, State.TEMP_PREFIX];\n/**\n * Checks if a variable name is a valid state name.\n * A valid state name is either:\n *   - <identifier>\n *   - <prefix>:<identifier>\n *\n * @param variableName The variable name to check.\n * @returns True if the variable name is valid, False otherwise.\n */\nfunction isValidStateName(variableName: string): boolean {\n  const parts = variableName.split(':');\n  if (parts.length === 0 || parts.length > 2) {\n    return false;\n  }\n  if (parts.length === 1) {\n    return isIdentifier(variableName);\n  }\n  if (VALID_PREFIXES.includes(parts[0] + ':')) {\n    return isIdentifier(parts[1]);\n  }\n  return false;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  AudioTranscriptionConfig,\n  Modality,\n  ProactivityConfig,\n  RealtimeInputConfig,\n  SpeechConfig,\n} from '@google/genai';\n\nimport {logger} from '../utils/logger.js';\n\n/**\n * The streaming mode for the run config.\n */\nexport enum StreamingMode {\n  NONE = 'none',\n  SSE = 'sse',\n  BIDI = 'bidi',\n}\n\n/**\n * Configs for runtime behavior of agents.\n */\nexport interface RunConfig {\n  /**\n   * Speech configuration for the live agent.\n   */\n  speechConfig?: SpeechConfig;\n\n  /**\n   * The output modalities. If not set, it's default to AUDIO.\n   */\n  responseModalities?: Modality[];\n\n  /**\n   * Whether or not to save the input blobs as artifacts.\n   */\n  saveInputBlobsAsArtifacts?: boolean;\n\n  /**\n   * Whether to support CFC (Compositional Function Calling). Only applicable\n   * for StreamingMode.SSE. If it's true. the LIVE API will be invoked. Since\n   * only LIVE API supports CFC\n   *\n   * WARNING: This feature is **experimental** and its API or behavior may\n   * change in future releases.\n   */\n  supportCfc?: boolean;\n\n  /**\n   * Streaming mode, None or StreamingMode.SSE or StreamingMode.BIDI.\n   */\n  streamingMode?: StreamingMode;\n\n  /**\n   * Output audio transcription config.\n   */\n  outputAudioTranscription?: AudioTranscriptionConfig;\n\n  /**\n   * Input transcription for live agents with audio input from user.\n   */\n  inputAudioTranscription?: AudioTranscriptionConfig;\n\n  /**\n   * If enabled, the model will detect emotions and adapt its responses\n   * accordingly.\n   */\n  enableAffectiveDialog?: boolean;\n\n  /**\n   * Configures the proactivity of the model. This allows the model to respond\n   * proactively to the input and to ignore irrelevant input.\n   */\n  proactivity?: ProactivityConfig;\n\n  /**\n   * Realtime input config for live agents with audio input from user.\n   */\n  realtimeInputConfig?: RealtimeInputConfig;\n\n  /**\n   * A limit on the total number of llm calls for a given run.\n   *\n   * Valid Values:\n   *   - More than 0 and less than sys.maxsize: The bound on the number of llm\n   *     calls is enforced, if the value is set in this range.\n   *   - Less than or equal to 0: This allows for unbounded number of llm calls.\n   */\n  maxLlmCalls?: number;\n}\n\nexport function createRunConfig(params: Partial<RunConfig> = {}) {\n  return {\n    saveInputBlobsAsArtifacts: false,\n    supportCfc: false,\n    enableAffectiveDialog: false,\n    streamingMode: StreamingMode.NONE,\n    maxLlmCalls: validateMaxLlmCalls(params.maxLlmCalls || 500),\n    ...params,\n  };\n}\n\nfunction validateMaxLlmCalls(value: number): number {\n  if (value > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\n      `maxLlmCalls should be less than ${Number.MAX_SAFE_INTEGER}.`,\n    );\n  }\n\n  if (value <= 0) {\n    logger.warn(\n      'maxLlmCalls is less than or equal to 0. This will result in no enforcement on total number of llm calls that will be made for a run. This may not be ideal, as this could result in a never ending communication between the model and the agent in certain cases.',\n    );\n  }\n  return value;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Event} from '../events/event.js';\n\nimport {BaseAgent, BaseAgentConfig} from './base_agent.js';\nimport {InvocationContext} from './invocation_context.js';\n\n/**\n * The configuration options for creating a loop agent.\n */\nexport interface LoopAgentConfig extends BaseAgentConfig {\n  /**\n   * The maximum number of iterations the loop agent will run.\n   *\n   * If not provided, the loop agent will run indefinitely.\n   */\n  maxIterations?: number;\n}\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all LoopAgent instances.\n */\nconst LOOP_AGENT_SIGNATURE_SYMBOL = Symbol.for('google.adk.loopAgent');\n\n/**\n * Type guard to check if an object is an instance of LoopAgent.\n * @param obj The object to check.\n * @returns True if the object is an instance of LoopAgent, false otherwise.\n */\nexport function isLoopAgent(obj: unknown): obj is LoopAgent {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    LOOP_AGENT_SIGNATURE_SYMBOL in obj &&\n    obj[LOOP_AGENT_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * A shell agent that run its sub-agents in a loop.\n *\n * When sub-agent generates an event with escalate or max_iterations are\n * reached, the loop agent will stop.\n */\nexport class LoopAgent extends BaseAgent {\n  /**\n   * A unique symbol to identify ADK loop agent class.\n   */\n  readonly [LOOP_AGENT_SIGNATURE_SYMBOL] = true;\n\n  private readonly maxIterations: number;\n\n  constructor(config: LoopAgentConfig) {\n    super(config);\n    this.maxIterations = config.maxIterations ?? Number.MAX_SAFE_INTEGER;\n  }\n\n  protected async *runAsyncImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    let iteration = 0;\n\n    while (iteration < this.maxIterations) {\n      for (const subAgent of this.subAgents) {\n        let shouldExit = false;\n        for await (const event of subAgent.runAsync(context)) {\n          yield event;\n\n          if (event.actions.escalate) {\n            shouldExit = true;\n          }\n        }\n\n        if (shouldExit) {\n          return;\n        }\n      }\n\n      iteration++;\n    }\n\n    return;\n  }\n\n  // eslint-disable-next-line require-yield\n  protected async *runLiveImpl(\n    _context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    throw new Error('This is not supported yet for LoopAgent.');\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Event} from '../events/event.js';\n\nimport {BaseAgent} from './base_agent.js';\nimport {InvocationContext} from './invocation_context.js';\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all ParallelAgent instances.\n */\nconst PARALLEL_AGENT_SIGNATURE_SYMBOL = Symbol.for('google.adk.parallelAgent');\n\n/**\n * Type guard to check if an object is an instance of ParallelAgent.\n * @param obj The object to check.\n * @returns True if the object is an instance of ParallelAgent, false otherwise.\n */\nexport function isParallelAgent(obj: unknown): obj is ParallelAgent {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    PARALLEL_AGENT_SIGNATURE_SYMBOL in obj &&\n    obj[PARALLEL_AGENT_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * A shell agent that run its sub-agents in parallel in isolated manner.\n *\n * This approach is beneficial for scenarios requiring multiple perspectives or\n * attempts on a single task, such as:\n *\n *  - Running different algorithms simultaneously.\n *  - Generating multiple responses for review by a subsequent evaluation agent.\n */\nexport class ParallelAgent extends BaseAgent {\n  /**\n   * A unique symbol to identify ADK parallel agent class.\n   */\n  readonly [PARALLEL_AGENT_SIGNATURE_SYMBOL] = true;\n\n  protected async *runAsyncImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    const agentRuns = this.subAgents.map((subAgent) =>\n      subAgent.runAsync(createBranchCtxForSubAgent(this, subAgent, context)),\n    );\n\n    for await (const event of mergeAgentRuns(agentRuns)) {\n      yield event;\n    }\n  }\n\n  // eslint-disable-next-line require-yield\n  protected async *runLiveImpl(\n    _context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    throw new Error('This is not supported yet for ParallelAgent.');\n  }\n}\n\n/**\n * Create isolated branch for every sub-agent.\n */\nfunction createBranchCtxForSubAgent(\n  agent: BaseAgent,\n  subAgent: BaseAgent,\n  originalContext: InvocationContext,\n): InvocationContext {\n  const invocationContext = new InvocationContext(originalContext);\n  const branchSuffix = `${agent.name}.${subAgent.name}`;\n  invocationContext.branch = invocationContext.branch\n    ? `${invocationContext.branch}.${branchSuffix}`\n    : branchSuffix;\n\n  return invocationContext;\n}\n\n/**\n * Merges the agent run event generator.\n *\n * This implementation guarantees for each agent, it won't move on until the\n * generated event is processed by upstream runner.\n *\n * @param agentRuns A list of async generators that yield events from each\n *     agent.\n *\n * @returns A list of async generators that yield events from each agent.\n *\n * @yield The next event from the merged generator.\n */\nasync function* mergeAgentRuns(\n  agentRuns: AsyncGenerator<Event, void, void>[],\n): AsyncGenerator<Event, void, void> {\n  const pendingPromises = new Map<\n    number,\n    Promise<{result: IteratorResult<Event>; index: number}>\n  >();\n\n  for (const [index, generator] of agentRuns.entries()) {\n    const promise = generator.next().then((result) => ({result, index}));\n    pendingPromises.set(index, promise);\n  }\n\n  while (pendingPromises.size > 0) {\n    const {result, index} = await Promise.race(pendingPromises.values());\n\n    if (result.done) {\n      pendingPromises.delete(index);\n      continue;\n    }\n\n    yield result.value;\n\n    const nextPromise = agentRuns[index]\n      .next()\n      .then((result) => ({result, index}));\n    pendingPromises.set(index, nextPromise);\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {Event} from '../events/event.js';\nimport {FunctionTool} from '../tools/function_tool.js';\n\nimport {BaseAgent} from './base_agent.js';\nimport {InvocationContext} from './invocation_context.js';\nimport {isLlmAgent} from './llm_agent.js';\nimport {ReadonlyContext} from './readonly_context.js';\n\nconst TASK_COMPLETED_TOOL_NAME = 'task_completed';\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all SequentialAgent instances.\n */\nconst SEQUENTIAL_AGENT_SIGNATURE_SYMBOL = Symbol.for(\n  'google.adk.sequentialAgent',\n);\n\n/**\n * Type guard to check if an object is an instance of SequentialAgent.\n * @param obj The object to check.\n * @returns True if the object is an instance of SequentialAgent, false otherwise.\n */\nexport function isSequentialAgent(obj: unknown): obj is SequentialAgent {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    SEQUENTIAL_AGENT_SIGNATURE_SYMBOL in obj &&\n    obj[SEQUENTIAL_AGENT_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * A shell agent that runs its sub-agents in a sequential order.\n */\nexport class SequentialAgent extends BaseAgent {\n  /**\n   * A unique symbol to identify ADK sequential agent class.\n   */\n  readonly [SEQUENTIAL_AGENT_SIGNATURE_SYMBOL] = true;\n\n  protected async *runAsyncImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    for (const subAgent of this.subAgents) {\n      for await (const event of subAgent.runAsync(context)) {\n        yield event;\n      }\n    }\n  }\n\n  /**\n   * Implementation for live SequentialAgent.\n   *\n   * Compared to the non-live case, live agents process a continuous stream of\n   * audio or video, so there is no way to tell if it's finished and should pass\n   * to the next agent or not. So we introduce a task_completed() function so\n   * the model can call this function to signal that it's finished the task and\n   * we can move on to the next agent.\n   *\n   * @param context The invocation context of the agent.\n   */\n  protected async *runLiveImpl(\n    context: InvocationContext,\n  ): AsyncGenerator<Event, void, void> {\n    for (const subAgent of this.subAgents) {\n      if (isLlmAgent(subAgent)) {\n        const agentTools = await subAgent.canonicalTools(\n          new ReadonlyContext(context),\n        );\n        const taskCompletedToolAlreadyAdded = agentTools.some(\n          (tool) => tool.name === TASK_COMPLETED_TOOL_NAME,\n        );\n\n        if (!taskCompletedToolAlreadyAdded) {\n          subAgent.tools.push(\n            new FunctionTool({\n              name: TASK_COMPLETED_TOOL_NAME,\n              description: `Signals that the model has successfully completed the user's question or task.`,\n              execute: () => 'Task completion signaled.',\n            }),\n          );\n          subAgent.instruction += `If you finished the user's request according to its description, call the ${\n            TASK_COMPLETED_TOOL_NAME\n          } function to exit so the next agents can take over. When calling this function, do not generate any text other than the function call.`;\n        }\n      }\n    }\n\n    for (const subAgent of this.subAgents) {\n      for await (const event of subAgent.runLive(context)) {\n        yield event;\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Part} from '@google/genai';\n\nimport {\n  BaseArtifactService,\n  DeleteArtifactRequest,\n  ListArtifactKeysRequest,\n  ListVersionsRequest,\n  LoadArtifactRequest,\n  SaveArtifactRequest,\n} from './base_artifact_service.js';\n\n/**\n * An in-memory implementation of the ArtifactService.\n */\nexport class InMemoryArtifactService implements BaseArtifactService {\n  private readonly artifacts: Record<string, Part[]> = {};\n\n  saveArtifact({\n    appName,\n    userId,\n    sessionId,\n    filename,\n    artifact,\n  }: SaveArtifactRequest): Promise<number> {\n    const path = artifactPath(appName, userId, sessionId, filename);\n\n    if (!this.artifacts[path]) {\n      this.artifacts[path] = [];\n    }\n\n    const version = this.artifacts[path].length;\n    this.artifacts[path].push(artifact);\n\n    return Promise.resolve(version);\n  }\n\n  loadArtifact({\n    appName,\n    userId,\n    sessionId,\n    filename,\n    version,\n  }: LoadArtifactRequest): Promise<Part | undefined> {\n    const path = artifactPath(appName, userId, sessionId, filename);\n    const versions = this.artifacts[path];\n\n    if (!versions) {\n      return Promise.resolve(undefined);\n    }\n\n    if (version === undefined) {\n      version = versions.length - 1;\n    }\n\n    return Promise.resolve(versions[version]);\n  }\n\n  listArtifactKeys({\n    appName,\n    userId,\n    sessionId,\n  }: ListArtifactKeysRequest): Promise<string[]> {\n    const sessionPrefix = `${appName}/${userId}/${sessionId}/`;\n    const usernamespacePrefix = `${appName}/${userId}/user/`;\n    const filenames: string[] = [];\n\n    for (const path in this.artifacts) {\n      if (path.startsWith(sessionPrefix)) {\n        const filename = path.replace(sessionPrefix, '');\n        filenames.push(filename);\n      } else if (path.startsWith(usernamespacePrefix)) {\n        const filename = path.replace(usernamespacePrefix, '');\n        filenames.push(filename);\n      }\n    }\n\n    return Promise.resolve(filenames.sort());\n  }\n\n  deleteArtifact({\n    appName,\n    userId,\n    sessionId,\n    filename,\n  }: DeleteArtifactRequest): Promise<void> {\n    const path = artifactPath(appName, userId, sessionId, filename);\n    if (!this.artifacts[path]) {\n      return Promise.resolve();\n    }\n    delete this.artifacts[path];\n\n    return Promise.resolve();\n  }\n\n  listVersions({\n    appName,\n    userId,\n    sessionId,\n    filename,\n  }: ListVersionsRequest): Promise<number[]> {\n    const path = artifactPath(appName, userId, sessionId, filename);\n    const artifacts = this.artifacts[path];\n\n    if (!artifacts) {\n      return Promise.resolve([]);\n    }\n\n    const versions: number[] = [];\n    for (let i = 0; i < artifacts.length; i++) {\n      versions.push(i);\n    }\n\n    return Promise.resolve(versions);\n  }\n}\n\n/**\n * Constructs the path to the artifact.\n *\n * @param appName The app name.\n * @param userId The user ID.\n * @param sessionId The session ID.\n * @param filename The filename.\n * @return The path to the artifact.\n */\nfunction artifactPath(\n  appName: string,\n  userId: string,\n  sessionId: string,\n  filename: string,\n): string {\n  if (fileHasUserNamespace(filename)) {\n    return `${appName}/${userId}/user/${filename}`;\n  }\n\n  return `${appName}/${userId}/${sessionId}/${filename}`;\n}\n\n/**\n * Checks if the filename has a user namespace prefix.\n *\n * @param filename The filename to check.\n * @return true if the filename has a user namespace (starts with \"user:\") false\n *     otherwise.\n */\nfunction fileHasUserNamespace(filename: string): boolean {\n  return filename.startsWith('user:');\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Represents the secret token value for HTTP authentication, like user name,\n * password, oauth token, etc.\n */\nexport interface HttpCredentials {\n  username?: string;\n  password?: string;\n  token?: string;\n}\n\n/**\n * The credentials and metadata for HTTP authentication.\n */\nexport interface HttpAuth {\n  /**\n   * The name of the HTTP Authorization scheme to be used in the Authorization\n   * header as defined in RFC7235. The values used SHOULD be registered in the\n   * IANA Authentication Scheme registry.\n   * Examples: 'basic', 'bearer'\n   */\n  scheme: string;\n  credentials: HttpCredentials;\n}\n\n/**\n * Represents credential value and its metadata for a OAuth2 credential.\n */\nexport interface OAuth2Auth {\n  clientId?: string;\n  clientSecret?: string;\n  /**\n   * tool or adk can generate the authUri with the state info thus client can\n   * verify the state\n   */\n  authUri?: string;\n  state?: string;\n  /**\n   * tool or adk can decide the redirect_uri if they don't want client to decide\n   */\n  redirectUri?: string;\n  authResponseUri?: string;\n  authCode?: string;\n  accessToken?: string;\n  refreshToken?: string;\n  expiresAt?: number;\n  expiresIn?: number;\n}\n\n/**\n * Represents Google Service Account configuration.\n * @example\n * config = {\n *   type: \"service_account\",\n *   projectId: \"your_project_id\",\n *   privateKeyId: \"your_private_key_id\",\n *   privateKey: \"-----BEGIN PRIVATE KEY-----...\",\n *   clientEmail: \"...@....iam.gserviceaccount.com\",\n *   clientId: \"your_client_id\",\n *   authUri: \"https://accounts.google.com/o/oauth2/auth\",\n *   tokenUri: \"https://oauth2.googleapis.com/token\",\n *   authProviderX509CertUrl: \"https://www.googleapis.com/oauth2/v1/certs\",\n *   clientX509CertUrl: \"https://www.googleapis.com/robot/v1/metadata/x509/...\",\n *   universeDomain: \"googleapis.com\",\n * }\n */\nexport interface ServiceAccountCredential {\n  /**\n   * The type should be 'service_account'.\n   */\n  type: 'service_account';\n\n  /**\n   * The project ID of the Google Cloud project.\n   */\n  projectId: string;\n\n  /**\n   * The ID of the private key.\n   */\n  privateKeyId: string;\n\n  /**\n   * The private key value.\n   */\n  privateKey: string;\n\n  /**\n   * The client email.\n   */\n  clientEmail: string;\n\n  /**\n   * The client ID.\n   */\n  clientId: string;\n\n  /**\n   * The authorization URI.\n   */\n  authUri: string;\n\n  /**\n   * The token URI.\n   */\n  tokenUri: string;\n\n  /**\n   * URL for auth provider's X.509 cert.\n   */\n  authProviderX509CertUrl: string;\n\n  /**\n   * URL for the client's X.509 cert.\n   */\n  clientX509CertUrl: string;\n\n  /**\n   * The universe domain.\n   */\n  universeDomain: string;\n}\n\n/**\n * Represents Google Service Account configuration.\n */\nexport interface ServiceAccount {\n  serviceAccountCredential?: ServiceAccountCredential;\n  scopes?: string[];\n  useDefaultCredential?: boolean;\n}\n\n/*\n * Represents the type of authentication credential.\n */\nexport enum AuthCredentialTypes {\n  /**\n   * API Key credential:\n   * @see {@link https://swagger.io/docs/specification/v3_0/authentication/api-keys/}\n   */\n  API_KEY = 'apiKey',\n\n  /**\n   * Credentials for HTTP Auth schemes:\n   * @see {@link https://www.iana.org/assignments/http-authschemes/http-auth-schemes.xhtml}\n   */\n  HTTP = 'http',\n\n  /**\n   * OAuth2 credentials:\n   * @see {@link https://swagger.io/docs/specification/v3_0/authentication/oauth2/}\n   */\n  OAUTH2 = 'oauth2',\n\n  /**\n   * Open ID Connect credentials:\n   * @see {@link https://swagger.io/docs/specification/v3_0/authentication/openid-connect-discovery/}\n   */\n  OPEN_ID_CONNECT = 'openIdConnect',\n\n  /**\n   * Service Account credentials:\n   * @see {@link https://cloud.google.com/iam/docs/service-account-creds}\n   */\n  SERVICE_ACCOUNT = 'serviceAccount',\n}\n\n/**\n * Data class representing an authentication credential.\n *\n * To exchange for the actual credential, please use\n * CredentialExchanger.exchangeCredential().\n *\n * @example\n * // API Key Auth\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.API_KEY,\n *   apiKey: \"your_api_key\",\n * };\n *\n * @example\n * // HTTP Auth\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.HTTP,\n *   http: {\n *     scheme: \"basic\",\n *     credentials: {\n *       username: \"user\",\n *       password: \"password\",\n *     },\n *   }\n * }\n *\n * @example\n * // OAuth2 Bearer Token in HTTP Header\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.HTTP,\n *   http: {\n *     scheme: \"bearer\",\n *     credentials: {\n *       token: \"your_access_token\",\n *     },\n *   }\n * }\n *\n * @example\n * // OAuth2 Auth with Authorization Code Flow\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.OAUTH2,\n *   oauth2: {\n *     clientId: \"your_client_id\",\n *     clientSecret: \"your_client_secret\",\n *   }\n * }\n *\n * @example:\n * // Open ID Connect Auth\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.OPEN_ID_CONNECT,\n *   oauth2: {\n *     clientId: \"1234\",\n *     clientSecret: \"secret\",\n *     redirectUri: \"https://example.com\",\n *     scopes: [\"scope1\", \"scope2\"],\n *   }\n * }\n *\n * @example:\n * // Auth with resource reference\n * const authCredential: AuthCredential = {\n *   authType: AuthCredentialTypes.API_KEY,\n *   resourceRef: \"projects/1234/locations/us-central1/resources/resource1\"\n * }\n */\nexport interface AuthCredential {\n  authType: AuthCredentialTypes;\n\n  /**\n   * Resource reference for the credential.\n   * This will be supported in the future.\n   */\n  resourceRef?: string;\n\n  apiKey?: string;\n  http?: HttpAuth;\n  serviceAccount?: ServiceAccount;\n  oauth2?: OAuth2Auth;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Example} from './example.js';\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all BaseExampleProvider instances.\n */\nconst BASE_EXAMPLE_PROVIDER_SIGNATURE_SYMBOL = Symbol.for(\n  'google.adk.baseExampleProvider',\n);\n\n/**\n * Type guard to check if an object is an instance of BaseExampleProvider.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseExampleProvider, false otherwise.\n */\nexport function isBaseExampleProvider(\n  obj: unknown,\n): obj is BaseExampleProvider {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    BASE_EXAMPLE_PROVIDER_SIGNATURE_SYMBOL in obj &&\n    obj[BASE_EXAMPLE_PROVIDER_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * Base class for example providers.\n *\n *  This class defines the interface for providing examples for a given query.\n */\nexport abstract class BaseExampleProvider {\n  /**\n   * A unique symbol to identify ADK example provider classes.\n   */\n  readonly [BASE_EXAMPLE_PROVIDER_SIGNATURE_SYMBOL] = true;\n\n  /**\n   * Returns a list of examples for a given query.\n   *\n   * @param query The query to get examples for.\n   * @return A list of Example objects.\n   */\n  abstract getExamples(query: string): Example[];\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Event} from '../events/event.js';\nimport {Session} from '../sessions/session.js';\n\nimport {\n  BaseMemoryService,\n  SearchMemoryRequest,\n  SearchMemoryResponse,\n} from './base_memory_service.js';\nimport {MemoryEntry} from './memory_entry.js';\n\n/**\n * An in-memory memory service for prototyping purpose only.\n *\n * Uses keyword matching instead of semantic search.\n */\nexport class InMemoryMemoryService implements BaseMemoryService {\n  private readonly memories: MemoryEntry[] = [];\n  private readonly sessionEvents: {\n    [userKey: string]: {[sessionId: string]: Event[]};\n  } = {};\n\n  async addSessionToMemory(session: Session): Promise<void> {\n    const userKey = getUserKey(session.appName, session.userId);\n    if (!this.sessionEvents[userKey]) {\n      this.sessionEvents[userKey] = {};\n    }\n    this.sessionEvents[userKey][session.id] = session.events.filter(\n      (event) => (event.content?.parts?.length ?? 0) > 0,\n    );\n  }\n\n  async searchMemory(req: SearchMemoryRequest): Promise<SearchMemoryResponse> {\n    const userKey = getUserKey(req.appName, req.userId);\n    if (!this.sessionEvents[userKey]) {\n      return Promise.resolve({memories: []});\n    }\n\n    const wordsInQuery = req.query.toLowerCase().split(/\\s+/);\n    const response: SearchMemoryResponse = {memories: []};\n\n    for (const sessionEvents of Object.values(this.sessionEvents[userKey])) {\n      for (const event of sessionEvents) {\n        if (!event.content?.parts?.length) {\n          continue;\n        }\n\n        const joinedText = event.content.parts\n          .map((part) => part.text)\n          .filter((text) => !!text)\n          .join(' ');\n        const wordsInEvent = extractWordsLower(joinedText);\n        if (!wordsInEvent.size) {\n          continue;\n        }\n\n        const matchQuery = wordsInQuery.some((queryWord) =>\n          wordsInEvent.has(queryWord),\n        );\n        if (matchQuery) {\n          response.memories.push({\n            content: event.content,\n            author: event.author,\n            timestamp: formatTimestamp(event.timestamp),\n          });\n        }\n      }\n    }\n\n    return response;\n  }\n}\n\n/**\n * Constructs the user key from the app name and user ID.\n *\n * @param appName The app name.\n * @param userId The user ID.\n * @return The user key.\n */\nfunction getUserKey(appName: string, userId: string): string {\n  return `${appName}/${userId}`;\n}\n\n/**\n * Extracts the words from the text.\n *\n * @param text The text to extract the words from.\n * @return A set of words.\n */\nfunction extractWordsLower(text: string): Set<string> {\n  return new Set(\n    [...text.matchAll(/[A-Za-z]+/)].map((match) => match[0].toLowerCase()),\n  );\n}\n\n/**\n * Formats the timestamp to a string in ISO format.\n *\n * @param timestamp The timestamp to format.\n * @return A string representing the timestamp in ISO format.\n */\nfunction formatTimestamp(timestamp: number): string {\n  return new Date(timestamp).toISOString();\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {CallbackContext} from '../agents/callback_context.js';\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {Event} from '../events/event.js';\nimport {LlmRequest} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {ToolContext} from '../tools/tool_context.js';\n\n/**\n * Base class for creating plugins.\n *\n * Plugins provide a structured way to intercept and modify agent, tool, and\n * LLM behaviors at critical execution points in a callback manner. While agent\n * callbacks apply to a particular agent, plugins applies globally to all\n * agents added in the runner. Plugins are best used for adding custom behaviors\n * like logging, monitoring, caching, or modifying requests and responses at key\n * stages.\n *\n * A plugin can implement one or more methods of callbacks, but should not\n * implement the same method of callback for multiple times.\n *\n * Relation with [Agent\n * callbacks](https://google.github.io/adk-docs/callbacks/):\n *\n * **Execution Order**\n * Similar to Agent callbacks, Plugins are executed in the order they are\n * registered. However, Plugin and Agent Callbacks are executed sequentially,\n * with Plugins takes precedence over agent callbacks. When the callback in a\n * plugin returns a value, it will short circuit all remaining plugins and\n * agent callbacks, causing all remaining plugins and agent callbacks\n * to be skipped.\n *\n * **Change Propagation**\n * Plugins and agent callbacks can both modify the value of the input\n * parameters, including agent input, tool input, and LLM request/response, etc.\n * They work in the exactly same way. The modifications will be visible and\n * passed to the next callback in the chain. For example, if a plugin modifies\n * the tool input with before_tool_callback, the modified tool input will be\n * passed to the before_tool_callback of the next plugin, and further passed to\n * the agent callbacks if not short circuited.\n *\n * To use a plugin, implement the desired callback methods and pass an instance\n * of your custom plugin class to the ADK Runner.\n *\n * Example:\n * A simple plugin that logs every tool call.\n * ```typescript\n * class ToolLoggerPlugin extends BasePlugin {\n *   constructor() {\n *     super('tool_logger');\n *   }\n *\n *   override async beforeToolCallback(\n *     {tool, toolArgs, toolContext}: {\n *       tool: BaseTool,\n *       toolArgs: Record<string, unknown>,\n *       toolContext: ToolContext,\n *     },\n *   ): Promise<Record<string, unknown> | undefined> {\n *     this.logger.info(\n *       `[${this.name}] Calling tool '${tool.name}' with args:\n * ${JSON.stringify( toolArgs,\n *       )}`,\n *     );\n *     return;\n *   }\n *\n *   override async afterToolCallback(\n *     {tool, toolArgs, toolContext, result}: {\n *       tool: BaseTool,\n *       toolArgs: Record<string, unknown>,\n *       toolContext: ToolContext,\n *       result: Record<string, unknown>,\n *     },\n *   ): Promise<Record<string, unknown> | undefined> {\n *     this.logger.info(\n *       `[${this.name}] Tool '${tool.name}' finished with result:\n * ${JSON.stringify( result,\n *       )}`,\n *     );\n *     return;\n *   }\n * }\n *\n * // Add the plugin to ADK Runner\n * // runner = new Runner({\n * //   ...\n * //   plugins: [new ToolLoggerPlugin(), new AgentPolicyPlugin()],\n * // });\n * ```\n */\nexport abstract class BasePlugin {\n  readonly name: string;\n\n  /**\n   * Initializes the plugin.\n   *\n   * @param name A unique identifier for this plugin instance.\n   */\n  constructor(name: string) {\n    this.name = name;\n  }\n\n  /**\n   * Callback executed when a user message is received before an invocation\n   * starts.\n   *\n   * This callback helps logging and modifying the user message before the\n   * runner starts the invocation.\n   *\n   * @param params.invocationContext The context for the entire invocation.\n   * @param params.userMessage The message content input by user.\n   * @returns An optional `Content` to be returned to the ADK. Returning a\n   *     value to replace the user message. Returning `undefined` to proceed\n   *     normally.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async onUserMessageCallback(params: {\n    invocationContext: InvocationContext;\n    userMessage: Content;\n  }): Promise<Content | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed before the ADK runner runs.\n   *\n   * This is the first callback to be called in the lifecycle, ideal for global\n   * setup or initialization tasks.\n   *\n   * @param params.invocationContext The context for the entire invocation, containing\n   *     session information, the root agent, etc.\n   * @returns An optional `Event` to be returned to the ADK. Returning a value\n   *     to halt execution of the runner and ends the runner with that event.\n   *     Return `undefined` to proceed normally.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async beforeRunCallback(params: {\n    invocationContext: InvocationContext;\n  }): Promise<Content | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed after an event is yielded from runner.\n   *\n   * This is the ideal place to make modification to the event before the event\n   * is handled by the underlying agent app.\n   *\n   * @param params.invocationContext The context for the entire invocation.\n   * @param params.event The event raised by the runner.\n   * @returns An optional value. A non-`undefined` return may be used by the\n   *     framework to modify or replace the response. Returning `undefined`\n   *     allows the original response to be used.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async onEventCallback(params: {\n    invocationContext: InvocationContext;\n    event: Event;\n  }): Promise<Event | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed after an ADK runner run has completed.\n   *\n   * This is the final callback in the ADK lifecycle, suitable for cleanup,\n   * final logging, or reporting tasks.\n   *\n   * @param params.invocationContext The context for the entire invocation.\n   * @returns undefined\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async afterRunCallback(params: {\n    invocationContext: InvocationContext;\n  }): Promise<void> {\n    return;\n  }\n\n  /**\n   * Callback executed before an agent's primary logic is invoked.\n   *\n   * This callback can be used for logging, setup, or to short-circuit the\n   * agent's execution by returning a value.\n   *\n   * @param params.agent The agent that is about to run.\n   * @param params.callbackContext The context for the agent invocation.\n   * @returns An optional `Content` object. If a value is returned, it will\n   *     bypass the agent's callbacks and its execution, and return this value\n   *     directly. Returning `undefined` allows the agent to proceed normally.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async beforeAgentCallback(params: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed after an agent's primary logic has completed.\n   *\n   * This callback can be used to inspect, log, or modify the agent's final\n   * result before it is returned.\n   *\n   * @param params.agent The agent that has just run.\n   * @param params.callbackContext The context for the agent invocation.\n   * @returns An optional `Content` object. If a value is returned, it will\n   *     replace the agent's original result. Returning `undefined` uses the\n   *     original, unmodified result.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async afterAgentCallback(params: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed before a request is sent to the model.\n   *\n   * This provides an opportunity to inspect, log, or modify the `LlmRequest`\n   * object. It can also be used to implement caching by returning a cached\n   * `LlmResponse`, which would skip the actual model call.\n   *\n   * @param params.callbackContext The context for the current agent call.\n   * @param params.llmRequest The prepared request object to be sent to the model.\n   * @returns An optional value. The interpretation of a non-`undefined`\n   *     trigger an early exit and returns the response immediately. Returning\n   *     `undefined` allows the LLM request to proceed normally.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async beforeModelCallback(params: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n  }): Promise<LlmResponse | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed after a response is received from the model.\n   *\n   * This is the ideal place to log model responses, collect metrics on token\n   * usage, or perform post-processing on the raw `LlmResponse`.\n   *\n   * @param params.callbackContext The context for the current agent call.\n   * @param params.llmResponse The response object received from the model.\n   * @returns An optional value. A non-`undefined` return may be used by the\n   *     framework to modify or replace the response. Returning `undefined`\n   *     allows the original response to be used.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async afterModelCallback(params: {\n    callbackContext: CallbackContext;\n    llmResponse: LlmResponse;\n  }): Promise<LlmResponse | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed when a model call encounters an error.\n   *\n   * This callback provides an opportunity to handle model errors gracefully,\n   * potentially providing alternative responses or recovery mechanisms.\n   *\n   * @param params.callbackContext The context for the current agent call.\n   * @param params.llmRequest The request that was sent to the model when the error\n   *     occurred.\n   * @param params.error The exception that was raised during model execution.\n   * @returns An optional LlmResponse. If an LlmResponse is returned, it will be\n   *     used instead of propagating the error. Returning `undefined` allows\n   *     the original error to be raised.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async onModelErrorCallback(params: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n    error: Error;\n  }): Promise<LlmResponse | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed before a tool is called.\n   *\n   * This callback is useful for logging tool usage, input validation, or\n   * modifying the arguments before they are passed to the tool.\n   *\n   * @param params.tool The tool instance that is about to be executed.\n   * @param params.toolArgs The dictionary of arguments to be used for invoking the\n   *     tool.\n   * @param params.toolContext The context specific to the tool execution.\n   * @returns An optional dictionary. If a dictionary is returned, it will stop\n   *     the tool execution and return this response immediately. Returning\n   *     `undefined` uses the original, unmodified arguments.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async beforeToolCallback(params: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n  }): Promise<Record<string, unknown> | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed after a tool has been called.\n   *\n   * This callback allows for inspecting, logging, or modifying the result\n   * returned by a tool.\n   *\n   * @param params.tool The tool instance that has just been executed.\n   * @param params.toolArgs The original arguments that were passed to the tool.\n   * @param params.toolContext The context specific to the tool execution.\n   * @param params.result The dictionary returned by the tool invocation.\n   * @returns An optional dictionary. If a dictionary is returned, it will\n   *     **replace** the original result from the tool. This allows for\n   *     post-processing or altering tool outputs. Returning `undefined` uses\n   *     the original, unmodified result.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async afterToolCallback(params: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    result: Record<string, unknown>;\n  }): Promise<Record<string, unknown> | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed when a tool call encounters an error.\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    result: Record<string, unknown>;\n  }): Promise<Record<string, unknown> | undefined> {\n    return;\n  }\n\n  /**\n   * Callback executed when a tool call encounters an error.\n   *\n   * This callback provides an opportunity to handle tool errors gracefully,\n   * potentially providing alternative responses or recovery mechanisms.\n   *\n   * @param params.tool The tool instance that encountered an error.\n   * @param params.toolArgs The arguments that were passed to the tool.\n   * @param params.toolContext The context specific to the tool execution.\n   * @param params.error The exception that was raised during tool execution.\n   * @returns An optional dictionary. If a dictionary is returned, it will be\n   *     used as the tool response instead of propagating the error. Returning\n   *     `undefined` allows the original error to be raised.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async onToolErrorCallback(params: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    error: Error;\n  }): Promise<Record<string, unknown> | undefined> {\n    return;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {CallbackContext} from '../agents/callback_context.js';\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {\n  Event,\n  getFunctionCalls,\n  getFunctionResponses,\n  isFinalResponse,\n} from '../events/event.js';\nimport {LlmRequest} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {ToolContext} from '../tools/tool_context.js';\nimport {logger} from '../utils/logger.js';\n\nimport {BasePlugin} from './base_plugin.js';\n\n/**\n * A plugin that logs important information at each callback point.\n *\n * This plugin helps printing all critical events in the console. It is not a\n * replacement of existing logging in ADK. It rather helps terminal based\n * debugging by showing all logs in the console, and serves as a simple demo for\n * everyone to leverage when developing new plugins.\n *\n * This plugin helps users track the invocation status by logging:\n * - User messages and invocation context\n * - Agent execution flow\n * - LLM requests and responses\n * - Tool calls with arguments and results\n * - Events and final responses\n * - Errors during model and tool execution\n *\n * Example:\n * ```typescript\n * const loggingPlugin = new LoggingPlugin();\n * const runner = new Runner({\n *   agents: [myAgent],\n *   // ...\n *   plugins: [loggingPlugin],\n * });\n * ```\n */\nexport class LoggingPlugin extends BasePlugin {\n  /**\n   * Initialize the logging plugin.\n   *\n   * @param name The name of the plugin instance.\n   */\n  constructor(name = 'logging_plugin') {\n    super(name);\n  }\n\n  override async onUserMessageCallback({\n    invocationContext,\n    userMessage,\n  }: {\n    invocationContext: InvocationContext;\n    userMessage: Content;\n  }): Promise<Content | undefined> {\n    this.log('\uD83D\uDE80 USER MESSAGE RECEIVED');\n    this.log(`   Invocation ID: ${invocationContext.invocationId}`);\n    this.log(`   Session ID: ${invocationContext.session.id}`);\n    this.log(`   User ID: ${invocationContext.userId}`);\n    this.log(`   App Name: ${invocationContext.appName}`);\n    this.log(`   Root Agent: ${invocationContext.agent.name ?? 'Unknown'}`);\n    this.log(`   User Content: ${this.formatContent(userMessage)}`);\n    if (invocationContext.branch) {\n      this.log(`   Branch: ${invocationContext.branch}`);\n    }\n    return undefined;\n  }\n\n  override async beforeRunCallback({\n    invocationContext,\n  }: {\n    invocationContext: InvocationContext;\n  }): Promise<Content | undefined> {\n    this.log('\uD83C\uDFC3 INVOCATION STARTING');\n    this.log(`   Invocation ID: ${invocationContext.invocationId}`);\n    this.log(`   Starting Agent: ${invocationContext.agent.name ?? 'Unknown'}`);\n    return undefined;\n  }\n\n  override async onEventCallback({\n    event,\n  }: {\n    invocationContext: InvocationContext;\n    event: Event;\n  }): Promise<Event | undefined> {\n    this.log('\uD83D\uDCE2 EVENT YIELDED');\n    this.log(`   Event ID: ${event.id}`);\n    this.log(`   Author: ${event.author}`);\n    this.log(`   Content: ${this.formatContent(event.content)}`);\n    this.log(`   Final Response: ${isFinalResponse(event)}`);\n\n    const functionCalls = getFunctionCalls(event);\n    if (functionCalls.length > 0) {\n      const funcCalls = functionCalls.map((fc) => fc.name);\n      this.log(`   Function Calls: ${funcCalls}`);\n    }\n\n    const functionResponses = getFunctionResponses(event);\n    if (functionResponses.length > 0) {\n      const funcResponses = functionResponses.map((fr) => fr.name);\n      this.log(`   Function Responses: ${funcResponses}`);\n    }\n\n    if (event.longRunningToolIds && event.longRunningToolIds.length > 0) {\n      this.log(`   Long Running Tools: ${[...event.longRunningToolIds]}`);\n    }\n\n    return undefined;\n  }\n\n  override async afterRunCallback({\n    invocationContext,\n  }: {\n    invocationContext: InvocationContext;\n  }): Promise<void> {\n    this.log('\u2705 INVOCATION COMPLETED');\n    this.log(`   Invocation ID: ${invocationContext.invocationId}`);\n    this.log(`   Final Agent: ${invocationContext.agent.name ?? 'Unknown'}`);\n    return undefined;\n  }\n\n  override async beforeAgentCallback({\n    callbackContext,\n  }: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    this.log('\uD83E\uDD16 AGENT STARTING');\n    this.log(`   Agent Name: ${callbackContext.agentName}`);\n    this.log(`   Invocation ID: ${callbackContext.invocationId}`);\n    if (callbackContext.invocationContext.branch) {\n      this.log(`   Branch: ${callbackContext.invocationContext.branch}`);\n    }\n    return undefined;\n  }\n\n  override async afterAgentCallback({\n    callbackContext,\n  }: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    this.log('\uD83E\uDD16 AGENT COMPLETED');\n    this.log(`   Agent Name: ${callbackContext.agentName}`);\n    this.log(`   Invocation ID: ${callbackContext.invocationId}`);\n    return undefined;\n  }\n\n  override async beforeModelCallback({\n    callbackContext,\n    llmRequest,\n  }: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n  }): Promise<LlmResponse | undefined> {\n    this.log('\uD83E\uDDE0 LLM REQUEST');\n    this.log(`   Model: ${llmRequest.model ?? 'default'}`);\n    this.log(`   Agent: ${callbackContext.agentName}`);\n\n    if (llmRequest.config && llmRequest.config.systemInstruction) {\n      let sysInstruction = llmRequest.config.systemInstruction as string;\n      if (sysInstruction.length > 200) {\n        sysInstruction = sysInstruction.substring(0, 200) + '...';\n      }\n      this.log(`   System Instruction: '${sysInstruction}'`);\n    }\n\n    if (llmRequest.toolsDict) {\n      const toolNames = Object.keys(llmRequest.toolsDict);\n      this.log(`   Available Tools: ${toolNames}`);\n    }\n\n    return undefined;\n  }\n\n  override async afterModelCallback({\n    callbackContext,\n    llmResponse,\n  }: {\n    callbackContext: CallbackContext;\n    llmResponse: LlmResponse;\n  }): Promise<LlmResponse | undefined> {\n    this.log('\uD83E\uDDE0 LLM RESPONSE');\n    this.log(`   Agent: ${callbackContext.agentName}`);\n\n    if (llmResponse.errorCode) {\n      this.log(`   \u274C ERROR - Code: ${llmResponse.errorCode}`);\n      this.log(`   Error Message: ${llmResponse.errorMessage}`);\n    } else {\n      this.log(`   Content: ${this.formatContent(llmResponse.content)}`);\n      if (llmResponse.partial) {\n        this.log(`   Partial: ${llmResponse.partial}`);\n      }\n      if (llmResponse.turnComplete !== undefined) {\n        this.log(`   Turn Complete: ${llmResponse.turnComplete}`);\n      }\n    }\n\n    if (llmResponse.usageMetadata) {\n      this.log(\n        `   Token Usage - Input: ${llmResponse.usageMetadata.promptTokenCount}, Output: ${llmResponse.usageMetadata.candidatesTokenCount}`,\n      );\n    }\n\n    return undefined;\n  }\n\n  override async beforeToolCallback({\n    tool,\n    toolArgs,\n    toolContext,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n  }): Promise<Record<string, unknown> | undefined> {\n    this.log('\uD83D\uDD27 TOOL STARTING');\n    this.log(`   Tool Name: ${tool.name}`);\n    this.log(`   Agent: ${toolContext.agentName}`);\n    this.log(`   Function Call ID: ${toolContext.functionCallId}`);\n    this.log(`   Arguments: ${this.formatArgs(toolArgs)}`);\n    return undefined;\n  }\n\n  override async afterToolCallback({\n    tool,\n    toolContext,\n    result,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    result: Record<string, unknown>;\n  }): Promise<Record<string, unknown> | undefined> {\n    this.log('\uD83D\uDD27 TOOL COMPLETED');\n    this.log(`   Tool Name: ${tool.name}`);\n    this.log(`   Agent: ${toolContext.agentName}`);\n    this.log(`   Function Call ID: ${toolContext.functionCallId}`);\n    this.log(`   Result: ${this.formatArgs(result)}`);\n    return undefined;\n  }\n\n  override async onModelErrorCallback({\n    callbackContext,\n    error,\n  }: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n    error: Error;\n  }): Promise<LlmResponse | undefined> {\n    this.log('\uD83E\uDDE0 LLM ERROR');\n    this.log(`   Agent: ${callbackContext.agentName}`);\n    this.log(`   Error: ${error}`);\n\n    return undefined;\n  }\n\n  override async onToolErrorCallback({\n    tool,\n    toolArgs,\n    toolContext,\n    error,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    error: Error;\n  }): Promise<Record<string, unknown> | undefined> {\n    this.log('\uD83D\uDD27 TOOL ERROR');\n    this.log(`   Tool Name: ${tool.name}`);\n    this.log(`   Agent: ${toolContext.agentName}`);\n    this.log(`   Function Call ID: ${toolContext.functionCallId}`);\n    this.log(`   Arguments: ${this.formatArgs(toolArgs)}`);\n    this.log(`   Error: ${error}`);\n    return undefined;\n  }\n\n  private log(message: string): void {\n    const formattedMessage = `\\u001b[90m[${this.name}] ${message}\\u001b[0m`;\n    logger.info(formattedMessage);\n  }\n\n  private formatContent(content?: Content, maxLength = 200): string {\n    if (!content || !content.parts) {\n      return 'None';\n    }\n\n    const parts: string[] = [];\n    for (const part of content.parts) {\n      if (part.text) {\n        let text = part.text.trim();\n        if (text.length > maxLength) {\n          text = text.substring(0, maxLength) + '...';\n        }\n        parts.push(`text: '${text}'`);\n      } else if (part.functionCall) {\n        parts.push(`function_call: ${part.functionCall.name}`);\n      } else if (part.functionResponse) {\n        parts.push(`function_response: ${part.functionResponse.name}`);\n      } else if (part.codeExecutionResult) {\n        parts.push('code_execution_result');\n      } else {\n        parts.push('other_part');\n      }\n    }\n\n    return parts.join(' | ');\n  }\n\n  private formatArgs(args: Record<string, unknown>, maxLength = 300): string {\n    if (!args) {\n      return '{}';\n    }\n\n    let formatted = JSON.stringify(args);\n    if (formatted.length > maxLength) {\n      formatted = formatted.substring(0, maxLength) + '...}';\n    }\n    return formatted;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content} from '@google/genai';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {CallbackContext} from '../agents/callback_context.js';\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {Event} from '../events/event.js';\nimport {LlmRequest} from '../models/llm_request.js';\nimport {LlmResponse} from '../models/llm_response.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {ToolContext} from '../tools/tool_context.js';\nimport {logger} from '../utils/logger.js';\n\nimport {BasePlugin} from './base_plugin.js';\n\n/**\n * Manages the registration and execution of plugins.\n *\n * The PluginManager is an internal class that orchestrates the invocation of\n * plugin callbacks at key points in the SDK's execution lifecycle. It maintains\n * a list of registered plugins and ensures they are called in the order they\n * were registered.\n *\n * The core execution logic implements an \"early exit\" strategy: if any plugin\n * callback returns a non-`undefined` value, the execution of subsequent plugins\n * for that specific event is halted, and the returned value is propagated up\n * the call stack. This allows plugins to short-circuit operations like agent\n * runs, tool calls, or model requests.\n */\nexport class PluginManager {\n  private readonly plugins: Set<BasePlugin> = new Set();\n  /**\n   * Initializes the plugin service.\n   *\n   * @param plugins An optional list of plugins to register upon\n   *     initialization.\n   */\n  constructor(plugins?: BasePlugin[]) {\n    if (plugins) {\n      for (const plugin of plugins) {\n        this.registerPlugin(plugin);\n      }\n    }\n  }\n\n  /**\n   * Registers a new plugin.\n   *\n   * @param plugin The plugin instance to register.\n   * @throws If the same exact plugin or a plugin with the same name is already\n   *     registered.\n   */\n  registerPlugin(plugin: BasePlugin): void {\n    // Short circuit for duplicate objects or duplicate names\n    if (this.plugins.has(plugin)) {\n      throw new Error(`Plugin '${plugin.name}' already registered.`);\n    }\n    if (Array.from(this.plugins).some((p) => p.name === plugin.name)) {\n      throw new Error(`Plugin with name '${plugin.name}' already registered.`);\n    }\n\n    this.plugins.add(plugin);\n\n    logger.info(`Plugin '${plugin.name}' registered.`);\n  }\n\n  /**\n   * Retrieves a registered plugin by its name.\n   *\n   * @param pluginName The name of the plugin to retrieve.\n   * @returns The plugin instance if found, otherwise `undefined`.\n   */\n  getPlugin(pluginName: string): BasePlugin | undefined {\n    // Set operates on strict equality, we only want to match by name\n    return Array.from(this.plugins).find((p) => p.name === pluginName);\n  }\n\n  /**\n   * Runs the same callback for all plugins. This is a utility method to reduce\n   * duplication below.\n   *\n   * @param plugins The set of plugins to run\n   * @param callback A closure containing the callback method to run on each\n   *     plugin\n   * @param callbackName The name of the function being called in the closure\n   *     above. Used for logging purposes.\n   * @returns A promise containing the plugin method result. Must be casted to\n   *     the proper type for the plugin method.\n   */\n  private async runCallbacks(\n    plugins: Set<BasePlugin>,\n    callback: (plugin: BasePlugin) => Promise<unknown>,\n    callbackName: string,\n  ): Promise<unknown> {\n    for (const plugin of plugins) {\n      try {\n        const result = await callback(plugin);\n        if (result !== undefined) {\n          logger.debug(\n            `Plugin '${plugin.name}' returned a value for callback '${callbackName}', exiting early.`,\n          );\n          return result;\n        }\n      } catch (e) {\n        const errorMessage = `Error in plugin '${plugin.name}' during '${callbackName}' callback: ${e}`;\n        logger.error(errorMessage);\n        throw new Error(errorMessage);\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Runs the `onUserMessageCallback` for all plugins.\n   */\n  async runOnUserMessageCallback({\n    userMessage,\n    invocationContext,\n  }: {\n    userMessage: Content;\n    invocationContext: InvocationContext;\n  }): Promise<Content | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.onUserMessageCallback({userMessage, invocationContext}),\n      'onUserMessageCallback',\n    )) as Content | undefined;\n  }\n\n  /**\n   * Runs the `beforeRunCallback` for all plugins.\n   */\n  async runBeforeRunCallback({\n    invocationContext,\n  }: {\n    invocationContext: InvocationContext;\n  }): Promise<Content | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) => plugin.beforeRunCallback({invocationContext}),\n      'beforeRunCallback',\n    )) as Content | undefined;\n  }\n\n  /**\n   * Runs the `afterRunCallback` for all plugins.\n   */\n  async runAfterRunCallback({\n    invocationContext,\n  }: {\n    invocationContext: InvocationContext;\n  }): Promise<void> {\n    await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) => plugin.afterRunCallback({invocationContext}),\n      'afterRunCallback',\n    );\n  }\n\n  /**\n   * Runs the `onEventCallback` for all plugins.\n   */\n  async runOnEventCallback({\n    invocationContext,\n    event,\n  }: {\n    invocationContext: InvocationContext;\n    event: Event;\n  }): Promise<Event | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.onEventCallback({invocationContext, event}),\n      'onEventCallback',\n    )) as Event | undefined;\n  }\n\n  /**\n   * Runs the `beforeAgentCallback` for all plugins.\n   */\n  async runBeforeAgentCallback({\n    agent,\n    callbackContext,\n  }: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.beforeAgentCallback({agent, callbackContext}),\n      'beforeAgentCallback',\n    )) as Content | undefined;\n  }\n\n  /**\n   * Runs the `afterAgentCallback` for all plugins.\n   */\n  async runAfterAgentCallback({\n    agent,\n    callbackContext,\n  }: {\n    agent: BaseAgent;\n    callbackContext: CallbackContext;\n  }): Promise<Content | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.afterAgentCallback({agent, callbackContext}),\n      'afterAgentCallback',\n    )) as Content | undefined;\n  }\n\n  /**\n   * Runs the `beforeToolCallback` for all plugins.\n   */\n  async runBeforeToolCallback({\n    tool,\n    toolArgs,\n    toolContext,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n  }): Promise<Record<string, unknown> | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.beforeToolCallback({tool, toolArgs, toolContext}),\n      'beforeToolCallback',\n    )) as Record<string, unknown> | undefined;\n  }\n\n  /**\n   * Runs the `afterToolCallback` for all plugins.\n   */\n  async runAfterToolCallback({\n    tool,\n    toolArgs,\n    toolContext,\n    result,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    result: Record<string, unknown>;\n  }): Promise<Record<string, unknown> | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.afterToolCallback({tool, toolArgs, toolContext, result}),\n      'afterToolCallback',\n    )) as Record<string, unknown> | undefined;\n  }\n\n  /**\n   * Runs the `onModelErrorCallback` for all plugins.\n   */\n  async runOnModelErrorCallback({\n    callbackContext,\n    llmRequest,\n    error,\n  }: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n    error: Error;\n  }): Promise<LlmResponse | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.onModelErrorCallback({callbackContext, llmRequest, error}),\n      'onModelErrorCallback',\n    )) as LlmResponse | undefined;\n  }\n\n  /**\n   * Runs the `beforeModelCallback` for all plugins.\n   */\n  async runBeforeModelCallback({\n    callbackContext,\n    llmRequest,\n  }: {\n    callbackContext: CallbackContext;\n    llmRequest: LlmRequest;\n  }): Promise<LlmResponse | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.beforeModelCallback({callbackContext, llmRequest}),\n      'beforeModelCallback',\n    )) as LlmResponse | undefined;\n  }\n\n  /**\n   * Runs the `afterModelCallback` for all plugins.\n   */\n  async runAfterModelCallback({\n    callbackContext,\n    llmResponse,\n  }: {\n    callbackContext: CallbackContext;\n    llmResponse: LlmResponse;\n  }): Promise<LlmResponse | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.afterModelCallback({callbackContext, llmResponse}),\n      'afterModelCallback',\n    )) as LlmResponse | undefined;\n  }\n\n  /**\n   * Runs the `onToolErrorCallback` for all plugins.\n   */\n  async runOnToolErrorCallback({\n    tool,\n    toolArgs,\n    toolContext,\n    error,\n  }: {\n    tool: BaseTool;\n    toolArgs: Record<string, unknown>;\n    toolContext: ToolContext;\n    error: Error;\n  }): Promise<Record<string, unknown> | undefined> {\n    return (await this.runCallbacks(\n      this.plugins,\n      (plugin: BasePlugin) =>\n        plugin.onToolErrorCallback({tool, toolArgs, toolContext, error}),\n      'onToolErrorCallback',\n    )) as Record<string, unknown> | undefined;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {FunctionCall} from '@google/genai';\n\nimport {Event} from '../events/event.js';\nimport {BasePlugin} from '../plugins/base_plugin.js';\nimport {BaseTool} from '../tools/base_tool.js';\nimport {ToolConfirmation} from '../tools/tool_confirmation.js';\nimport {ToolContext} from '../tools/tool_context.js';\n\n// Constants\nexport const REQUEST_CONFIRMATION_FUNCTION_CALL_NAME =\n  'adk_request_confirmation';\n\nconst TOOL_CALL_SECURITY_CHECK_STATES = 'orcas_tool_call_security_check_states';\nconst INTERMEDIATE_REQUIRE_TOOL_CALL_CONFIRMATION_ERROR =\n  'This tool call needs external confirmation before completion.';\n\n// --------------------------------------------------------------------------\n// #START Policy Engine Interface\n// --------------------------------------------------------------------------\n\n/**\n * The outcome of a policy check.\n */\nexport enum PolicyOutcome {\n  // The tool call is rejected by the policy engine.\n  DENY = 'DENY',\n  // The tool call needs external confirmation before proceeding.\n  CONFIRM = 'CONFIRM',\n  // The tool call is allowed by the policy engine.\n  ALLOW = 'ALLOW',\n}\n\nexport interface PolicyCheckResult {\n  outcome: string;\n  reason?: string;\n}\n\nexport interface ToolCallPolicyContext {\n  tool: BaseTool;\n  toolArgs: Record<string, unknown>;\n}\n\nexport interface BasePolicyEngine {\n  evaluate(context: ToolCallPolicyContext): Promise<PolicyCheckResult>;\n}\n\nexport class InMemoryPolicyEngine implements BasePolicyEngine {\n  async evaluate(): Promise<PolicyCheckResult> {\n    // Default permissive implementation\n    return Promise.resolve({\n      outcome: PolicyOutcome.ALLOW,\n      reason: 'For prototyping purpose, all tool calls are allowed.',\n    });\n  }\n}\n// --------------------------------------------------------------------------\n// #END Policy Engine Interface\n// --------------------------------------------------------------------------\n\n/**\n *  Security Plugin for running Orcas agents.\n */\nexport class SecurityPlugin extends BasePlugin {\n  private readonly policyEngine: BasePolicyEngine;\n\n  constructor(params?: {policyEngine?: BasePolicyEngine}) {\n    super('security_plugin');\n    this.policyEngine = params?.policyEngine ?? new InMemoryPolicyEngine();\n  }\n\n  override async beforeToolCallback({\n    tool,\n    toolArgs,\n    toolContext,\n  }: {\n    tool: BaseTool;\n    toolArgs: {[key: string]: unknown};\n    toolContext: ToolContext;\n  }): Promise<{[key: string]: unknown} | undefined> {\n    const toolCallCheckState = this.getToolCallCheckState(toolContext);\n\n    // We only check the tool call policy ONCE, when the tool call is handled\n    // for the first time.\n    if (!toolCallCheckState) {\n      return this.checkToolCallPolicy({\n        tool: tool,\n        toolArgs: toolArgs,\n        toolContext: toolContext,\n      });\n    }\n\n    if (toolCallCheckState !== PolicyOutcome.CONFIRM) {\n      return;\n    }\n\n    if (!toolContext.toolConfirmation) {\n      return {partial: INTERMEDIATE_REQUIRE_TOOL_CALL_CONFIRMATION_ERROR};\n    }\n\n    this.setToolCallCheckState(toolContext, toolContext.toolConfirmation);\n    if (!toolContext.toolConfirmation.confirmed) {\n      return {\n        error: 'Tool call rejected from confirmation flow.',\n      };\n    }\n    toolContext.toolConfirmation = undefined;\n    return;\n  }\n\n  private getToolCallCheckState(\n    toolContext: ToolContext,\n  ): string | ToolConfirmation | undefined {\n    const {functionCallId} = toolContext;\n    if (!functionCallId) {\n      return;\n    }\n\n    const toolCallStates =\n      (toolContext.state.get(TOOL_CALL_SECURITY_CHECK_STATES) as {\n        [key: string]: string | ToolConfirmation;\n      }) ?? {};\n    return toolCallStates[functionCallId];\n  }\n\n  private setToolCallCheckState(\n    toolContext: ToolContext,\n    state: string | ToolConfirmation,\n  ): void {\n    const {functionCallId} = toolContext;\n    if (!functionCallId) {\n      return;\n    }\n\n    const toolCallStates =\n      (toolContext.state.get(TOOL_CALL_SECURITY_CHECK_STATES) as {\n        [key: string]: string | ToolConfirmation;\n      }) ?? {};\n    toolCallStates[functionCallId] = state;\n    toolContext.state.set(TOOL_CALL_SECURITY_CHECK_STATES, toolCallStates);\n  }\n\n  private async checkToolCallPolicy({\n    tool,\n    toolArgs,\n    toolContext,\n  }: {\n    tool: BaseTool;\n    toolArgs: {[key: string]: unknown};\n    toolContext: ToolContext;\n  }): Promise<{[key: string]: unknown} | undefined> {\n    const policyCheckResult = await this.policyEngine.evaluate({\n      tool,\n      toolArgs,\n    });\n\n    this.setToolCallCheckState(toolContext, policyCheckResult.outcome);\n\n    switch (policyCheckResult.outcome) {\n      case PolicyOutcome.DENY:\n        return {\n          error: `This tool call is rejected by policy engine. Reason: ${\n            policyCheckResult.reason\n          }`,\n        };\n      case PolicyOutcome.CONFIRM:\n        toolContext.requestConfirmation({\n          hint: `Policy engine requires confirmation calling tool: ${\n            tool.name\n          }. Reason: ${policyCheckResult.reason}`,\n        });\n        return {partial: INTERMEDIATE_REQUIRE_TOOL_CALL_CONFIRMATION_ERROR};\n      case PolicyOutcome.ALLOW:\n        return;\n      default:\n        return;\n    }\n  }\n}\n\n/**\n * Gets the ask user confirmation function calls from the event.\n * @param event The event to get the function calls from.\n * @returns The ask user confirmation function calls.\n */\nexport function getAskUserConfirmationFunctionCalls(\n  event: Event,\n): FunctionCall[] {\n  if (!event.content || !event.content.parts) {\n    return [];\n  }\n  const results: FunctionCall[] = [];\n\n  for (const part of event.content.parts) {\n    if (\n      part &&\n      part.functionCall &&\n      part.functionCall.name === REQUEST_CONFIRMATION_FUNCTION_CALL_NAME\n    ) {\n      results.push(part.functionCall);\n    }\n  }\n  return results;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {cloneDeep} from 'lodash-es';\n\nimport {Event} from '../events/event.js';\nimport {randomUUID} from '../utils/env_aware_utils.js';\nimport {logger} from '../utils/logger.js';\n\nimport {\n  AppendEventRequest,\n  BaseSessionService,\n  CreateSessionRequest,\n  DeleteSessionRequest,\n  GetSessionRequest,\n  ListSessionsRequest,\n  ListSessionsResponse,\n} from './base_session_service.js';\nimport {createSession, Session} from './session.js';\nimport {State} from './state.js';\n\n/**\n * An in-memory implementation of the session service.\n */\nexport class InMemorySessionService extends BaseSessionService {\n  /**\n   * A map from app name to a map from user ID to a map from session ID to\n   * session.\n   */\n  private sessions: Record<string, Record<string, Record<string, Session>>> =\n    {};\n\n  /**\n   * A map from app name to a map from user ID to a map from key to the value.\n   */\n  private userState: Record<string, Record<string, Record<string, unknown>>> =\n    {};\n\n  /**\n   * A map from app name to a map from key to the value.\n   */\n  private appState: Record<string, Record<string, unknown>> = {};\n\n  createSession({\n    appName,\n    userId,\n    state,\n    sessionId,\n  }: CreateSessionRequest): Promise<Session> {\n    const session = createSession({\n      id: sessionId || randomUUID(),\n      appName,\n      userId,\n      state,\n      events: [],\n      lastUpdateTime: Date.now(),\n    });\n\n    if (!this.sessions[appName]) {\n      this.sessions[appName] = {};\n    }\n    if (!this.sessions[appName][userId]) {\n      this.sessions[appName][userId] = {};\n    }\n\n    this.sessions[appName][userId][session.id] = session;\n\n    return Promise.resolve(\n      this.mergeState(appName, userId, cloneDeep(session)),\n    );\n  }\n\n  getSession({\n    appName,\n    userId,\n    sessionId,\n    config,\n  }: GetSessionRequest): Promise<Session | undefined> {\n    if (\n      !this.sessions[appName] ||\n      !this.sessions[appName][userId] ||\n      !this.sessions[appName][userId][sessionId]\n    ) {\n      return Promise.resolve(undefined);\n    }\n\n    const session: Session = this.sessions[appName][userId][sessionId];\n    const copiedSession = cloneDeep(session);\n\n    if (config) {\n      if (config.numRecentEvents) {\n        copiedSession.events = copiedSession.events.slice(\n          -config.numRecentEvents,\n        );\n      }\n      if (config.afterTimestamp) {\n        let i = copiedSession.events.length - 1;\n        while (i >= 0) {\n          if (copiedSession.events[i].timestamp < config.afterTimestamp) {\n            break;\n          }\n          i--;\n        }\n        if (i >= 0) {\n          copiedSession.events = copiedSession.events.slice(i + 1);\n        }\n      }\n    }\n\n    return Promise.resolve(this.mergeState(appName, userId, copiedSession));\n  }\n\n  listSessions({\n    appName,\n    userId,\n  }: ListSessionsRequest): Promise<ListSessionsResponse> {\n    if (!this.sessions[appName] || !this.sessions[appName][userId]) {\n      return Promise.resolve({sessions: []});\n    }\n\n    const sessionsWithoutEvents: Session[] = [];\n    for (const session of Object.values(this.sessions[appName][userId])) {\n      sessionsWithoutEvents.push(\n        createSession({\n          id: session.id,\n          appName: session.appName,\n          userId: session.userId,\n          state: {},\n          events: [],\n          lastUpdateTime: session.lastUpdateTime,\n        }),\n      );\n    }\n\n    return Promise.resolve({sessions: sessionsWithoutEvents});\n  }\n\n  async deleteSession({\n    appName,\n    userId,\n    sessionId,\n  }: DeleteSessionRequest): Promise<void> {\n    const session = await this.getSession({appName, userId, sessionId});\n\n    if (!session) {\n      return;\n    }\n\n    delete this.sessions[appName][userId][sessionId];\n  }\n\n  override async appendEvent({\n    session,\n    event,\n  }: AppendEventRequest): Promise<Event> {\n    await super.appendEvent({session, event});\n    session.lastUpdateTime = event.timestamp;\n\n    const appName = session.appName;\n    const userId = session.userId;\n    const sessionId = session.id;\n\n    const warning = (message: string) => {\n      logger.warn(`Failed to append event to session ${sessionId}: ${message}`);\n    };\n\n    if (!this.sessions[appName]) {\n      warning(`appName ${appName} not in sessions`);\n      return event;\n    }\n\n    if (!this.sessions[appName][userId]) {\n      warning(`userId ${userId} not in sessions[appName]`);\n      return event;\n    }\n\n    if (!this.sessions[appName][userId][sessionId]) {\n      warning(`sessionId ${sessionId} not in sessions[appName][userId]`);\n      return event;\n    }\n\n    if (event.actions && event.actions.stateDelta) {\n      for (const key of Object.keys(event.actions.stateDelta)) {\n        if (key.startsWith(State.APP_PREFIX)) {\n          this.appState[appName] = this.appState[appName] || {};\n          this.appState[appName][key.replace(State.APP_PREFIX, '')] =\n            event.actions.stateDelta[key];\n        }\n\n        if (key.startsWith(State.USER_PREFIX)) {\n          this.userState[appName] = this.userState[appName] || {};\n          this.userState[appName][userId] =\n            this.userState[appName][userId] || {};\n          this.userState[appName][userId][key.replace(State.USER_PREFIX, '')] =\n            event.actions.stateDelta[key];\n        }\n      }\n    }\n\n    const storageSession: Session = this.sessions[appName][userId][sessionId];\n    await super.appendEvent({session: storageSession, event});\n\n    storageSession.lastUpdateTime = event.timestamp;\n\n    return event;\n  }\n\n  private mergeState(\n    appName: string,\n    userId: string,\n    copiedSession: Session,\n  ): Session {\n    if (this.appState[appName]) {\n      for (const key of Object.keys(this.appState[appName])) {\n        copiedSession.state[State.APP_PREFIX + key] =\n          this.appState[appName][key];\n      }\n    }\n\n    if (!this.userState[appName] || !this.userState[appName][userId]) {\n      return copiedSession;\n    }\n\n    for (const key of Object.keys(this.userState[appName][userId])) {\n      copiedSession.state[State.USER_PREFIX + key] =\n        this.userState[appName][userId][key];\n    }\n    return copiedSession;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Event} from '../events/event.js';\n\nimport {Session} from './session.js';\nimport {State} from './state.js';\n\n/**\n * The configuration of getting a session.\n */\nexport interface GetSessionConfig {\n  /** The number of recent events to retrieve. */\n  numRecentEvents?: number;\n  /** Retrieve events after this timestamp. */\n  afterTimestamp?: number;\n}\n\n/**\n * The parameters for `createSession`.\n */\nexport interface CreateSessionRequest {\n  /** The name of the application. */\n  appName: string;\n  /** The ID of the user. */\n  userId: string;\n  /** The initial state of the session. */\n  state?: Record<string, unknown>;\n  /** The ID of the session. A new ID will be generated if not provided. */\n  sessionId?: string;\n}\n\n/**\n * The parameters for `getSession`.\n */\nexport interface GetSessionRequest {\n  /** The name of the application. */\n  appName: string;\n  /** The ID of the user. */\n  userId: string;\n  /** The ID of the session. */\n  sessionId: string;\n  /** The configurations for getting the session. */\n  config?: GetSessionConfig;\n}\n\n/**\n * The parameters for `listSessions`.\n */\nexport interface ListSessionsRequest {\n  /** The name of the application. */\n  appName: string;\n  /** The ID of the user. */\n  userId: string;\n}\n\n/**\n * The parameters for `deleteSession`.\n */\nexport interface DeleteSessionRequest {\n  /** The name of the application. */\n  appName: string;\n  /** The ID of the user. */\n  userId: string;\n  /** The ID of the session. */\n  sessionId: string;\n}\n\n/**\n * The parameters for `appendEvent`.\n */\nexport interface AppendEventRequest {\n  /** The session to append the event to. */\n  session: Session;\n  /** The event to append. */\n  event: Event;\n}\n\n/**\n * The response of listing sessions.\n *\n * The events and states are not set within each Session object.\n */\nexport interface ListSessionsResponse {\n  /** A list of sessions. */\n  sessions: Session[];\n}\n\n/**\n * Base class for session services.\n *\n * The service provides a set of methods for managing sessions and events.\n */\n// TODO - b/425992518: can held session internally to make the API simpler.\nexport abstract class BaseSessionService {\n  /**\n   * Creates a new session.\n   *\n   * @param request The request to create a session.\n   * @return A promise that resolves to the newly created session instance.\n   */\n  abstract createSession(request: CreateSessionRequest): Promise<Session>;\n\n  /**\n   * Gets a session.\n   *\n   * @param request The request to get a session.\n   * @return A promise that resolves to the session instance or undefined if not\n   *     found.\n   */\n  abstract getSession(request: GetSessionRequest): Promise<Session | undefined>;\n\n  /**\n   * Lists sessions for a user.\n   *\n   * @param request The request to list sessions.\n   * @return A promise that resolves to a list of sessions for the user.\n   */\n  abstract listSessions(\n    request: ListSessionsRequest,\n  ): Promise<ListSessionsResponse>;\n\n  /**\n   * Deletes a session.\n   *\n   * @param request The request to delete a session.\n   * @return A promise that resolves when the session is deleted.\n   */\n  abstract deleteSession(request: DeleteSessionRequest): Promise<void>;\n\n  /**\n   * Appends an event to a session.\n   *\n   * @param request The request to append an event.\n   * @return A promise that resolves to the event that was appended.\n   */\n  async appendEvent({session, event}: AppendEventRequest): Promise<Event> {\n    if (event.partial) {\n      return event;\n    }\n\n    this.updateSessionState({session, event});\n    session.events.push(event);\n\n    return event;\n  }\n\n  /**\n   * Updates the session state based on the event.\n   *\n   * @param request The request to update the session state.\n   */\n  private updateSessionState({session, event}: AppendEventRequest): void {\n    if (!event.actions || !event.actions.stateDelta) {\n      return;\n    }\n    for (const [key, value] of Object.entries(event.actions.stateDelta)) {\n      if (key.startsWith(State.TEMP_PREFIX)) {\n        continue;\n      }\n      session.state[key] = value;\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Event} from '../events/event.js';\n\n/**\n * Represents a session in a conversation between agents and users.\n */\nexport interface Session {\n  /**\n   * The unique identifier of the session.\n   */\n  id: string;\n\n  /**\n   * The name of the app.\n   */\n  appName: string;\n\n  /**\n   * The id of the user.\n   */\n  userId: string;\n\n  /**\n   * The state of the session.\n   */\n  state: Record<string, unknown>;\n\n  /**\n   * The events of the session, e.g. user input, model response, function\n   * call/response, etc.\n   */\n  events: Event[];\n\n  /**\n   * The last update time of the session.\n   */\n  lastUpdateTime: number;\n}\n\n/**\n * Creates a session from a partial session.\n *\n * @param params The partial session to create the session from.\n * @returns The session.\n */\nexport function createSession(\n  params: Partial<Session> & {\n    id: string;\n    appName: string;\n  },\n): Session {\n  return {\n    id: params.id,\n    appName: params.appName,\n    userId: params.userId || '',\n    state: params.state || {},\n    events: params.events || [],\n    lastUpdateTime: params.lastUpdateTime || 0,\n  };\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content, createPartFromText} from '@google/genai';\nimport {context, trace} from '@opentelemetry/api';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {\n  InvocationContext,\n  newInvocationContextId,\n} from '../agents/invocation_context.js';\nimport {isLlmAgent} from '../agents/llm_agent.js';\nimport {createRunConfig, RunConfig} from '../agents/run_config.js';\nimport {BaseArtifactService} from '../artifacts/base_artifact_service.js';\nimport {BaseCredentialService} from '../auth/credential_service/base_credential_service.js';\nimport {\n  BuiltInCodeExecutor,\n  isBuiltInCodeExecutor,\n} from '../code_executors/built_in_code_executor.js';\nimport {createEvent, Event, getFunctionCalls} from '../events/event.js';\nimport {createEventActions} from '../events/event_actions.js';\nimport {BaseMemoryService} from '../memory/base_memory_service.js';\nimport {BasePlugin} from '../plugins/base_plugin.js';\nimport {PluginManager} from '../plugins/plugin_manager.js';\nimport {BaseSessionService} from '../sessions/base_session_service.js';\nimport {Session} from '../sessions/session.js';\nimport {\n  runAsyncGeneratorWithOtelContext,\n  tracer,\n} from '../telemetry/tracing.js';\nimport {logger} from '../utils/logger.js';\nimport {isGemini2OrAbove} from '../utils/model_name.js';\n\n/**\n * The configuration parameters for the Runner.\n */\nexport interface RunnerConfig {\n  /**\n   * The application name.\n   */\n  appName: string;\n\n  /**\n   * The agent to run.\n   */\n  agent: BaseAgent;\n  plugins?: BasePlugin[];\n  artifactService?: BaseArtifactService;\n  sessionService: BaseSessionService;\n  memoryService?: BaseMemoryService;\n  credentialService?: BaseCredentialService;\n}\n\nexport class Runner {\n  readonly appName: string;\n  readonly agent: BaseAgent;\n  readonly pluginManager: PluginManager;\n  readonly artifactService?: BaseArtifactService;\n  readonly sessionService: BaseSessionService;\n  readonly memoryService?: BaseMemoryService;\n  readonly credentialService?: BaseCredentialService;\n\n  constructor(input: RunnerConfig) {\n    this.appName = input.appName;\n    this.agent = input.agent;\n    this.pluginManager = new PluginManager(input.plugins ?? []);\n    this.artifactService = input.artifactService;\n    this.sessionService = input.sessionService;\n    this.memoryService = input.memoryService;\n    this.credentialService = input.credentialService;\n  }\n\n  /**\n   * Runs the agent with the given message, and returns an async generator of\n   * events.\n   *\n   * @param params.userId The user ID of the session.\n   * @param params.sessionId The session ID of the session.\n   * @param params.newMessage A new message to append to the session.\n   * @param params.stateDelta An optional state delta to apply to the session.\n   * @param params.runConfig The run config for the agent.\n   * @yields The events generated by the agent.\n   */\n  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.\n  async *runAsync(params: {\n    userId: string;\n    sessionId: string;\n    newMessage: Content;\n    stateDelta?: Record<string, unknown>;\n    runConfig?: RunConfig;\n  }): AsyncGenerator<Event, void, undefined> {\n    const {userId, sessionId, stateDelta} = params;\n    const runConfig = createRunConfig(params.runConfig);\n    let newMessage = params.newMessage;\n\n    // =========================================================================\n    // Setup the session and invocation context\n    // =========================================================================\n    const span = tracer.startSpan('invocation');\n    const ctx = trace.setSpan(context.active(), span);\n    try {\n      yield* runAsyncGeneratorWithOtelContext<Runner, Event>(\n        ctx,\n        this,\n        async function* () {\n          const session = await this.sessionService.getSession({\n            appName: this.appName,\n            userId,\n            sessionId,\n          });\n\n          if (!session) {\n            if (!this.appName) {\n              throw new Error(\n                `Session lookup failed: appName must be provided in runner constructor`,\n              );\n            }\n            throw new Error(`Session not found: ${sessionId}`);\n          }\n\n          if (runConfig.supportCfc && isLlmAgent(this.agent)) {\n            const modelName = this.agent.canonicalModel.model;\n            if (!isGemini2OrAbove(modelName)) {\n              throw new Error(\n                `CFC is not supported for model: ${\n                  modelName\n                } in agent: ${this.agent.name}`,\n              );\n            }\n\n            if (!isBuiltInCodeExecutor(this.agent.codeExecutor)) {\n              this.agent.codeExecutor = new BuiltInCodeExecutor();\n            }\n          }\n\n          const invocationContext = new InvocationContext({\n            artifactService: this.artifactService,\n            sessionService: this.sessionService,\n            memoryService: this.memoryService,\n            credentialService: this.credentialService,\n            invocationId: newInvocationContextId(),\n            agent: this.agent,\n            session,\n            userContent: newMessage,\n            runConfig,\n            pluginManager: this.pluginManager,\n          });\n\n          // =========================================================================\n          // Preprocess plugins on user message\n          // =========================================================================\n          const pluginUserMessage =\n            await this.pluginManager.runOnUserMessageCallback({\n              userMessage: newMessage,\n              invocationContext,\n            });\n          if (pluginUserMessage) {\n            newMessage = pluginUserMessage as Content;\n          }\n\n          // =========================================================================\n          // Append user message to session\n          // =========================================================================\n          if (newMessage) {\n            if (!newMessage.parts?.length) {\n              throw new Error('No parts in the newMessage.');\n            }\n\n            // Directly saves the artifacts (if applicable) in the user message and\n            // replaces the artifact data with a file name placeholder.\n            // TODO - b/425992518: fix Runner<>>ArtifactService leaky abstraction.\n            if (runConfig.saveInputBlobsAsArtifacts) {\n              await this.saveArtifacts(\n                invocationContext.invocationId,\n                session.userId,\n                session.id,\n                newMessage,\n              );\n            }\n            // Append the user message to the session with optional state delta.\n            await this.sessionService.appendEvent({\n              session,\n              event: createEvent({\n                invocationId: invocationContext.invocationId,\n                author: 'user',\n                actions: stateDelta\n                  ? createEventActions({stateDelta})\n                  : undefined,\n                content: newMessage,\n              }),\n            });\n          }\n\n          // =========================================================================\n          // Determine which agent should handle the workflow resumption.\n          // =========================================================================\n          invocationContext.agent = this.determineAgentForResumption(\n            session,\n            this.agent,\n          );\n\n          // =========================================================================\n          // Run the agent with the plugins (aka hooks to apply in the lifecycle)\n          // =========================================================================\n          if (newMessage) {\n            // =========================================================================\n            // Run the agent with the plugins (aka hooks to apply in the lifecycle)\n            // =========================================================================\n            // Step 1: Run the before_run callbacks to see if we should early exit.\n            const beforeRunCallbackResponse =\n              await this.pluginManager.runBeforeRunCallback({\n                invocationContext,\n              });\n\n            if (beforeRunCallbackResponse) {\n              const earlyExitEvent = createEvent({\n                invocationId: invocationContext.invocationId,\n                author: 'model',\n                content: beforeRunCallbackResponse,\n              });\n              // TODO: b/447446338 - In the future, do *not* save live call audio\n              // content to session This is a feature in Python ADK\n              await this.sessionService.appendEvent({\n                session,\n                event: earlyExitEvent,\n              });\n              yield earlyExitEvent;\n            } else {\n              // Step 2: Otherwise continue with normal execution\n              for await (const event of invocationContext.agent.runAsync(\n                invocationContext,\n              )) {\n                if (!event.partial) {\n                  await this.sessionService.appendEvent({session, event});\n                }\n                // Step 3: Run the on_event callbacks to optionally modify the event.\n                const modifiedEvent =\n                  await this.pluginManager.runOnEventCallback({\n                    invocationContext,\n                    event,\n                  });\n                if (modifiedEvent) {\n                  yield modifiedEvent;\n                } else {\n                  yield event;\n                }\n              }\n              // Step 4: Run the after_run callbacks to optionally modify the context.\n              await this.pluginManager.runAfterRunCallback({invocationContext});\n            }\n          }\n        },\n      );\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Saves artifacts from the message parts and replaces the inline data with\n   * a file name placeholder.\n   *\n   * @param invocationId The current invocation ID.\n   * @param userId The user ID of the session.\n   * @param sessionId The session ID of the session.\n   * @param message The message containing parts to process.\n   */\n  private async saveArtifacts(\n    invocationId: string,\n    userId: string,\n    sessionId: string,\n    message: Content,\n  ): Promise<void> {\n    if (!this.artifactService || !message.parts?.length) {\n      return;\n    }\n\n    for (let i = 0; i < message.parts.length; i++) {\n      const part = message.parts[i];\n      if (!part.inlineData) {\n        continue;\n      }\n      const fileName = `artifact_${invocationId}_${i}`;\n      // TODO - b/425992518: group appname, userId, sessionId as a key.\n      await this.artifactService.saveArtifact({\n        appName: this.appName,\n        userId,\n        sessionId,\n        filename: fileName,\n        artifact: part,\n      });\n      // TODO - b/425992518: potentially buggy if accidentally exposed to LLM.\n      message.parts[i] = createPartFromText(\n        `Uploaded file: ${fileName}. It is saved into artifacts`,\n      );\n    }\n  }\n\n  /**\n   * Determines the next agent to run to continue the session. This is primarily\n   * used for session resumption.\n   */\n  // TODO - b/425992518: This is where LRO integration should happen.\n  // Needs clean up before we can generalize it.\n  private determineAgentForResumption(\n    session: Session,\n    rootAgent: BaseAgent,\n  ): BaseAgent {\n    // =========================================================================\n    // Case 1: If the last event is a function response, this returns the\n    // agent that made the original function call.\n    // =========================================================================\n    const event = findEventByLastFunctionResponseId(session.events);\n    if (event && event.author) {\n      return rootAgent.findAgent(event.author) || rootAgent;\n    }\n\n    // =========================================================================\n    // Case 2: Otherwise, find the last agent that emitted a message and is\n    // transferable across the agent tree.\n    // =========================================================================\n    // TODO - b/425992518: Optimize this, not going to work for long sessions.\n    // TODO - b/425992518: The behavior is dynamic, needs better documentation.\n    for (let i = session.events.length - 1; i >= 0; i--) {\n      logger.info('event: ', JSON.stringify(session.events[i]));\n      const event = session.events[i];\n      if (event.author === 'user' || !event.author) {\n        continue;\n      }\n\n      if (event.author === rootAgent.name) {\n        return rootAgent;\n      }\n\n      const agent = rootAgent.findSubAgent(event.author!);\n      if (!agent) {\n        logger.warn(\n          `Event from an unknown agent: ${event.author}, event id: ${event.id}`,\n        );\n        continue;\n      }\n      if (this.isRoutableLlmAgent(agent)) {\n        return agent;\n      }\n    }\n    // =========================================================================\n    // Case 3: default to root agent.\n    // =========================================================================\n    return rootAgent;\n  }\n\n  /**\n   * Whether the agent to run can transfer to any other agent in the agent tree.\n   *\n   * An agent is transferable if:\n   *  - It is an instance of `LlmAgent`.\n   *  - All its ancestors are also transferable (i.e., they have\n   *    `disallowTransferToParent` set to false).\n   *\n   * @param agentToRun The agent to check for transferability.\n   * @returns True if the agent can transfer, False otherwise.\n   */\n  private isRoutableLlmAgent(agentToRun: BaseAgent): boolean {\n    let agent: BaseAgent | undefined = agentToRun;\n    while (agent) {\n      if (!isLlmAgent(agent)) {\n        return false;\n      }\n      if (agent.disallowTransferToParent) {\n        return false;\n      }\n      agent = agent.parentAgent;\n    }\n    return true;\n  }\n  // TODO - b/425992518: Implement runLive and related methods.\n}\n\n/**\n * It iterates through the events in reverse order, and returns the event\n * containing a function call with a functionCall.id matching the\n * functionResponse.id from the last event in the session.\n */\n// TODO - b/425992518: a hack that used event log as transaction log. Fix.\nfunction findEventByLastFunctionResponseId(events: Event[]): Event | null {\n  if (!events.length) {\n    return null;\n  }\n\n  const lastEvent = events[events.length - 1];\n  const functionCallId = lastEvent.content?.parts?.find(\n    (part) => part.functionResponse,\n  )?.functionResponse?.id;\n  if (!functionCallId) {\n    return null;\n  }\n\n  // TODO - b/425992518: inefficient search, fix.\n  for (let i = events.length - 2; i >= 0; i--) {\n    const event = events[i];\n    // Looking for the system long running request euc function call.\n    const functionCalls = getFunctionCalls(event);\n    if (!functionCalls) {\n      continue;\n    }\n\n    for (const functionCall of functionCalls) {\n      if (functionCall.id === functionCallId) {\n        return event;\n      }\n    }\n  }\n  return null;\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {InMemoryArtifactService} from '../artifacts/in_memory_artifact_service.js';\nimport {InMemoryMemoryService} from '../memory/in_memory_memory_service.js';\nimport {BasePlugin} from '../plugins/base_plugin.js';\nimport {InMemorySessionService} from '../sessions/in_memory_session_service.js';\n\nimport {Runner} from './runner.js';\n\nexport class InMemoryRunner extends Runner {\n  constructor({\n    agent,\n    appName = 'InMemoryRunner',\n    plugins = [],\n  }: {\n    agent: BaseAgent;\n    appName?: string;\n    plugins?: BasePlugin[];\n  }) {\n    super({\n      appName,\n      agent,\n      plugins,\n      artifactService: new InMemoryArtifactService(),\n      sessionService: new InMemorySessionService(),\n      memoryService: new InMemoryMemoryService(),\n    });\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Content, FunctionDeclaration, Type} from '@google/genai';\n\nimport {BaseAgent} from '../agents/base_agent.js';\nimport {isLlmAgent} from '../agents/llm_agent.js';\nimport {Event} from '../events/event.js';\nimport {InMemoryMemoryService} from '../memory/in_memory_memory_service.js';\nimport {Runner} from '../runner/runner.js';\nimport {InMemorySessionService} from '../sessions/in_memory_session_service.js';\nimport {GoogleLLMVariant} from '../utils/variant_utils.js';\n\nimport {BaseTool, RunAsyncToolRequest} from './base_tool.js';\nimport {ForwardingArtifactService} from './forwarding_artifact_service.js';\n\n/**\n * The configuration of the agent tool.\n */\nexport interface AgentToolConfig {\n  /**\n   * The reference to the agent instance.\n   */\n  agent: BaseAgent;\n\n  /**\n   * Whether to skip summarization of the agent output.\n   */\n  skipSummarization?: boolean;\n}\n\n/**\n * A unique symbol to identify ADK agent classes.\n * Defined once and shared by all BaseTool instances.\n */\nconst AGENT_TOOL_SIGNATURE_SYMBOL = Symbol.for('google.adk.agentTool');\n\n/**\n * Type guard to check if an object is an instance of BaseTool.\n * @param obj The object to check.\n * @returns True if the object is an instance of BaseTool, false otherwise.\n */\nexport function isAgentTool(obj: unknown): obj is AgentTool {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    AGENT_TOOL_SIGNATURE_SYMBOL in obj &&\n    obj[AGENT_TOOL_SIGNATURE_SYMBOL] === true\n  );\n}\n\n/**\n * A tool that wraps an agent.\n *\n * This tool allows an agent to be called as a tool within a larger\n * application. The agent's input schema is used to define the tool's input\n * parameters, and the agent's output is returned as the tool's result.\n *\n *  @param config: The configuration of the agent tool.\n */\nexport class AgentTool extends BaseTool {\n  /** A unique symbol to identify ADK agent tool class. */\n  readonly [AGENT_TOOL_SIGNATURE_SYMBOL] = true;\n\n  private readonly agent: BaseAgent;\n\n  private readonly skipSummarization: boolean;\n\n  constructor(config: AgentToolConfig) {\n    super({\n      name: config.agent.name,\n      description: config.agent.description || '',\n    });\n    this.agent = config.agent;\n    this.skipSummarization = config.skipSummarization || false;\n  }\n\n  override _getDeclaration(): FunctionDeclaration {\n    let declaration: FunctionDeclaration;\n\n    if (isLlmAgent(this.agent) && this.agent.inputSchema) {\n      declaration = {\n        name: this.name,\n        description: this.description,\n        // TODO(b/425992518): We should not use the agent's input schema as is.\n        // It should be validated and possibly transformed. Consider similar\n        // logic to one we have in Python ADK.\n        parameters: this.agent.inputSchema,\n      };\n    } else {\n      declaration = {\n        name: this.name,\n        description: this.description,\n        parameters: {\n          type: Type.OBJECT,\n          properties: {\n            'request': {\n              type: Type.STRING,\n            },\n          },\n          required: ['request'],\n        },\n      };\n    }\n\n    if (this.apiVariant !== GoogleLLMVariant.GEMINI_API) {\n      const hasOutputSchema = isLlmAgent(this.agent) && this.agent.outputSchema;\n      declaration.response = hasOutputSchema\n        ? {type: Type.OBJECT}\n        : {type: Type.STRING};\n    }\n\n    return declaration;\n  }\n\n  override async runAsync({\n    args,\n    toolContext,\n  }: RunAsyncToolRequest): Promise<unknown> {\n    if (this.skipSummarization) {\n      toolContext.actions.skipSummarization = true;\n    }\n\n    const hasInputSchema = isLlmAgent(this.agent) && this.agent.inputSchema;\n    const content: Content = {\n      role: 'user',\n      parts: [\n        {\n          // TODO(b/425992518): Should be validated. Consider similar\n          // logic to one we have in Python ADK.\n          text: hasInputSchema\n            ? JSON.stringify(args)\n            : (args['request'] as string),\n        },\n      ],\n    };\n\n    const runner = new Runner({\n      appName: this.agent.name,\n      agent: this.agent,\n      artifactService: new ForwardingArtifactService(toolContext),\n      sessionService: new InMemorySessionService(),\n      memoryService: new InMemoryMemoryService(),\n      credentialService: toolContext.invocationContext.credentialService,\n    });\n\n    const session = await runner.sessionService.createSession({\n      appName: this.agent.name,\n      userId: 'tmp_user',\n      state: toolContext.state.toRecord(),\n    });\n\n    let lastEvent: Event | undefined;\n    for await (const event of runner.runAsync({\n      userId: session.userId,\n      sessionId: session.id,\n      newMessage: content,\n    })) {\n      if (event.actions.stateDelta) {\n        toolContext.state.update(event.actions.stateDelta);\n      }\n\n      lastEvent = event;\n    }\n\n    if (!lastEvent?.content?.parts?.length) {\n      return '';\n    }\n\n    const hasOutputSchema = isLlmAgent(this.agent) && this.agent.outputSchema;\n    const mergedText = lastEvent.content.parts\n      .map((part) => part.text)\n      .filter((text) => text)\n      .join('\\n');\n\n    // TODO - b/425992518: In case of output schema, the output should be\n    // validated. Consider similar logic to one we have in Python ADK.\n    return hasOutputSchema ? JSON.parse(mergedText) : mergedText;\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Part} from '@google/genai';\n\nimport {InvocationContext} from '../agents/invocation_context.js';\nimport {\n  BaseArtifactService,\n  DeleteArtifactRequest,\n  ListVersionsRequest,\n  LoadArtifactRequest,\n  SaveArtifactRequest,\n} from '../artifacts/base_artifact_service.js';\n\nimport {ToolContext} from './tool_context.js';\n\n/**\n * Artifact service that forwards to the parent tool context.\n */\nexport class ForwardingArtifactService implements BaseArtifactService {\n  private readonly invocationContext: InvocationContext;\n\n  constructor(private readonly toolContext: ToolContext) {\n    this.invocationContext = toolContext.invocationContext;\n  }\n\n  // TODO - b/425992518: Remove unnecessary parameters. We should rethink the\n  // abstraction layer to make it more clear.\n  async saveArtifact(request: SaveArtifactRequest): Promise<number> {\n    return this.toolContext.saveArtifact(request.filename, request.artifact);\n  }\n\n  async loadArtifact(request: LoadArtifactRequest): Promise<Part | undefined> {\n    return this.toolContext.loadArtifact(request.filename, request.version);\n  }\n\n  async listArtifactKeys(): Promise<string[]> {\n    return this.toolContext.listArtifacts();\n  }\n\n  async deleteArtifact(request: DeleteArtifactRequest): Promise<void> {\n    if (!this.toolContext.invocationContext.artifactService) {\n      throw new Error('Artifact service is not initialized.');\n    }\n\n    return this.toolContext.invocationContext.artifactService.deleteArtifact(\n      request,\n    );\n  }\n\n  async listVersions(request: ListVersionsRequest): Promise<number[]> {\n    if (!this.toolContext.invocationContext.artifactService) {\n      throw new Error('Artifact service is not initialized.');\n    }\n\n    return this.toolContext.invocationContext.artifactService.listVersions(\n      request,\n    );\n  }\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReadonlyContext} from '../agents/readonly_context.js';\nimport {LlmRequest} from '../models/llm_request.js';\n\nimport {BaseTool} from './base_tool.js';\nimport {ToolContext} from './tool_context.js';\n\n/**\n * Function to decide whether a tool should be exposed to LLM. Toolset\n * implementer could consider whether to accept such instance in the toolset's\n * constructor and apply the predicate in getTools method.\n */\nexport type ToolPredicate = (\n  tool: BaseTool,\n  readonlyContext: ReadonlyContext,\n) => boolean;\n\n/**\n * Base class for toolset.\n *\n * A toolset is a collection of tools that can be used by an agent.\n */\nexport abstract class BaseToolset {\n  constructor(readonly toolFilter: ToolPredicate | string[]) {}\n\n  /**\n   * Returns the tools that should be exposed to LLM.\n   *\n   * @param context Context used to filter tools available to the agent. If\n   *     not defined, all tools in the toolset are returned.\n   * @return A Promise that resolves to the list of tools.\n   */\n  abstract getTools(context?: ReadonlyContext): Promise<BaseTool[]>;\n\n  /**\n   * Closes the toolset.\n   *\n   * NOTE: This method is invoked, for example, at the end of an agent server's\n   * lifecycle or when the toolset is no longer needed. Implementations\n   * should ensure that any open connections, files, or other managed\n   * resources are properly released to prevent leaks.\n   *\n   * @return A Promise that resolves when the toolset is closed.\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Returns whether the tool should be exposed to LLM.\n   *\n   * @param tool The tool to check.\n   * @param context Context used to filter tools available to the agent.\n   * @return Whether the tool should be exposed to LLM.\n   */\n  protected isToolSelected(tool: BaseTool, context: ReadonlyContext): boolean {\n    if (!this.toolFilter) {\n      return true;\n    }\n\n    if (typeof this.toolFilter === 'function') {\n      return this.toolFilter(tool, context);\n    }\n\n    if (Array.isArray(this.toolFilter)) {\n      return (this.toolFilter as string[]).includes(tool.name);\n    }\n\n    return false;\n  }\n\n  /**\n   * Processes the outgoing LLM request for this toolset. This method will be\n   * called before each tool processes the llm request.\n   *\n   * Use cases:\n   * - Instead of let each tool process the llm request, we can let the toolset\n   *   process the llm request. e.g. ComputerUseToolset can add computer use\n   *   tool to the llm request.\n   *\n   * @param toolContext The context of the tool.\n   * @param llmRequest The outgoing LLM request, mutable this method.\n   */\n  async processLlmRequest(\n    toolContext: ToolContext, // eslint-disable-line @typescript-eslint/no-unused-vars\n    llmRequest: LlmRequest, // eslint-disable-line @typescript-eslint/no-unused-vars\n  ): Promise<void> {}\n}\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport {GenerateContentConfig} from '@google/genai';\n\nimport {isGemini1Model, isGeminiModel} from '../utils/model_name.js';\n\nimport {BaseTool, ToolProcessLlmRequest} from './base_tool.js';\n\n/**\n * A built-in tool that is automatically invoked by Gemini 2 models to retrieve\n * search results from Google Search.\n *\n * This tool operates internally within the model and does not require or\n * perform local code execution.\n */\nexport class GoogleSearchTool extends BaseTool {\n  constructor() {\n    super({name: 'google_search', description: 'Google Search Tool'});\n  }\n\n  runAsync(): Promise<unknown> {\n    // This is a built-in tool on server side, it's triggered by setting the\n    // corresponding request parameters.\n    return Promise.resolve();\n  }\n\n  override async processLlmRequest({\n    llmRequest,\n  }: ToolProcessLlmRequest): Promise<void> {\n    if (!llmRequest.model) {\n      return;\n    }\n\n    llmRequest.config = llmRequest.config || ({} as GenerateContentConfig);\n    llmRequest.config.tools = llmRequest.config.tools || [];\n\n    if (isGemini1Model(llmRequest.model)) {\n      if (llmRequest.config.tools.length > 0) {\n        throw new Error(\n          'Google search tool can not be used with other tools in Gemini 1.x.',\n        );\n      }\n\n      llmRequest.config.tools.push({\n        googleSearchRetrieval: {},\n      });\n\n      return;\n    }\n\n    if (isGeminiModel(llmRequest.model)) {\n      llmRequest.config.tools.push({\n        googleSearch: {},\n      });\n\n      return;\n    }\n\n    throw new Error(\n      `Google search tool is not supported for model ${llmRequest.model}`,\n    );\n  }\n}\n\n/**\n * A global instance of {@link GoogleSearchTool}.\n */\nexport const GOOGLE_SEARCH = new GoogleSearchTool();\n", "/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {FunctionDeclaration} from '@google/genai';\n\nimport {\n  FunctionTool,\n  ToolInputParameters,\n  ToolOptions,\n} from './function_tool.js';\n\n/**\n * A function tool that returns the result asynchronously.\n *\n * This tool is used for long-running operations that may take a significant\n * amount of time to complete. The framework will call the function. Once the\n * function returns, the response will be returned asynchronously to the\n * framework which is identified by the function_call_id.\n */\n\nconst LONG_RUNNING_INSTRUCTION = `\n\nNOTE: This is a long-running operation. Do not call this tool again if it has already returned some intermediate or pending status.`;\n\nexport class LongRunningFunctionTool<\n  TParameters extends ToolInputParameters = undefined,\n> extends FunctionTool<TParameters> {\n  /**\n   * The constructor acts as the user-friendly factory.\n   * @param options The configuration for the tool.\n   */\n  constructor(options: ToolOptions<TParameters>) {\n    super({...options, isLongRunning: true});\n  }\n\n  /**\n   * Provide a schema for the function.\n   */\n  override _getDeclaration(): FunctionDeclaration {\n    const declaration = super._getDeclaration();\n    if (declaration.description) {\n      declaration.description += LONG_RUNNING_INSTRUCTION;\n    } else {\n      declaration.description = LONG_RUNNING_INSTRUCTION.trimStart();\n    }\n    return declaration;\n  }\n}\n"],
  "mappings": "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",
  "names": ["ActiveStreamingTool", "params", "context", "trace", "createEventActions", "state", "__spreadValues", "mergeEventActions", "sources", "target", "result", "source", "createEvent", "params", "__spreadProps", "__spreadValues", "createNewEventId", "createEventActions", "isFinalResponse", "event", "getFunctionCalls", "getFunctionResponses", "hasTrailingCodeExecutionResult", "funcCalls", "part", "funcResponses", "_a", "stringifyContent", "ASCII_LETTERS_AND_NUMBERS", "id", "i", "context", "trace", "version", "GEN_AI_AGENT_DESCRIPTION", "GEN_AI_AGENT_NAME", "GEN_AI_CONVERSATION_ID", "GEN_AI_OPERATION_NAME", "GEN_AI_TOOL_CALL_ID", "GEN_AI_TOOL_DESCRIPTION", "GEN_AI_TOOL_NAME", "GEN_AI_TOOL_TYPE", "tracer", "trace", "version", "safeJsonSerialize", "obj", "_e", "traceAgentInvocation", "agent", "invocationContext", "span", "traceToolCall", "tool", "args", "functionResponseEvent", "_a", "_b", "shouldAddRequestResponseToSpans", "toolCallId", "toolResponse", "functionResponse", "traceMergedToolCalls", "responseEventId", "traceCallLlm", "eventId", "llmRequest", "llmResponse", "_c", "buildLlmRequestForTrace", "finishReasonValue", "buildLlmRequestForTrace", "llmRequest", "result", "_a", "responseSchema", "cleanConfig", "__objRest", "content", "part", "bindOtelContextToAsyncGenerator", "ctx", "generator", "context", "runAsyncGeneratorWithOtelContext", "otelContext", "generatorFnContext", "generatorFn", "shouldAddRequestResponseToSpans", "envValue", "State", "value", "delta", "key", "defaultValue", "__spreadValues", "ReadonlyContext", "invocationContext", "State", "CallbackContext", "ReadonlyContext", "invocationContext", "eventActions", "createEventActions", "State", "filename", "version", "artifact", "isBrowser", "UUID_MASK", "randomUUID", "uuid", "i", "randomValue", "base64Decode", "data", "isBrowser", "InvocationCostManager", "runConfig", "InvocationContext", "params", "newInvocationContextId", "randomUUID", "BASE_AGENT_SIGNATURE_SYMBOL", "isBaseAgent", "obj", "_a", "BaseAgent", "config", "validateAgentName", "getCannonicalCallback", "getRootAgent", "parentContext", "__asyncGenerator", "span", "tracer", "ctx", "trace", "context", "__yieldStar", "runAsyncGeneratorWithOtelContext", "beforeAgentCallbackEvent", "__await", "traceAgentInvocation", "iter", "__forAwait", "more", "temp", "error", "event", "afterAgentCallbackEvent", "name", "subAgent", "result", "InvocationContext", "__spreadProps", "__spreadValues", "invocationContext", "callbackContext", "CallbackContext", "callback", "content", "createEvent", "isIdentifier", "str", "rootAgent", "callbacks", "BaseLlmRequestProcessor", "BaseLlmResponseProcessor", "createUserContent", "isEmpty", "AuthHandler", "authConfig", "state", "credentialKey", "_a", "_b", "authSchemeType", "ToolConfirmation", "hint", "confirmed", "payload", "ToolContext", "CallbackContext", "params", "authConfig", "authHandler", "AuthHandler", "query", "hint", "payload", "ToolConfirmation", "LogLevel", "logLevel", "setLogLevel", "level", "SimpleLogger", "args", "getColoredPrefix", "NoOpLogger", "_level", "_args", "LOG_LEVEL_STR", "CONSOLE_COLOR_MAP", "RESET_COLOR", "currentLogger", "setLogger", "customLogger", "getLogger", "logger", "level", "args", "currentLogger", "AF_FUNCTION_CALL_ID_PREFIX", "REQUEST_EUC_FUNCTION_CALL_NAME", "REQUEST_CONFIRMATION_FUNCTION_CALL_NAME", "functionsExportedForTestingOnly", "handleFunctionCallList", "generateAuthEvent", "generateRequestConfirmationEvent", "generateClientFunctionCallId", "randomUUID", "populateClientFunctionCallId", "modelResponseEvent", "functionCalls", "getFunctionCalls", "functionCall", "removeClientFunctionCallId", "content", "part", "getLongRunningFunctionCalls", "toolsDict", "longRunningToolIds", "invocationContext", "functionResponseEvent", "_a", "isEmpty", "parts", "functionCallId", "authConfig", "requestEucFunctionCall", "createEvent", "functionCallEvent", "_b", "toolConfirmation", "originalFunctionCall", "call", "requestConfirmationFunctionCall", "callToolAsync", "tool", "args", "toolContext", "tracer", "span", "logger", "result", "traceToolCall", "buildResponseEvent", "functionResult", "responseResult", "handleFunctionCallsAsync", "beforeToolCallbacks", "afterToolCallbacks", "filters", "toolConfirmationDict", "functionResponseEvents", "filteredFunctionCalls", "getToolAndContext", "functionArgs", "functionResponse", "functionResponseError", "callback", "e", "onToolErrorResponse", "alteredFunctionResponse", "createUserContent", "mergedEvent", "mergeParallelFunctionResponseEvents", "traceMergedToolCalls", "ToolContext", "mergedParts", "event", "baseEvent", "actionsList", "mergedActions", "mergeEventActions", "LiveRequestQueue", "req", "resolve", "closeRequest", "content", "blob", "__asyncGenerator", "request", "__await", "context", "trace", "cloneDeep", "z", "BASE_CODE_EXECUTOR_SIGNATURE_SYMBOL", "isBaseCodeExecutor", "obj", "_a", "BaseCodeExecutor", "MODEL_NAME_PATTERN", "extractModelName", "modelString", "match", "isGeminiModel", "parseVersion", "versionString", "parts", "part", "isGemini1Model", "isGemini2OrAbove", "modelName", "parsedVersion", "BUILT_IN_CODE_EXECUTOR_SIGNATURE_SYMBOL", "isBuiltInCodeExecutor", "obj", "_a", "_b", "BuiltInCodeExecutor", "BaseCodeExecutor", "_params", "llmRequest", "isGemini2OrAbove", "Language", "Outcome", "cloneDeep", "extractCodeAndTruncateContent", "content", "codeBlockDelimiters", "_a", "i", "part", "textParts", "firstTextPart", "cloneDeep", "responseText", "leadingDelimiterPattern", "trailingDelimiterPattern", "match", "prefix", "codeStr", "buildExecutableCodePart", "code", "Language", "buildCodeExecutionResultPart", "codeExecutionResult", "Outcome", "finalResult", "f", "convertCodeExecutionParts", "codeBlockDelimiter", "executionResultDelimiters", "lastPart", "cloneDeep", "CONTEXT_KEY", "SESSION_ID_KEY", "PROCESSED_FILE_NAMES_KEY", "INPUT_FILE_KEY", "ERROR_COUNT_KEY", "CODE_EXECUTION_RESULTS_KEY", "CodeExecutorContext", "sessionState", "_a", "executionId", "fileNames", "inputFiles", "invocationId", "errorCounts", "code", "resultStdout", "resultStderr", "codeExecutionResults", "ADK_LABEL", "LANGUAGE_LABEL", "AGENT_ENGINE_TELEMETRY_TAG", "AGENT_ENGINE_TELEMETRY_ENV_VARIABLE_NAME", "_getDefaultLabels", "frameworkLabel", "version", "isBrowser", "languageLabel", "getClientLabels", "BASE_MODEL_SYMBOL", "isBaseLlm", "obj", "_a", "BaseLlm", "model", "headerValue", "getClientLabels", "llmRequest", "appendInstructions", "llmRequest", "instructions", "newInstructions", "setOutputSchema", "llmRequest", "schema", "createPartFromText", "FinishReason", "GoogleGenAI", "GoogleLLMVariant", "getGoogleLlmVariant", "getBooleanEnvVar", "envVar", "envVarValue", "GeminiLlmConnection", "geminiSession", "history", "contents", "content", "_a", "logger", "functionResponses", "part", "fr", "blob", "text", "__asyncGenerator", "createLlmResponse", "response", "_a", "usageMetadata", "candidate", "Gemini", "BaseLlm", "model", "apiKey", "vertexai", "project", "location", "headers", "canReadEnv", "vertexAIfromEnv", "llmRequest", "stream", "__asyncGenerator", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "logger", "__spreadValues", "streamResult", "__await", "thoughtText", "text", "usageMetadata", "lastResponse", "iter", "__forAwait", "more", "temp", "error", "response", "llmResponse", "createLlmResponse", "firstPart", "parts", "createPartFromText", "FinishReason", "combinedHeaders", "GoogleGenAI", "liveSession", "GeminiLlmConnection", "content", "part", "removeDisplayNameIfPresent", "dataObj", "LRUCache", "maxSize", "key", "item", "value", "lruKey", "_LLMRegistry", "model", "modelNameRegex", "llmCls", "logger", "regex", "cachedLlm", "llmClass", "LLMRegistry", "Gemini", "BASE_TOOL_SIGNATURE_SYMBOL", "isBaseTool", "obj", "_a", "BaseTool", "params", "llmRequest", "functionDeclaration", "tool", "findToolWithFunctionDeclarations", "getGoogleLlmVariant", "Type", "Type", "toJSONSchemaV3", "toJSONSchemaV4", "isZodSchema", "obj", "isZodV3Schema", "isZodV4Schema", "getZodTypeName", "schema", "_a", "_b", "schemaAny", "zod4Type", "isZodObject", "zodObjectToSchema", "ctx", "jsonSchema", "_c", "_d", "_e", "_f", "_g", "toSchema", "parameters", "Type", "isZodObject", "zodObjectToSchema", "FUNCTION_TOOL_SIGNATURE_SYMBOL", "isFunctionTool", "obj", "_a", "_b", "FunctionTool", "BaseTool", "options", "name", "req", "validatedArgs", "error", "errorMessage", "cloneDeep", "getContents", "events", "agentName", "currentBranch", "_a", "_b", "_c", "filteredEvents", "event", "isAuthEvent", "isToolConfirmationEvent", "isEventFromAnotherAgent", "convertForeignEvent", "resultEvents", "rearrangeEventsForLatestFunctionResponse", "rearrangeEventsForAsyncFunctionResponsesInHistory", "contents", "content", "cloneDeep", "removeClientFunctionCallId", "getCurrentTurnContents", "i", "part", "REQUEST_EUC_FUNCTION_CALL_NAME", "REQUEST_CONFIRMATION_FUNCTION_CALL_NAME", "_d", "_e", "_f", "argsText", "safeStringify", "responseText", "createEvent", "mergeFunctionResponseEvents", "mergedEvent", "partsInMergedEvent", "partIndicesInMergedEvent", "functionCallId", "latestEvent", "functionResponses", "getFunctionResponses", "functionResponsesIds", "response", "secondLatestEvent", "functionCallsFromSecondLatest", "getFunctionCalls", "functionCall", "functionCallEventIdx", "idx", "functionCalls", "functionCallIds", "fc", "id", "functionResponseEvents", "responses", "functionCallIdToResponseEventIndex", "functionResponse", "functionResponseEventsIndices", "responseIndex", "eventsToMerge", "a", "b", "index", "obj", "injectSessionState", "template", "readonlyContext", "invocationContext", "replaceMatchedKeyWithItsValue", "match", "key", "isOptional", "fileName", "artifact", "isValidStateName", "pattern", "result", "lastEnd", "matches", "replacement", "isIdentifierPattern", "isIdentifier", "s", "VALID_PREFIXES", "State", "variableName", "parts", "StreamingMode", "createRunConfig", "params", "__spreadValues", "validateMaxLlmCalls", "value", "logger", "ADK_AGENT_NAME_LABEL_KEY", "convertToolUnionToTools", "toolUnion", "context", "BaseTool", "BasicLlmRequestProcessor", "BaseLlmRequestProcessor", "invocationContext", "llmRequest", "__asyncGenerator", "_a", "agent", "isLlmAgent", "__spreadValues", "setOutputSchema", "BASIC_LLM_REQUEST_PROCESSOR", "IdentityLlmRequestProcessor", "si", "appendInstructions", "IDENTITY_LLM_REQUEST_PROCESSOR", "InstructionsLlmRequestProcessor", "LlmAgent", "rootAgent", "instruction", "requireStateInjection", "__await", "ReadonlyContext", "instructionWithState", "injectSessionState", "INSTRUCTIONS_LLM_REQUEST_PROCESSOR", "ContentRequestProcessor", "getContents", "getCurrentTurnContents", "CONTENT_REQUEST_PROCESSOR", "AgentTransferLlmRequestProcessor", "FunctionTool", "z", "args", "toolContext", "transferTargets", "ToolContext", "targetAgent", "targetAgents", "instructions", "targets", "peerAgent", "AGENT_TRANSFER_LLM_REQUEST_PROCESSOR", "RequestConfirmationLlmRequestProcessor", "events", "requestConfirmationFunctionResponses", "confirmationEventIndex", "i", "event", "responses", "getFunctionResponses", "foundConfirmation", "functionResponse", "REQUEST_CONFIRMATION_FUNCTION_CALL_NAME", "toolConfirmation", "ToolConfirmation", "functionCalls", "getFunctionCalls", "toolsToResumeWithConfirmation", "toolsToResumeWithArgs", "functionCall", "originalFunctionCall", "j", "eventToCheck", "functionResponses", "fr", "toolsList", "toolsDict", "tool", "functionResponseEvent", "handleFunctionCallList", "REQUEST_CONFIRMATION_LLM_REQUEST_PROCESSOR", "CodeExecutionRequestProcessor", "iter", "__forAwait", "runPreProcessor", "more", "temp", "error", "isBaseCodeExecutor", "content", "delimeters", "convertCodeExecutionParts", "DATA_FILE_UTIL_MAP", "DATA_FILE_HELPER_LIB", "CodeExecutionResponseProcessor", "llmResponse", "runPostProcessor", "responseProcessor", "codeExecutor", "isBuiltInCodeExecutor", "codeExecutorContext", "CodeExecutorContext", "State", "allInputFiles", "extractAndReplaceInlineFiles", "processedFileNames", "filesToProcess", "f", "file", "codeStr", "getDataFilePreprocessingCode", "codeContent", "buildExecutableCodePart", "cloneDeep", "createEvent", "executionId", "getOrSetExecutionId", "codeExecutionResult", "executionResultEvent", "postProcessCodeExecutionResult", "responseContent", "extractCodeAndTruncateContent", "savedFileNames", "part", "mimeType", "fileName", "base64Decode", "resultContent", "buildCodeExecutionResultPart", "eventActions", "createEventActions", "outputFile", "version", "getNormalizedFileName", "varName", "normalizedName", "loaderCode", "CODE_EXECUTION_REQUEST_PROCESSOR", "LLM_AGENT_SIGNATURE_SYMBOL", "obj", "_b", "_LlmAgent", "BaseAgent", "config", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "logger", "isBaseLlm", "LLMRegistry", "ancestorAgent", "resolvedTools", "tools", "callback", "isFinalResponse", "resultStr", "result", "e", "lastEvent", "_invocationContext", "processor", "modelResponseEvent", "span", "tracer", "ctx", "trace", "__yieldStar", "runAsyncGeneratorWithOtelContext", "createNewEventId", "mergedEvent", "populateClientFunctionCallId", "getLongRunningFunctionCalls", "handleFunctionCallsAsync", "authEvent", "generateAuthEvent", "toolConfirmationEvent", "generateRequestConfirmationEvent", "nextAgentName", "nextAgent", "agentName", "agentToRun", "beforeModelResponse", "llm", "responsesGenerator", "traceCallLlm", "alteredLlmResponse", "callbackContext", "CallbackContext", "beforeModelCallbackResponse", "callbackResponse", "afterModelCallbackResponse", "responseGenerator", "response", "modelError", "onModelErrorCallbackResponse", "errorResponse", "LOOP_AGENT_SIGNATURE_SYMBOL", "isLoopAgent", "obj", "_a", "_b", "LoopAgent", "BaseAgent", "config", "context", "__asyncGenerator", "iteration", "subAgent", "shouldExit", "iter", "__forAwait", "more", "temp", "error", "__await", "event", "_context", "PARALLEL_AGENT_SIGNATURE_SYMBOL", "isParallelAgent", "obj", "_a", "_b", "ParallelAgent", "BaseAgent", "context", "__asyncGenerator", "agentRuns", "subAgent", "createBranchCtxForSubAgent", "iter", "__forAwait", "mergeAgentRuns", "more", "temp", "error", "__await", "event", "_context", "agent", "originalContext", "invocationContext", "InvocationContext", "branchSuffix", "pendingPromises", "index", "generator", "promise", "result", "nextPromise", "TASK_COMPLETED_TOOL_NAME", "SEQUENTIAL_AGENT_SIGNATURE_SYMBOL", "isSequentialAgent", "obj", "_a", "_b", "SequentialAgent", "BaseAgent", "context", "__asyncGenerator", "subAgent", "iter", "__forAwait", "more", "temp", "error", "__await", "event", "isLlmAgent", "ReadonlyContext", "tool", "FunctionTool", "InMemoryArtifactService", "appName", "userId", "sessionId", "filename", "artifact", "path", "artifactPath", "version", "versions", "sessionPrefix", "usernamespacePrefix", "filenames", "artifacts", "i", "fileHasUserNamespace", "AuthCredentialTypes", "BASE_EXAMPLE_PROVIDER_SIGNATURE_SYMBOL", "isBaseExampleProvider", "obj", "_a", "BaseExampleProvider", "InMemoryMemoryService", "session", "userKey", "getUserKey", "event", "_a", "_b", "_c", "req", "wordsInQuery", "response", "sessionEvents", "joinedText", "part", "text", "wordsInEvent", "extractWordsLower", "queryWord", "formatTimestamp", "appName", "userId", "match", "timestamp", "BasePlugin", "name", "params", "LoggingPlugin", "BasePlugin", "name", "invocationContext", "userMessage", "_a", "event", "isFinalResponse", "functionCalls", "getFunctionCalls", "funcCalls", "fc", "functionResponses", "getFunctionResponses", "funcResponses", "fr", "callbackContext", "llmRequest", "sysInstruction", "toolNames", "llmResponse", "tool", "toolArgs", "toolContext", "result", "error", "message", "formattedMessage", "logger", "content", "maxLength", "parts", "part", "text", "args", "formatted", "PluginManager", "plugins", "plugin", "p", "logger", "pluginName", "callback", "callbackName", "result", "e", "errorMessage", "userMessage", "invocationContext", "event", "agent", "callbackContext", "tool", "toolArgs", "toolContext", "llmRequest", "error", "llmResponse", "REQUEST_CONFIRMATION_FUNCTION_CALL_NAME", "TOOL_CALL_SECURITY_CHECK_STATES", "INTERMEDIATE_REQUIRE_TOOL_CALL_CONFIRMATION_ERROR", "PolicyOutcome", "InMemoryPolicyEngine", "SecurityPlugin", "BasePlugin", "params", "_a", "tool", "toolArgs", "toolContext", "toolCallCheckState", "functionCallId", "state", "toolCallStates", "policyCheckResult", "getAskUserConfirmationFunctionCalls", "event", "results", "part", "cloneDeep", "BaseSessionService", "session", "event", "key", "value", "State", "createSession", "params", "InMemorySessionService", "BaseSessionService", "appName", "userId", "state", "sessionId", "session", "createSession", "randomUUID", "cloneDeep", "config", "copiedSession", "i", "sessionsWithoutEvents", "event", "warning", "message", "logger", "key", "State", "storageSession", "createPartFromText", "context", "trace", "Runner", "input", "_a", "PluginManager", "params", "__asyncGenerator", "userId", "sessionId", "stateDelta", "runConfig", "createRunConfig", "newMessage", "span", "tracer", "ctx", "trace", "context", "__yieldStar", "runAsyncGeneratorWithOtelContext", "session", "__await", "isLlmAgent", "modelName", "isGemini2OrAbove", "isBuiltInCodeExecutor", "BuiltInCodeExecutor", "invocationContext", "InvocationContext", "newInvocationContextId", "pluginUserMessage", "createEvent", "createEventActions", "beforeRunCallbackResponse", "earlyExitEvent", "iter", "__forAwait", "more", "temp", "error", "event", "modifiedEvent", "invocationId", "message", "i", "part", "fileName", "createPartFromText", "rootAgent", "findEventByLastFunctionResponseId", "logger", "agent", "agentToRun", "events", "_b", "_c", "_d", "functionCallId", "functionCalls", "getFunctionCalls", "functionCall", "InMemoryRunner", "Runner", "agent", "appName", "plugins", "InMemoryArtifactService", "InMemorySessionService", "InMemoryMemoryService", "Type", "ForwardingArtifactService", "toolContext", "request", "AGENT_TOOL_SIGNATURE_SYMBOL", "isAgentTool", "obj", "_a", "_b", "AgentTool", "BaseTool", "config", "declaration", "isLlmAgent", "Type", "hasOutputSchema", "args", "toolContext", "content", "runner", "Runner", "ForwardingArtifactService", "InMemorySessionService", "InMemoryMemoryService", "session", "lastEvent", "iter", "__forAwait", "more", "temp", "error", "event", "mergedText", "part", "text", "BaseToolset", "toolFilter", "tool", "context", "toolContext", "llmRequest", "GoogleSearchTool", "BaseTool", "llmRequest", "isGemini1Model", "isGeminiModel", "GOOGLE_SEARCH", "LONG_RUNNING_INSTRUCTION", "LongRunningFunctionTool", "FunctionTool", "options", "__spreadProps", "__spreadValues", "declaration"]
}
